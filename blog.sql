/*
 Navicat Premium Data Transfer

 Source Server         : blog-connection
 Source Server Type    : MySQL
 Source Server Version : 80017
 Source Host           : 47.101.223.154:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80017
 File Encoding         : 65001

 Date: 23/03/2020 22:23:36
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `title` varchar(512) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '文章标题，长度为64',
  `corpus_id` int(10) UNSIGNED NOT NULL COMMENT '所属文集id',
  `user_id` int(10) UNSIGNED NOT NULL COMMENT '文章所属用户id',
  `word_num` int(10) UNSIGNED NOT NULL DEFAULT 0 COMMENT '文章字数，默认0',
  `read_num` int(10) UNSIGNED NOT NULL DEFAULT 0 COMMENT '阅读数量，默认0',
  `love_num` int(10) UNSIGNED NOT NULL DEFAULT 0,
  `release_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '发布时间，每次更新后，变化成更新时间',
  `comment_num` int(11) NOT NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 106 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES (10, 'docker----docker--Error-response-from-daemon--error-while-creating-mou', 5, 1, 462, 0, 0, '2020-01-14 14:31:45', 0);
INSERT INTO `blog` VALUES (11, 'docker----dockerfile文件', 5, 1, 1604, 0, 0, '2020-01-14 14:31:45', 0);
INSERT INTO `blog` VALUES (12, 'docker----dockfile指令简记', 5, 1, 6079, 0, 0, '2020-01-14 14:31:45', 0);
INSERT INTO `blog` VALUES (13, 'docker----学习简记', 5, 1, 1661, 0, 0, '2020-01-14 14:31:45', 0);
INSERT INTO `blog` VALUES (14, 'docker----提交docker容器快照到dockerhub', 5, 1, 2578, 0, 0, '2020-01-14 14:31:45', 0);
INSERT INTO `blog` VALUES (15, 'docker----解决宿主机无法连接docker容器中运行的mysql问题', 5, 1, 413, 0, 0, '2020-01-14 14:31:46', 0);
INSERT INTO `blog` VALUES (16, 'es----ElasticSearch的安装到使用（简易）', 12, 1, 1796, 0, 0, '2020-01-14 14:31:46', 0);
INSERT INTO `blog` VALUES (17, 'exception----trying-to-create-too-many-buckets--must-be-less-than-or-e', 12, 1, 697, 0, 0, '2020-01-14 14:31:46', 0);
INSERT INTO `blog` VALUES (18, 'jenkins部署脚本出错', 12, 1, 48, 0, 0, '2020-01-14 14:31:46', 0);
INSERT INTO `blog` VALUES (19, 'J2ee----详解Servlet', 13, 1, 15300, 0, 0, '2020-01-14 14:31:47', 0);
INSERT INTO `blog` VALUES (20, '（转）CAP和BASE理论', 13, 1, 1727, 0, 0, '2020-01-14 14:31:47', 0);
INSERT INTO `blog` VALUES (21, 'Java(转)----How-to-start-working-with-Lambda-Expressions-in-Java', 1, 1, 5948, 0, 0, '2020-01-14 14:31:47', 0);
INSERT INTO `blog` VALUES (22, 'Java----GregorianCalendar的使用', 1, 1, 3221, 0, 0, '2020-01-14 14:31:47', 0);
INSERT INTO `blog` VALUES (23, 'Java----NioSocket的简单使用', 1, 1, 9615, 0, 0, '2020-01-14 14:31:48', 0);
INSERT INTO `blog` VALUES (24, 'Java----Pattern与Matcher使用实例', 1, 1, 8129, 0, 0, '2020-01-14 14:31:48', 0);
INSERT INTO `blog` VALUES (25, 'java----从计算机存储形式分析java中基本类型', 1, 1, 4193, 0, 0, '2020-01-14 14:31:48', 0);
INSERT INTO `blog` VALUES (26, 'Java----使用nioSocket获取和返回http报文', 1, 1, 10060, 0, 0, '2020-01-14 14:31:48', 0);
INSERT INTO `blog` VALUES (27, 'java----并发编程散记', 1, 1, 2778, 0, 0, '2020-01-14 14:31:48', 0);
INSERT INTO `blog` VALUES (28, 'Java----数据类型解惑', 1, 1, 4388, 0, 0, '2020-01-14 14:31:49', 0);
INSERT INTO `blog` VALUES (29, 'Java----正则表达式简单记录', 1, 1, 6981, 0, 0, '2020-01-14 14:31:49', 0);
INSERT INTO `blog` VALUES (30, 'java（转）----Java8的HashMap详解（存储结构，功能实现，扩容优化，线程安全，遍历方法）', 1, 1, 16305, 0, 0, '2020-01-14 14:31:49', 0);
INSERT INTO `blog` VALUES (31, 'Java（转）----linux使用wget下载jdk包总为5k大小问题', 1, 1, 703, 0, 0, '2020-01-14 14:31:49', 0);
INSERT INTO `blog` VALUES (32, '正则表达式', 1, 1, 3028, 0, 0, '2020-01-14 14:31:49', 0);
INSERT INTO `blog` VALUES (33, '转载java----xml文件的读取', 1, 1, 67, 0, 0, '2020-01-14 14:31:50', 0);
INSERT INTO `blog` VALUES (34, 'Linux-----etc-xinetd-d文件夹下非独立运行的配置文件的格式详解', 4, 1, 531, 0, 0, '2020-01-14 14:31:50', 0);
INSERT INTO `blog` VALUES (35, 'Linux----buffer和cache的区别', 4, 1, 398, 0, 0, '2020-01-14 14:31:50', 0);
INSERT INTO `blog` VALUES (36, 'Linux----centos-u盘挂载详细过程及问题（开启虚拟机读取U盘功能、关闭centos的自动挂载）', 4, 1, 1917, 0, 0, '2020-01-14 14:31:50', 0);
INSERT INTO `blog` VALUES (37, 'Linux----centos下的umask详解（翻译）', 4, 1, 5138, 0, 0, '2020-01-14 14:31:50', 0);
INSERT INTO `blog` VALUES (38, 'Linux----centos下的文件与文件操作', 4, 1, 3353, 0, 0, '2020-01-14 14:31:50', 0);
INSERT INTO `blog` VALUES (39, 'Linux----centos云服务器安装jdk', 4, 1, 762, 0, 0, '2020-01-14 14:31:51', 0);
INSERT INTO `blog` VALUES (40, 'Linux----centos云服务器安装配置tomcat', 4, 1, 1595, 0, 0, '2020-01-14 14:31:51', 0);
INSERT INTO `blog` VALUES (41, 'Linux----centos使用yum安装配置mysql', 4, 1, 715, 0, 0, '2020-01-14 14:31:51', 0);
INSERT INTO `blog` VALUES (42, 'Linux----netstat--tunlp命令简记', 4, 1, 477, 0, 0, '2020-01-14 14:31:51', 0);
INSERT INTO `blog` VALUES (43, 'Linux----rpm--ivh下载包出现库找不到类似libc-so-6-is-needed-by-xinetd-2-2-3-14-20-', 4, 1, 1396, 0, 0, '2020-01-14 14:31:51', 0);
INSERT INTO `blog` VALUES (44, 'Linux----sed方法实现精准匹配', 4, 1, 180, 0, 0, '2020-01-14 14:31:52', 0);
INSERT INTO `blog` VALUES (45, 'Linux----vi-vim编辑器的使用', 4, 1, 4087, 0, 0, '2020-01-14 14:31:52', 0);
INSERT INTO `blog` VALUES (46, 'Linux----命令行简记', 4, 1, 4120, 0, 0, '2020-01-14 14:31:52', 0);
INSERT INTO `blog` VALUES (47, 'Linux----用户管理相关知识简介', 4, 1, 10357, 0, 0, '2020-01-14 14:31:52', 0);
INSERT INTO `blog` VALUES (48, 'Linux----较新版linux系统vi不能强制保存只读文件错误', 4, 1, 553, 0, 0, '2020-01-14 14:31:52', 0);
INSERT INTO `blog` VALUES (49, 'Linux----黑马程序员Linux教学视频简记', 4, 1, 8787, 0, 0, '2020-01-14 14:31:53', 0);
INSERT INTO `blog` VALUES (50, 'Linux（转）----centos关于线程命令简记', 4, 1, 5463, 0, 0, '2020-01-14 14:31:53', 0);
INSERT INTO `blog` VALUES (51, 'Linux（转）----linux下创建和删除软、硬链接', 4, 1, 4266, 0, 0, '2020-01-14 14:31:53', 0);
INSERT INTO `blog` VALUES (52, 'Linux（转）----关于特殊权限（SUID-SGID-SBIT）', 4, 1, 8117, 0, 0, '2020-01-14 14:31:53', 0);
INSERT INTO `blog` VALUES (53, 'Mybatis----完成HelloWorld程序', 8, 1, 3674, 0, 0, '2020-01-14 14:31:54', 0);
INSERT INTO `blog` VALUES (54, 'shiro----shiro简单使用与流程分析（一）', 14, 1, 8452, 0, 0, '2020-01-14 14:31:54', 0);
INSERT INTO `blog` VALUES (55, 'shiro----shiro简单使用与流程分析（三）加密', 14, 1, 3866, 0, 0, '2020-01-14 14:31:54', 0);
INSERT INTO `blog` VALUES (56, 'shiro----shiro简单使用与流程分析（二）授权', 14, 1, 6283, 0, 0, '2020-01-14 14:31:54', 0);
INSERT INTO `blog` VALUES (57, 'shiro----shiro简单使用与流程分析（四）会话管理', 14, 1, 1, 0, 0, '2020-01-14 14:31:55', 0);
INSERT INTO `blog` VALUES (58, '用shiro用到自闭', 14, 1, 311, 0, 0, '2020-01-14 14:31:55', 0);
INSERT INTO `blog` VALUES (59, 'spring----bean生命周期的探索', 6, 1, 5932, 0, 0, '2020-01-14 14:31:55', 0);
INSERT INTO `blog` VALUES (60, 'Spring----使用mysql时碰上的问题', 6, 1, 2352, 0, 0, '2020-01-14 14:31:55', 0);
INSERT INTO `blog` VALUES (61, 'Spring----使用时IOException-parsing-XML-document-from-class-path-resource', 6, 1, 2976, 0, 0, '2020-01-14 14:31:55', 0);
INSERT INTO `blog` VALUES (62, 'Spring----对于AOP的理解', 6, 1, 5149, 0, 0, '2020-01-14 14:31:56', 0);
INSERT INTO `blog` VALUES (63, 'Spring（转）----IoC-spring-的灵魂(带你轻松理解IOC思想及bean对象的生成过程)', 6, 1, 10400, 0, 0, '2020-01-14 14:31:56', 0);
INSERT INTO `blog` VALUES (64, 'spring-boot----使用spring-initializer创建springboot项目于时的相关知识点！', 7, 1, 194, 0, 0, '2020-01-14 14:31:56', 0);
INSERT INTO `blog` VALUES (65, 'spring-boot----关于web应用的自动配置和自定义支持', 7, 1, 4952, 0, 0, '2020-01-14 14:31:56', 0);
INSERT INTO `blog` VALUES (66, 'spring-boot----自动加载机制', 7, 1, 1945, 0, 0, '2020-01-14 14:31:56', 0);
INSERT INTO `blog` VALUES (67, 'spring-boot----静态资源映射规则', 7, 1, 5948, 0, 0, '2020-01-14 14:31:57', 0);
INSERT INTO `blog` VALUES (68, '2018-09-10晚--Web服务与RESTful技术听课笔记', 17, 1, 3922, 0, 0, '2020-01-14 14:31:57', 0);
INSERT INTO `blog` VALUES (69, 'IDEA----亲身体验后觉得不可缺少的idea插件', 18, 1, 1, 0, 0, '2020-01-14 14:31:57', 0);
INSERT INTO `blog` VALUES (70, '初来乍到，简书请多指教！', 19, 1, 571, 0, 0, '2020-01-14 14:31:57', 0);
INSERT INTO `blog` VALUES (71, '网咖如雨后春笋，新华书店门可罗雀', 19, 1, 1255, 0, 0, '2020-01-14 14:31:58', 0);
INSERT INTO `blog` VALUES (72, '电脑无法锁定任务栏解决五步走', 20, 1, 827, 0, 0, '2020-01-14 14:31:58', 0);
INSERT INTO `blog` VALUES (73, '计算机组成原理(转)----何为电脑和系统的32位和64位属性', 20, 1, 5171, 0, 0, '2020-01-14 14:31:58', 0);
INSERT INTO `blog` VALUES (74, '（转）ASCii码、Unicode和UTF介绍', 20, 1, 1341, 0, 0, '2020-01-14 14:31:58', 0);
INSERT INTO `blog` VALUES (75, 'driud（转）----配置属性表', 21, 1, 2582, 0, 0, '2020-01-14 14:31:58', 0);
INSERT INTO `blog` VALUES (76, 'mysql----innoDB事务与锁测试的操作', 21, 1, 6400, 0, 0, '2020-01-14 14:31:59', 0);
INSERT INTO `blog` VALUES (77, '数据库（转）-----脏读、不可重复读和幻读以及隔离级别！', 21, 1, 1050, 0, 0, '2020-01-14 14:31:59', 0);
INSERT INTO `blog` VALUES (78, '数据库（转）----Sql-Server用户名和登录名的关系总结', 21, 1, 6673, 0, 0, '2020-01-14 14:31:59', 0);
INSERT INTO `blog` VALUES (79, 'ACM----从1-10w（乱序）这10w个数中随机去除一个数，求出去除的是哪个数，要求时间O(n),-空间O(1)', 22, 1, 21, 0, 0, '2020-01-14 14:31:59', 0);
INSERT INTO `blog` VALUES (80, 'ACM----已知前序遍历序列和后序遍历序列求后序遍历序列', 22, 1, 1598, 0, 0, '2020-01-14 14:31:59', 0);
INSERT INTO `blog` VALUES (81, 'ACM----相关余数定理及相关题目', 22, 1, 613, 0, 0, '2020-01-14 14:32:00', 0);
INSERT INTO `blog` VALUES (82, 'hanoi塔问题的自己的理解及相关竞赛题的解答', 23, 1, 3575, 0, 0, '2020-01-14 14:32:00', 0);
INSERT INTO `blog` VALUES (83, 'J2EE----关于Servlet的代码知识整理', 23, 1, 11789, 0, 0, '2020-01-14 14:32:00', 0);
INSERT INTO `blog` VALUES (84, 'J2EE----几个易混淆点', 23, 1, 2697, 0, 0, '2020-01-14 14:32:01', 0);
INSERT INTO `blog` VALUES (85, 'J2EE----实现jsp运用Servlet-Cookie达到记住账号密码功能', 23, 1, 9429, 0, 0, '2020-01-14 14:32:01', 0);
INSERT INTO `blog` VALUES (86, 'J2EE----整理的html5相关知识', 23, 1, 4203, 0, 0, '2020-01-14 14:32:01', 0);
INSERT INTO `blog` VALUES (87, 'J2EE----用servlet在jsp页面中实现二维码的生成、刷新', 23, 1, 3598, 0, 0, '2020-01-14 14:32:01', 0);
INSERT INTO `blog` VALUES (88, 'J2EE----过滤器实践', 23, 1, 8942, 0, 0, '2020-01-14 14:32:02', 0);
INSERT INTO `blog` VALUES (89, 'J2EE----运用Sevlet实现上传图片至网页', 23, 1, 2829, 0, 0, '2020-01-14 14:32:02', 0);
INSERT INTO `blog` VALUES (90, 'java----对java以及Kotlin中泛型型变的相关认识！', 23, 1, 3897, 0, 0, '2020-01-14 14:32:02', 0);
INSERT INTO `blog` VALUES (91, 'java----编程时--TODO注释的作用', 23, 1, 521, 0, 0, '2020-01-14 14:32:02', 0);
INSERT INTO `blog` VALUES (92, 'Linux----实操腾讯云Linux-ubuntu系统的jdk及tomcat的配置', 23, 1, 4323, 0, 0, '2020-01-14 14:32:02', 0);
INSERT INTO `blog` VALUES (93, '云服务器一键配置lamp后mysql实现外网navicat连接', 23, 1, 3199, 0, 0, '2020-01-14 14:32:03', 0);
INSERT INTO `blog` VALUES (94, '软件测试----决策表法', 23, 1, 2112, 0, 0, '2020-01-14 14:32:03', 0);
INSERT INTO `blog` VALUES (95, '软件测试----等价类划分', 23, 1, 3724, 0, 0, '2020-01-14 14:32:03', 0);
INSERT INTO `blog` VALUES (96, 'rabbitmq----rabbit相关概念及五种模式的实现', 24, 1, 24968, 0, 0, '2020-01-14 14:32:03', 0);
INSERT INTO `blog` VALUES (97, '缓存----数据库缓存一致性问题简记', 25, 1, 2013, 0, 0, '2020-01-14 14:32:03', 0);
INSERT INTO `blog` VALUES (98, '计组----计算机中的数字表示（原码、反码和补码）', 26, 1, 658, 0, 0, '2020-01-14 14:32:04', 0);
INSERT INTO `blog` VALUES (99, '计算机网络----DNS协议、TCP-IP协议与Socket', 27, 1, 2218, 0, 0, '2020-01-14 14:32:04', 0);
INSERT INTO `blog` VALUES (100, '计算机网络----http缓存控制知识整理', 27, 1, 3563, 0, 0, '2020-01-14 14:32:04', 0);
INSERT INTO `blog` VALUES (101, '计算机网络----浏览器输入url到页面显示完全的中间详细过程', 27, 1, 211, 0, 0, '2020-01-14 14:32:04', 0);
INSERT INTO `blog` VALUES (102, '计算机网络（转）-----QQ通信原理及QQ是怎么穿透内网进行通信的？', 27, 1, 7047, 0, 0, '2020-01-14 14:32:04', 0);
INSERT INTO `blog` VALUES (103, '2018----我真的是太菜了', 28, 1, 267, 0, 0, '2020-01-14 14:32:05', 0);
INSERT INTO `blog` VALUES (104, '开发杂记', 28, 1, 2149, 0, 0, '2020-01-14 14:32:05', 0);
INSERT INTO `blog` VALUES (105, '随笔记之许多有关linux的国外网站', 28, 1, 194, 0, 0, '2020-01-14 14:32:05', 0);

-- ----------------------------
-- Table structure for blog_collection
-- ----------------------------
DROP TABLE IF EXISTS `blog_collection`;
CREATE TABLE `blog_collection`  (
  `user_id` int(10) UNSIGNED NOT NULL,
  `blog_id` int(10) UNSIGNED NOT NULL,
  `author_id` int(10) UNSIGNED NOT NULL,
  `collect_corpus_id` int(10) UNSIGNED NOT NULL COMMENT '记住这个功能，平常很喜欢将某些特别喜欢文章转载为自己的，这里可以实现直接将文章收藏为自己的，保存在自己的文集中。前端可以选择是否展示。',
  PRIMARY KEY (`blog_id`, `user_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for blog_content
-- ----------------------------
DROP TABLE IF EXISTS `blog_content`;
CREATE TABLE `blog_content`  (
  `blog_id` int(10) UNSIGNED NOT NULL COMMENT '文章内容所属文章id',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '内容，markdown的文本形式，最大64kb，字符集utf8mb4兼容utf8，且支持更多内容比如emoji标签'
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_content
-- ----------------------------
INSERT INTO `blog_content` VALUES (10, '\n> 当启动容器时指定共享文件夹，出现了这个错误.\n\n####原因：\n> 如果指定/shareDirWithContainer文件夹，docker不会定位至根目录，而是以当前目录为工作目录，在/shareDirWithContainer之前加上当前目录，即如果你在/root中，创建的即为/root//shareDirWithContainer，没错，而我所在目录正好是docker进程没有新建目录权限的目录，所以就会有此问题。\n\n>  注意：前面/root//shareDirWithContainerm中间的双斜杠没有写错：\n当前目录 + /shareDirWithContainer = /root/ + /shareDirWithContainer = /root//shareDirWithContainer\n\n#### 解决方法：\n> 1.退回到想创建挂载目录的目录，然后运行时去掉/shareDirWithContainer斜杠。\n或者直接```${pwd}shareDirWithContainerm```\n');
INSERT INTO `blog_content` VALUES (12, '# dockfile指令简记\n\n## COPY\n\n#### 两种形式\nCOPY [--chown=<user>:<group>] <源路径>... <目标路径>\nCOPY [--chown=<user>:<group>] [\"<源路径1>\",... \"<目标路径>\"]\n\n> COPY 指令将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路径> 位置（工作目录可以用 WORKDIR 指令来指定，也可是绝对路径） \n\n#### 示例：\n\n```dockerfile\nCOPY package.json /usr/src/app/\n\n# 使用该指令的时候还可以加上 `--chown=<user>:<group>` 选项来改变文件的所属用户及所属组:\n\nCOPY --chown=55:mygroup files* /mydir/\nCOPY --chown=bin files* /mydir/\nCOPY --chown=1 files* /mydir/\nCOPY --chown=10:11 files* /mydir/		\n```\n\n\n\n## ADD\n\n`ADD` 指令和 `COPY` 的格式和性质基本一致。但是在 `COPY` 基础上增加了一些功能。比如 `<源路径>` 可以是一个 `URL`，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 `<目标路径>` 去。下载后的文件权限自动设置为 `600`，如果这并不是想要的权限，那么还需要增加额外的一层 `RUN` 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 `RUN` 指令进行解压缩。所以不如直接使用 `RUN` 指令，然后使用 `wget` 或者 `curl` 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。\n\n使用copy还是使用add的推荐判断方法是：看其是否需要再添加了文件后做类似解压的处理，需要的话就用ADD，否则推荐COPY！\n\n#### 示例\n\n```Dockerfile\nADD --chown=55:mygroup files* /mydir/\nADD --chown=bin files* /mydir/\nADD --chown=1 files* /mydir/\nADD --chown=10:11 files* /mydir/\n```\n\n> **docker build上下文的概念：**在使用 docker build 命令通过 Dockerfile 创建镜像时，会产生一个 build 上下文(context)。所谓的 build 上下文就是 docker build 命令的 PATH 或 URL 指定的路径中的文件的集合。在镜像 build 过程中可以引用上下文中的任何文件，比如我们要介绍的 COPY 和 ADD 命令，就可以引用上下文中的文件。\n>\n> 默认情况下 docker build -t testx . 命令中的 . 表示 build 上下文为当前目录。当然我们可以指定一个目录作为上下文，比如下面的命令：\n>\n> ```shell\n> $ docker build -t testx /home/nick/hc\n> ```\n>\n> 我们指定 /home/nick/hc 目录为 build 上下文，默认情况下 docker 会使用在上下文的根目录下找到的 Dockerfile 文件。\n>\n> ----\n>\n> 对于目录而言，COPY 和 ADD 命令具有相同的特点：**只复制目录中的内容而不包含目录自身。**比如我们在 Dockerfile 中添加下面的命令：\n>\n> ```\n> WORKDIR /app\n> COPY nickdir .\n> ```\n>\n> 其中 nickdir 目录的结构如下：\n>\n> ![img](https://upload-images.jianshu.io/upload_images/9031347-b3fdb47b24467859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>\n> 重新构建镜像 testx，运行一个容器并查看 /app 目录下的内容：\n>\n> ![img](https://upload-images.jianshu.io/upload_images/9031347-2a556aedfda63f94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>\n> 这里只有 file1 和 file2，少了一层目录 nickdir。如果想让 file1 和 file2 还保存在 nickdir 目录中，需要在目标路径中指定这个目录的名称，比如：\n>\n> ```dockerfile\n> WORKDIR /app\n> COPY nickdir ./nickdir\n> ```\n>\n> ----\n>\n> **解压压缩文件并把它们添加到镜像中**\n> 如果我们有一个压缩文件包，并且需要把这个压缩包中的文件添加到镜像中。需不需要先解开压缩包然后执行 COPY 命令呢？当然不需要！我们可以通过 ADD 命令一次搞定：\n>\n> ```\n> WORKDIR /app\n> ADD nickdir.tar.gz .\n> ```\n>\n> 这应该是 ADD 命令的最佳使用场景了！\n>\n> ----comes from [文章](https://www.cnblogs.com/sparkdev/p/9573248.html)\n\n\n\n## CMD\n\n`CMD` 指令的格式和 `RUN` 相似，也是两种格式：\n\n- `shell` 格式：`CMD <命令>`\n- `exec` 格式：`CMD [\"可执行文件\", \"参数1\", \"参数2\"...]`\n- 参数列表格式：`CMD [\"参数1\", \"参数2\"...]`。在指定了 `ENTRYPOINT` 指令后，用 `CMD` 指定具体的参数。\n\n之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。`CMD` 指令就是用于**指定默认的容器主进程的启动命令的**。\n\n在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，`ubuntu` 镜像默认的 `CMD` 是 `/bin/bash`，如果我们直接 `docker run -it ubuntu` 的话，会直接进入 `bash`。我们也可以在运行时指定运行别的命令，如 `docker run -it ubuntu cat /etc/os-release`。这就是用 `cat /etc/os-release` 命令替换了默认的 `/bin/bash` 命令了，输出了系统版本信息。\n\n在指令格式上，一般推荐使用 `exec` 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 `\"`，而不要使用单引号。\n\n\n\n如果使用 `shell` 格式的话，实际的命令会被包装为 `sh -c` 的参数的形式进行执行。比如：\n\n```Dockerfile\nCMD echo $HOME\n```\n\n在实际执行中，会将其变更为：\n\n```Dockerfile\nCMD [ \"sh\", \"-c\", \"echo $HOME\" ]\n```\n\n\n\n#### 重点\n\n当初欲在容器中启动nginx的守护线程，一运行`service nginx start`就容器结束的原因原理就是：容器是为了运行主进程而存在的，当我们后台启动`CMD service nginx start`命令，其就会被理解成CMD[\"sh\", \"-c\", \"service nginx start\"]命令，当`service nginx start`命令已结束，这个进程也就结束了！所以容器就退出了！\n\n正确的做法是直接执行 `nginx` 可执行文件，并且要求以前台形式运行。比如：\n\n```Dockerfile\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\n\n\n\n\n## ENTRYPOINT\n\n[ENTRYPOINT](https://yeasy.gitbooks.io/docker_practice/image/dockerfile/entrypoint.html)\n\n## ENV \n\n设置环境变量\n\n格式有两种：\n\n- `ENV <key> <value>`\n- `ENV <key1>=<value1> <key2>=<value2>...`\n\n这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 `RUN`，还是运行时的应用，都可以直接使用这里定义的环境变量。\n\n## ARG\n\n格式：`ARG <参数名>[=<默认值>]`\n\n构建参数和 `ENV` 的效果一样，都是设置环境变量。所不同的是，`ARG` 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 `ARG` 保存密码之类的信息，因为 `docker history` 还是可以看到所有值的。\n\n`Dockerfile` 中的 `ARG` 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 `docker build` 中用 `--build-arg <参数名>=<值>` 来覆盖。\n\n## VOLUME\n\n 定义匿名卷\n\n## EXPOSE\n\n声明端口\n\n格式为 `EXPOSE <端口1> [<端口2>...]`。\n\n`EXPOSE` 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 `docker run -P` 时，会自动随机映射 `EXPOSE` 的端口。\n\n要将 `EXPOSE` 和在运行时使用 `-p <宿主端口>:<容器端口>` 区分开来。`-p`，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 `EXPOSE` 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。\n\n## WORKDIR\n\n指定镜像的工作目录。\n\n格式为 `WORKDIR <工作目录路径>`。\n\n使用 `WORKDIR` 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，`WORKDIR` 会帮你建立目录。\n\n之前提到一些初学者常犯的错误是把 `Dockerfile` 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：\n\n```docker\nRUN cd /app\nRUN echo \"hello\" > world.txt\n```\n\n如果将这个 `Dockerfile` 进行构建镜像运行后，会发现找不到 `/app/world.txt` 文件，或者其内容不是 `hello`。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 `Dockerfile` 中，这两行 `RUN` 命令的执行环境根本不同，是两个完全不同的容器。这就是对 `Dockerfile` 构建分层存储的概念不了解所导致的错误。\n\n之前说过每一个 `RUN` 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 `RUN cd /app` 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。\n\n因此如果需要改变以后各层的工作目录的位置，那么应该使用 `WORKDIR` 指令。\n\n## USER\n\n指定当前用户\n\n格式：`USER <用户名>[:<用户组>]`\n\n`USER` 指令和 `WORKDIR` 相似，都是改变环境状态并影响以后的层。`WORKDIR` 是改变工作目录，`USER` 则是改变之后层的执行 `RUN`, `CMD` 以及 `ENTRYPOINT` 这类命令的身份。\n\n格式：`USER <用户名>[:<用户组>]`\n\n`USER` 指令和 `WORKDIR` 相似，都是改变环境状态并影响以后的层。`WORKDIR` 是改变工作目录，`USER` 则是改变之后层的执行 `RUN`, `CMD` 以及 `ENTRYPOINT` 这类命令的身份。\n\n当然，和 `WORKDIR` 一样，`USER` 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。\n\n```Dockerfile\nRUN groupadd -r redis && useradd -r -g redis redis\nUSER redis\nRUN [ \"redis-server\" ]\n```\n\n如果以 `root` 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 `su` 或者 `sudo`，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 [`gosu`](https://github.com/tianon/gosu)。\n\n```Dockerfile\n# 建立 redis 用户，并使用 gosu 换另一个用户执行命令\nRUN groupadd -r redis && useradd -r -g redis redis\n# 下载 gosu\nRUN wget -O /usr/local/bin/gosu \"https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64\" \n    && chmod +x /usr/local/bin/gosu \n    && gosu nobody true\n# 设置 CMD，并以另外的用户执行\nCMD [ \"exec\", \"gosu\", \"redis\", \"redis-server\" ]\n```\n\n## ONBUILD\n\nhttps://yeasy.gitbooks.io/docker_practice/image/dockerfile/onbuild.html\n');
INSERT INTO `blog_content` VALUES (18, '在脚本头部加一行：\n```\nexport BUILD_ID=dontkillme\n```\n试试\n');
INSERT INTO `blog_content` VALUES (19, '> 参考 《看透Spring MVC 源代码分析与实践》\n对于想学习javaweb的我来说，这本书上全书干货啊！墙裂推荐！！！\n以下很多内容摘抄自此书！\n\n# Servlet\nServlet是Server+applet的缩写，即服务器应用小程序。它其实就是一套规范，按照这套规范写的代码可以直接在Java服务器上面运行。\n****\n# Servlet（tomcat8.5.34）的结构\n既然是规范，最终套的就是接口\n平常web程序中继承的HttpServlet类继承自GerericServlet（可以叫做通用servlet类），GenericServlet实现了两个接口。\n![类图](https://upload-images.jianshu.io/upload_images/9031347-497ba8bf914b5a68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### Servlet接口\nservlet子类的一个规范\n```java\npackage javax.servlet;\nimport java.io.IOException;\npublic interface Servlet {\n    void init(ServletConfig var1) throws ServletException;\n\n    ServletConfig getServletConfig();\n\n    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\n\n    String getServletInfo();\n\n    void destroy();\n}\n```\n####方法解析：\n- **init**\ninit方法被容器（即tomcat）调用（当我们在web.xml中设置load-on-startup设置成负数或不设置时会在Servlet第一次调用时才会被调用。设置成0或正数时才会在容器启动时被调用，并且正数越大优先级越高！），只会被调用一次。\n- **getServletConfig**\ngetServletConfig方法用于获取ServletConfig。从init方法的参数可以看到，是当容器调用init时将ServletConfig传进来的。\n- **service**\n用于处理一个请求（Tomcat处理请求的流程待我研究下。）\n- **getServletInfo**\ngetServletInfo可以获得Servlet的相关信息，如作者、版权等，这个方法自己实现吗，默认返回空字符串！\n- **destory**\ndestory方法用于servket的销毁（一般在tomcat容器关闭时）释放一些资源，也只会调用一次！\n### ServletConfig接口\nServlet的init方法会接收一个容器传入的ServletConfig类型的参数，顾名思义就是servelt的配置参数，我们在web.xml中配置的**init-param**标签中的参数就是保存在ServletConfig中的！比如SpringMVC的配置文件的位置contextConfigLocation。比如：\n```html\n    <servlet>\n        <servlet-name>DispatcherServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <!--contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等）-->\n        <!--如果不配置，则默认加载/WEB-INFO/servlet下名称为-servlet.xml(springmvc-servlet.xml)-->\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <!--放在src文件夹下，所以就是classpath：...-->\n            <param-value>/WEB-INF/springmvc.xml</param-value>\n        </init-param>\n        <!--设置为容器启动时调用Servlet的init方法！-->\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n```\nServletConfig接口代码：\n```java\npackage javax.servlet;\nimport java.util.Enumeration;\npublic interface ServletConfig {\n    String getServletName();\n\n    ServletContext getServletContext();\n\n    String getInitParameter(String var1);\n\n    Enumeration<String> getInitParameterNames();\n}\n```\n####方法解析：\n- **getServletName**\n很简单即获得Servlet的名称！也就是上述配置中<servlet-name>标签内的内容！\n- **getServletContext**\n这个方法非常重要，用来获得ServletContext（Servlet运行上下文环境）即就是我们这个应用的本身！ServletContext中配置的参数可以被所有servlet所共享！我们在开发web程序时可以将参数保存在session，也可以保存在application中，后者就是保存在ServletContext中。\n> 可以这么理解，ServletConfig是servlet级别的，而ServletContext是application级别的（当然ServletContext不只是保存配置参数的）。还有更高一层的站点即是Tomcat中的Host级别的，在ServletContext接口中有一个ServletContext getContext（String uriPath）方法获得同意tomcat下的其他web应用的ServletContext。但这样不安全，一般返回null，有需求可以进行相关设置！\n- **getInitParameter**\n以参数为键获得web.xml中标签<init-param>配置的参数\n- **getInitParameterNames**\n获得所有配置了的参数的集合\n\n##### 以上所述的两个接口与下面的GenericServlet父类都能在： tomcat目录libservlet-api.jarjavaxservlet 目录下找到：\n![](https://upload-images.jianshu.io/upload_images/9031347-58c8f86f803bf429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> 目录不符是因为压缩软件不默认能打开jar文件，然后我将其复制到桌面然后添加进压缩包，打开压缩包，在里面继续双击jar包就可以进去了！\n****\n\n# GenericServlet类\n### 类源代码\n```java\npackage javax.servlet;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.Enumeration;\npublic abstract class GenericServlet implements Servlet, ServletConfig, Serializable {\n    private static final long serialVersionUID = 1L;\n    private transient ServletConfig config;\n    public GenericServlet() {\n    }\n    public void destroy() {\n    }\n    public String getInitParameter(String name) {\n        return this.getServletConfig().getInitParameter(name);\n    }\n    public Enumeration<String> getInitParameterNames() {\n        return this.getServletConfig().getInitParameterNames();\n    }\n    public ServletConfig getServletConfig() {\n        return this.config;\n    }\n    public ServletContext getServletContext() {\n        return this.getServletConfig().getServletContext();\n    }\n    public String getServletInfo() {\n        return \"\";\n    }\n    public void init(ServletConfig config) throws ServletException {\n        this.config = config;\n        this.init();\n    }\n    public void init() throws ServletException {\n    }\n    public void log(String msg) {\n        this.getServletContext().log(this.getServletName() + \": \" + msg);\n    }\n    public void log(String message, Throwable t) {\n        this.getServletContext().log(this.getServletName() + \": \" + message, t);\n    }\n    public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;\n    public String getServletName() {\n        return this.config.getServletName();\n    }\n}\n```\nGenericServlet作为Servlet的默认子类，GenericSerclet主要实现了三件事：\n1. **实现了ServletConfig**\n可以直接使用ServletConfig的方法而不用调用Config属性。比如：当我们要获得ServletContext时，可以直接使用getServletContext()方法，而不用getServletConfig().getServletContext()。\n2. **定义了init无参初始化方法**\ninit()是个模板方法，两个作用：这么做可以在子类中只重写init（）方法实现自己的逻辑；然后就是这样子做我们避免重写init(ServletConfig config)方法忘记调用父类init方法（```this.init(config)```）而没有将config赋给GernericServlet的config属性！\n> init方法：\n```java\ninit(){}\ninit(ServletConfig config){\n        this.config = config;\n        init();\n}\n```\n3. **提供了两个log方法**\n一个记录日志，一个记录异常，具体通过给ServletContext日志实现的！\n> 书上说一般我们都有自己的方法，这个用的不是很多\nGenericServlet与具体协议无关\n****\n# HttpServlet类\n####源码：\n```java\npublic abstract class HttpServlet extends GenericServlet {\n    private static final long serialVersionUID = 1L;\n    private static final String METHOD_DELETE = \"DELETE\";\n    private static final String METHOD_HEAD = \"HEAD\";\n    private static final String METHOD_GET = \"GET\";\n    private static final String METHOD_OPTIONS = \"OPTIONS\";\n    private static final String METHOD_POST = \"POST\";\n    private static final String METHOD_PUT = \"PUT\";\n    private static final String METHOD_TRACE = \"TRACE\";\n    private static final String HEADER_IFMODSINCE = \"If-Modified-Since\";\n    private static final String HEADER_LASTMOD = \"Last-Modified\";\n    private static final String LSTRING_FILE = \"javax.servlet.http.LocalStrings\";\n    private static ResourceBundle lStrings = ResourceBundle.getBundle(\"javax.servlet.http.LocalStrings\");\n\n    public HttpServlet() {\n    }\n\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String protocol = req.getProtocol();\n        String msg = lStrings.getString(\"http.method_get_not_supported\");\n        if (protocol.endsWith(\"1.1\")) {\n            resp.sendError(405, msg);\n        } else {\n            resp.sendError(400, msg);\n        }\n\n    }\n\n    protected long getLastModified(HttpServletRequest req) {\n        return -1L;\n    }\n\n    protected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        NoBodyResponse response = new NoBodyResponse(resp);\n        this.doGet(req, response);\n        response.setContentLength();\n    }\n\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String protocol = req.getProtocol();\n        String msg = lStrings.getString(\"http.method_post_not_supported\");\n        if (protocol.endsWith(\"1.1\")) {\n            resp.sendError(405, msg);\n        } else {\n            resp.sendError(400, msg);\n        }\n\n    }\n\n    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String protocol = req.getProtocol();\n        String msg = lStrings.getString(\"http.method_put_not_supported\");\n        if (protocol.endsWith(\"1.1\")) {\n            resp.sendError(405, msg);\n        } else {\n            resp.sendError(400, msg);\n        }\n\n    }\n\n    protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String protocol = req.getProtocol();\n        String msg = lStrings.getString(\"http.method_delete_not_supported\");\n        if (protocol.endsWith(\"1.1\")) {\n            resp.sendError(405, msg);\n        } else {\n            resp.sendError(400, msg);\n        }\n\n    }\n\n    private static Method[] getAllDeclaredMethods(Class<?> c) {\n        if (c.equals(HttpServlet.class)) {\n            return null;\n        } else {\n            Method[] parentMethods = getAllDeclaredMethods(c.getSuperclass());\n            Method[] thisMethods = c.getDeclaredMethods();\n            if (parentMethods != null && parentMethods.length > 0) {\n                Method[] allMethods = new Method[parentMethods.length + thisMethods.length];\n                System.arraycopy(parentMethods, 0, allMethods, 0, parentMethods.length);\n                System.arraycopy(thisMethods, 0, allMethods, parentMethods.length, thisMethods.length);\n                thisMethods = allMethods;\n            }\n\n            return thisMethods;\n        }\n    }\n\n    protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        Method[] methods = getAllDeclaredMethods(this.getClass());\n        boolean ALLOW_GET = false;\n        boolean ALLOW_HEAD = false;\n        boolean ALLOW_POST = false;\n        boolean ALLOW_PUT = false;\n        boolean ALLOW_DELETE = false;\n        boolean ALLOW_TRACE = true;\n        boolean ALLOW_OPTIONS = true;\n\n        for(int i = 0; i < methods.length; ++i) {\n            Method m = methods[i];\n            if (m.getName().equals(\"doGet\")) {\n                ALLOW_GET = true;\n                ALLOW_HEAD = true;\n            }\n\n            if (m.getName().equals(\"doPost\")) {\n                ALLOW_POST = true;\n            }\n\n            if (m.getName().equals(\"doPut\")) {\n                ALLOW_PUT = true;\n            }\n\n            if (m.getName().equals(\"doDelete\")) {\n                ALLOW_DELETE = true;\n            }\n        }\n\n        String allow = null;\n        if (ALLOW_GET) {\n            allow = \"GET\";\n        }\n\n        if (ALLOW_HEAD) {\n            if (allow == null) {\n                allow = \"HEAD\";\n            } else {\n                allow = allow + \", HEAD\";\n            }\n        }\n\n        if (ALLOW_POST) {\n            if (allow == null) {\n                allow = \"POST\";\n            } else {\n                allow = allow + \", POST\";\n            }\n        }\n\n        if (ALLOW_PUT) {\n            if (allow == null) {\n                allow = \"PUT\";\n            } else {\n                allow = allow + \", PUT\";\n            }\n        }\n\n        if (ALLOW_DELETE) {\n            if (allow == null) {\n                allow = \"DELETE\";\n            } else {\n                allow = allow + \", DELETE\";\n            }\n        }\n\n        if (ALLOW_TRACE) {\n            if (allow == null) {\n                allow = \"TRACE\";\n            } else {\n                allow = allow + \", TRACE\";\n            }\n        }\n\n        if (ALLOW_OPTIONS) {\n            if (allow == null) {\n                allow = \"OPTIONS\";\n            } else {\n                allow = allow + \", OPTIONS\";\n            }\n        }\n\n        resp.setHeader(\"Allow\", allow);\n    }\n\n    protected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String CRLF = \"\r\n\";\n        StringBuilder buffer = (new StringBuilder(\"TRACE \")).append(req.getRequestURI()).append(\" \").append(req.getProtocol());\n        Enumeration reqHeaderEnum = req.getHeaderNames();\n\n        while(reqHeaderEnum.hasMoreElements()) {\n            String headerName = (String)reqHeaderEnum.nextElement();\n            buffer.append(CRLF).append(headerName).append(\": \").append(req.getHeader(headerName));\n        }\n\n        buffer.append(CRLF);\n        int responseLength = buffer.length();\n        resp.setContentType(\"message/http\");\n        resp.setContentLength(responseLength);\n        ServletOutputStream out = resp.getOutputStream();\n        out.print(buffer.toString());\n        out.close();\n    }\n\n    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String method = req.getMethod();\n        long lastModified;\n        if (method.equals(\"GET\")) {\n            lastModified = this.getLastModified(req);\n            if (lastModified == -1L) {\n                this.doGet(req, resp);\n            } else {\n                long ifModifiedSince;\n                try {\n                    ifModifiedSince = req.getDateHeader(\"If-Modified-Since\");\n                } catch (IllegalArgumentException var9) {\n                    ifModifiedSince = -1L;\n                }\n\n                if (ifModifiedSince < lastModified / 1000L * 1000L) {\n                    this.maybeSetLastModified(resp, lastModified);\n                    this.doGet(req, resp);\n                } else {\n                    resp.setStatus(304);\n                }\n            }\n        } else if (method.equals(\"HEAD\")) {\n            lastModified = this.getLastModified(req);\n            this.maybeSetLastModified(resp, lastModified);\n            this.doHead(req, resp);\n        } else if (method.equals(\"POST\")) {\n            this.doPost(req, resp);\n        } else if (method.equals(\"PUT\")) {\n            this.doPut(req, resp);\n        } else if (method.equals(\"DELETE\")) {\n            this.doDelete(req, resp);\n        } else if (method.equals(\"OPTIONS\")) {\n            this.doOptions(req, resp);\n        } else if (method.equals(\"TRACE\")) {\n            this.doTrace(req, resp);\n        } else {\n            String errMsg = lStrings.getString(\"http.method_not_implemented\");\n            Object[] errArgs = new Object[]{method};\n            errMsg = MessageFormat.format(errMsg, errArgs);\n            resp.sendError(501, errMsg);\n        }\n\n    }\n\n    private void maybeSetLastModified(HttpServletResponse resp, long lastModified) {\n        if (!resp.containsHeader(\"Last-Modified\")) {\n            if (lastModified >= 0L) {\n                resp.setDateHeader(\"Last-Modified\", lastModified);\n            }\n\n        }\n    }\n\n    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {\n        HttpServletRequest request;\n        HttpServletResponse response;\n        try {\n            request = (HttpServletRequest)req;\n            response = (HttpServletResponse)res;\n        } catch (ClassCastException var6) {\n            throw new ServletException(\"non-HTTP request or response\");\n        }\n\n        this.service(request, response);\n    }\n}\n\n```\n### 类解析\nHttpServlet是用HTTP协议实现的Servlet基类，写Servlet时直接继承它就行了，不用重头实现Servlet接口。\n**《看透Spring MVC 源代码分析与实践》**要研究的SpringMVC中负责请求转发的DispatcherServlet就是直接继承HttpServlet的！\n### 方法解析\nHttp主要作用就是处理请求了，所以其主要重写了service方法，上述代码中有两个service方法，下面那个功能就是将ServletRequest和ServletResponse转化为HttpServletRequest和HttpServletResponse，然后传给另一个也就是上面那个service方法根据Http请求方法交给不同的处理方法处理！\n\n处理方法：\n- doPost\n- doGet\n- doPut\n- doDelete\ndoPost、doGet、 doPut、doDelete都是模板方法，如果子类没有实现则抛出异常；而且在调用doGet方法时还对其是否果其进行检查，没有过期则直接返回304状态码使用缓存；\n- doOptions\n- doTrace\n以上两个一般正常情况不实用，主要做些调试工作！\n- doHead\n调用了doGet方法，返回有个空body的response；\n\n****\n\n\n美好的周末开始了，写完这篇博客就去看美剧了，天气凉爽到我忍不住想出去多走走而不是待在寝室，明天下午去踢球，虽然全是陌生人，但也应该跳出自己的舒适圈，多出去闯闯了！\n现在，休息，休息一会儿~\n![](https://upload-images.jianshu.io/upload_images/9031347-45e2443c56a48163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n');
INSERT INTO `blog_content` VALUES (20, '# 1. CAP理论\n2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。\n\nCAP理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。\n\n## 1.1 一致性（Consistency）\n一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。\n\n## 1.2 可用性（Availability）\n可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。\n\n\n## 1.3 分区容错性（Partition tolerance）\n分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。\n\n# 2. CAP权衡\n通过CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？\n\n对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。\n\n对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证CP，舍弃A。例如网络故障事只读不写。\n\n孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。\n\n# 3. BASE理论\neBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。\n\nBASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。\n\n## 3.1 基本可用（Basically Available）\n基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。\n电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。\n\n## 3.2 软状态（ Soft State）\n软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。\n\n## 3.3 最终一致性（ Eventual Consistency）\n最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。\n# 4. ACID和BASE的区别与联系\nACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。\n\nACID和BASE代表了两种截然相反的设计哲学\n\n在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。\n');
INSERT INTO `blog_content` VALUES (21, '> 转自：https://medium.freecodecamp.org/learn-these-4-things-and-working-with-lambda-expressions-b0ab36e0fffc\n\nBefore Lambda expressions support was added by JDK 8, I’d only used examples of them in languages like C# and C++.\n\nOnce this feature was added to Java, I started looking into them a bit closer.\n\nThe addition of lambda expressions adds syntax elements that increase the expressive power of Java. In this article, I want to focus on foundational concepts you need to get familiar with so you can start adding lambda expressions to your code today.\n\n#### Quick Introduction\n\nLambda expressions take advantage of parallel process capabilities of multi-core environments as seen with the support of pipeline operations on data in the Stream API.\n\nThey are anonymous methods (methods without names) used to implement a method defined by a functional interface. It’s important to know what a functional interface is before getting your hands dirty with lambda expressions.\n\n#### Functional interface\n\nA functional interface is an interface that contains one and only one abstract method.\n\nIf you take a look at the definition of the Java standard [Runnable interface](https://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html), you will notice how it falls into the definition of functional interface because it only defines one method: `run()`.\n\nIn the code sample below, the method `computeName` is implicitly abstract and is the only method defined, making MyName a functional interface.\n\n```java\ninterface MyName{\n  String computeName(String str);\n}\n```\n\n#### The Arrow Operator\nLambda expressions introduce the new arrow operator -> into Java. It divides the lambda expressions in two parts:\n```java\n(n) -> n*n\n```\nThe left side specifies the parameters required by the expression, which could also be empty if no parameters are required.\n\nThe right side is the lambda body which specifies the actions of the lambda expression. It might be helpful to think about this operator as “becomes”. For example, “n becomes n*n”, or “n becomes n squared”.\n\nWith functional interface and arrow operator concepts in mind, you can put together a simple lambda expression:\n```java\ninterface NumericTest {\n	boolean computeTest(int n); \n}\n\npublic static void main(String args[]) {\n	NumericTest isEven = (n) -> (n % 2) == 0;\n	NumericTest isNegative = (n) -> (n < 0);\n\n	// Output: false\n	System.out.println(isEven.computeTest(5));\n\n	// Output: true\n	System.out.println(isNegative.computeTest(-5));\n}\n```\n```java\ninterface MyGreeting {\n	String processName(String str);\n}\n\npublic static void main(String args[]) {\n	MyGreeting morningGreeting = (str) -> \"Good Morning \" + str + \"!\";\n	MyGreeting eveningGreeting = (str) -> \"Good Evening \" + str + \"!\";\n  \n  	// Output: Good Morning Luis! \n	System.out.println(morningGreeting.processName(\"Luis\"));\n	\n	// Output: Good Evening Jessica!\n	System.out.println(eveningGreeting.processName(\"Jessica\"));	\n}\n```\nThe variables morningGreeting and eveningGreeting, lines 6 and 7 in the sample above, make a reference to MyGreeting interface and define different greeting expressions.\n\nWhen writing a lambda expression, it is also possible to explicitly specify the type of the parameter in the expression like this:\n```java\nMyGreeting morningGreeting = (String str) -> \"Good Morning \" + str + \"!\";\nMyGreeting eveningGreeting = (String str) -> \"Good Evening \" + str + \"!\";\n```\n#### Block Lambda Expressions\nSo far, I have covered samples of single expression lambdas. There is another type of expression used when the code on the right side of the arrow operator contains more than one statement known as block lambdas:\n```java\ninterface MyString {\n	String myStringFunction(String str);\n}\n\npublic static void main (String args[]) {\n	// Block lambda to reverse string\n	MyString reverseStr = (str) -> {\n		String result = \"\";\n		\n		for(int i = str.length()-1; i >= 0; i--)\n			result += str.charAt(i);\n		\n		return result;\n	};\n\n	// Output: omeD adbmaL\n	System.out.println(reverseStr.myStringFunction(\"Lambda Demo\")); \n}\n```\n#### Generic Functional Interfaces\nA lambda expression cannot be generic. But the functional interface associated with a lambda expression can. It is possible to write one generic interface and handle different return types like this:\n```java\ninterface MyGeneric<T> {\n	T compute(T t);\n}\n\npublic static void main(String args[]){\n\n	// String version of MyGenericInteface\n	MyGeneric<String> reverse = (str) -> {\n		String result = \"\";\n		\n		for(int i = str.length()-1; i >= 0; i--)\n			result += str.charAt(i);\n		\n		return result;\n	};\n\n	// Integer version of MyGeneric\n	MyGeneric<Integer> factorial = (Integer n) -> {\n		int result = 1;\n		\n		for(int i=1; i <= n; i++)\n			result = i * result;\n		\n		return result;\n	};\n\n	// Output: omeD adbmaL\n	System.out.println(reverse.compute(\"Lambda Demo\")); \n\n	// Output: 120\n	System.out.println(factorial.compute(5)); \n\n}\n```\n\n#### Lambda Expressions as arguments\nOne common use of lambdas is to pass them as arguments.\n\nThey can be used in any piece of code that provides a target type. I find this exciting, as it lets me pass executable code as arguments to methods.\n\nTo pass lambda expressions as parameters, just make sure the functional interface type is compatible with the required parameter.\n```java\ninterface MyString {\n	String myStringFunction(String str);\n}\n\npublic static String reverseStr(MyString reverse, String str){\n  return reverse.myStringFunction(str);\n}\n\npublic static void main (String args[]) {\n	// Block lambda to reverse string\n	MyString reverse = (str) -> {\n		String result = \"\";\n		\n		for(int i = str.length()-1; i >= 0; i--)\n			result += str.charAt(i);\n		\n		return result;\n	};\n\n	// Output: omeD adbmaL\n	System.out.println(reverseStr(reverse, \"Lambda Demo\")); \n}\n```\n\nThese concepts will give you a good foundation to start working with lambda expressions. Take a look at your code and see where you can increase the expressive power of Java.\n');
INSERT INTO `blog_content` VALUES (22, '\n日历类GregorianCalendar也比较简单，比较常用的几个方法的具体用途今天也都试了一遍。功能差不多就注释内容吧！漏了在加！\n```java\nimport javax.swing.text.Style;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\n\n//Sun Sep 09 22:51:10 CST 2018 其中CST表示的是中央标准时间，例如我这边的中央标准时间是北京时间22:51:10\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Date d = new Date();\n        System.out.println(d);\n//        大致地看了下，发现Date类现在没什么可以用的方法了，像什么getYear()这样系列的已经不能用了！\n//        能用的就只有after()、before()、clone()。我怀疑就是让我们用字典函数，也可以将date格式化。\n//        其中还有一个getTime方法使用来获取自1970年1月1日00:00时间以来的豪秒数！\n//        不如用GregorianCalendar来的自在\n        Calendar calendar = new GregorianCalendar();\n        System.out.println(calendar.get(Calendar.DAY_OF_MONTH));//获取时间，参数是获取的时间类型，这个可以通过直接使用下面这句查看自己想要什么，然后当参数就行了！\n        System.out.println(calendar.toString());//toString方法\n        System.out.println(calendar.getTime());//直接返回一个Date对象，打印出来和第一个Date结果一样\n        System.out.println(calendar.after(new GregorianCalendar(2018,9,30,0,0,0)));//判断时间是否在参数时间后\n        System.out.println(calendar.before(new GregorianCalendar(2018,9,30,0,0,0)));//判断时间是否在参数时间前\n        Calendar calendar1 = (Calendar) calendar.clone();//克隆方法\n        System.out.println(calendar1);//一样\n        System.out.println(calendar.compareTo(new GregorianCalendar(2018,9,30,0,0,0)));//比较，这个返回-1，即早-1晚1\n        System.out.println(calendar.equals(new GregorianCalendar(2018,9,10)));//如果只设置了日期的话时间默认是网上0点整（参考下面这句），即时间不相等返回false\n        System.out.println(new GregorianCalendar(2018,9,10));\n        System.out.println(calendar.getActualMaximum(Calendar.DAY_OF_MONTH));//这个是根据时间获得最大值，如本月日期最大为30（现在9月）\n        System.out.println(calendar.getMaximum(Calendar.DAY_OF_MONTH));//而月的日期的最大能是31了（即在大月的时候！）\n//                获得最小值的示例略\n//        getDisplayName和getDisplayNames暂时好像没什么用！不展示了\n        System.out.println(calendar.getFirstDayOfWeek());//有些地方以星期一为第一天，有些则以周日，这个是获取当地第一天的星期数！\n        System.out.println(calendar.getGreatestMinimum(Calendar.DAY_OF_YEAR));//网上解释说最高最小值，凌乱了！\n\n        /*\n         * 鬼知道有什么用，文档说：\n         * Gets the Gregorian Calendar change date.  This is the point when the\n         * switch from Julian dates to Gregorian dates occurred. Default is\n         * October 15, 1582 (Gregorian). Previous to this, dates will be in the Julian\n         * calendar.\n         * @return the Gregorian cutover date for this <code>GregorianCalendar</code> object.\n         */\n        System.out.println(((GregorianCalendar) calendar).getGregorianChange());\n        System.out.println(calendar.getLeastMaximum(Calendar.DAY_OF_MONTH));//该又是返回最大值中的最小值吧！没用！\n        System.out.println(calendar.getTimeInMillis());//返回毫秒数啰！\n        System.out.println(calendar.getTimeZone());//显示时区是上海sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=19,lastRule=null]\n        System.out.println(((GregorianCalendar) calendar).isLeapYear(2008));//判断某一年是否为闰年\n        //下面这个是获取宽容度值对于宽容度，网上是这样解释的：\n        //如果设置了宽容度即lenient为true，则在设置日期时可以接受比其生成日期的范围还要大的值，例如我们设置日期为1月32号，在get的时候计算日期就会将其计算成1月1号\n        //而如果为false的话就不能。（注意：这里设置的时候只是将值赋予了相关参数，所以设置的时候值不符合规范不会报错，而是在get计算日期的时候报错！\n        System.out.println(calendar.isLenient());\n    }\n}\n\n```\n');
INSERT INTO `blog_content` VALUES (23, '### 一、自己理解的概念\n nioSocket（即new io socket）是一种同步非阻塞的I/O，其使用buffer来缓存数据和channel来传输数据，使用select来分拣消息。其使用的ServerSocketChannel和SocketChannel对应于之前学习的ServerSocket和Socket。\n> 在我看的书（《看透Spring MVC源代码分析与实践》）中形容为：当今的快递物流，现实中的快递站点不会一件一件地发出快递，而是在每一天的中午或者是一天的下午等时间即等待一段时间后将受到的快件一起发出去，这就像这里要提到的NioSocket的工作原理，送货员就像这里的channel，将一段时间的一批货一起送出去，这一批快件就针对于buffer，到一个中转点分拣员分拣，将不同的货分发给相应的地区相应的快递员，分拣员的身份就相当于selector。\n\n###二、与普通socket的区别：\n- 数据传输方面：\n**socket**是直接使用输入输出流的方式直接读，当然也可以选择性的放在缓冲数据区中。\n**nioSocket**只能用buffer来进行信息的获取与发出！\n- 异步特性上面\n**socket** 在连接和读写是都是堵塞状态的，即所在线程必须停住等待连接和数据的读入及写出，如果想在通信的时候可以开辟线程，一个线程对应一个socket连接，这样不仅资源消耗太高，而且线程安全问题也不容小觑！\n**niosocket**可以再连接、读入、写出等待时执行其他代码，就像上面的例子中，快递站点的工作人员不是一直有事，可以再等待快递的时间里干别的事。\n\n### 三、代码实现\n#####服务器端\n```java\npackage AboutNioSocket.SimpleNioSocket;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.Set;\n\n/**\n * @author hsw\n * @create 2018-09-11  16:09\n */\npublic class NioSocketServer {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        new NioSocketServer().start();\n    }\n\n    private void start() throws IOException, InterruptedException {\n        //使用静态open方法，生成一个ServerSocketChannel对象\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        //设置其为非阻塞模式\n        serverSocketChannel.configureBlocking(false);\n\n        //获取有个selector对象\n        Selector selector = Selector.open();\n\n        //注册selector，第二个参数设置了其操作类型\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        //绑定接受请求的端口\n        serverSocketChannel.bind(new InetSocketAddress(8001));\n\n        //循环接受请求\n        while (true) {\n            //等待三秒，如果没有请求就select方法返回0，运行else中的需要一部运行的代码\n            // 如果参数是0或没有参数的话就一直阻塞直到接收到请求\n            if (selector.select(3000) != 0) {\n                //selectedKeys方法获取SelectionKey的集合\n                //SelectionKey保存了请求的channel和selector信息\n                Set<SelectionKey> keys = selector.selectedKeys();\n                System.out.println(\"keys.length is \" + keys.size());\n                Iterator<SelectionKey> iterator = keys.iterator();\n                while (iterator.hasNext()) {\n                    SelectionKey key = iterator.next();\n                    //获取后移除这个已经处理的请求！\n                    iterator.remove();\n                    //如果该key所在的channel或者selector关闭了，这里就会返回true\n                    //如果是接收请求操作\n                    if (key.isAcceptable()) {\n                        accept(key);\n                        //如果是写操作\n                    } else if (key.isWritable()) {//\n                        write(key);\n                        //如果是读取操作\n                    } else if (key.isReadable()) {\n                        read(key);\n                    }\n                }\n            } else {\n                System.out.println();\n                Thread.sleep(800);\n            }\n        }\n    }\n\n    //nioSocket是通过缓流进行读写操作的，这里先初始化好读写的缓冲流！\n    private ByteBuffer read = ByteBuffer.allocate(1024);\n    private ByteBuffer write = ByteBuffer.allocate(1024);\n    //这是接收到的字符串\n    private String getStr;\n\n    private void accept(SelectionKey key) throws IOException {\n        //这里的socket还没有注册客户端的channel，所以channel方法是获取ServerSocketChannel的\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        //而ServerSocketChannel的accept方法才是获取连接的channel的！\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        //获取selector用的就是selector()方法\n        Selector selector = key.selector();\n        //也给其设置非阻塞模式\n        socketChannel.configureBlocking(false);\n        //注册服务器端的socket！本地分拣员能为客户端的channel服务了！\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        System.out.println(\"connect successfully\");\n    }\n\n    private void write(SelectionKey key) throws IOException {\n\n        /*\n        * clear方法中的内容，准备写入\n        *\n        * capacity = 1024 初始化时给的大小就是1024\n        * limit = capacity\n        * position = 0\n        * mark = -1\n        * */\n        write.clear();\n        write.put(getStr.getBytes());\n        /*\n        * flip方法中的内容，准备读取\n        *\n        * capacity = 1024\n        * limit = getStr.getBytes()\n        * position = 0\n        * mark = -1\n        * */\n        write.flip();\n\n        // selector已经注册了客户端的channel\n        // channel（）方法获取到的是发送请求的SocketChannel对象\n        SocketChannel channel = (SocketChannel) key.channel();\n        channel.configureBlocking(false);\n        channel.write(write);\n\n        Selector selector = key.selector();\n        //更换下一步的操作类型\n        channel.register(selector, SelectionKey.OP_READ);\n    }\n\n    private void read(SelectionKey key) throws IOException {\n        read.clear();\n\n        SocketChannel channel = (SocketChannel) key.channel();\n        channel.configureBlocking(false);\n        int num;\n        if ((num = channel.read(read)) == -1) {\n            System.out.println(\"未读到信息\");\n        } else {\n            Selector selector = key.selector();\n            channel.register(selector, SelectionKey.OP_WRITE);\n            getStr = new String(read.array(), 0, num);\n        }\n    }\n\n}\n\n```\n##### 客户端\n```java \npackage AboutNioSocket.SimpleNioSocket;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.*;\nimport java.util.Iterator;\nimport java.util.Set;\n\n/**\n * @author hsw\n * @create 2018-09-11  16:09\n */\npublic class NioSocketServer {\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        new NioSocketServer().start();\n    }\n\n    private void start() throws IOException, InterruptedException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.configureBlocking(false);\n\n        Selector selector = Selector.open();\n\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        serverSocketChannel.bind(new InetSocketAddress(8001));\n\n        while (true) {\n            if (selector.select(3000) != 0) {\n                Set<SelectionKey> keys = selector.selectedKeys();\n                System.out.println(\"keys.length is \" + keys.size());\n                Iterator<SelectionKey> iterator = keys.iterator();\n                while (iterator.hasNext()) {\n                    SelectionKey key = iterator.next();\n                    iterator.remove();\n                    //如果该key所在的channel或者selector关闭了，这里就会返回true\n                    if (key.isAcceptable()) {\n                        accept(key);\n                    } else if (key.isWritable()) {\n                        write(key);\n                    } else if (key.isReadable()) {\n                        read(key);\n                    }\n                }\n            } else {\n                System.out.println();\n                Thread.sleep(800);\n            }\n        }\n    }\n\n    private ByteBuffer read = ByteBuffer.allocate(1024);\n    private ByteBuffer write = ByteBuffer.allocate(1024);\n    private String getStr;\n\n    private void accept(SelectionKey key) throws IOException {\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        Selector selector = key.selector();\n        socketChannel.configureBlocking(false);\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        System.out.println(\"connect successfully\");\n    }\n\n    private void write(SelectionKey key) throws IOException {\n\n        write.clear();\n        write.put(getStr.getBytes());\n        write.flip();\n\n        SocketChannel channel = (SocketChannel) key.channel();\n        channel.configureBlocking(false);\n        channel.write(write);\n\n        Selector selector = key.selector();\n        channel.register(selector, SelectionKey.OP_READ);\n    }\n\n    private void read(SelectionKey key) throws IOException {\n        read.clear();\n\n        SocketChannel channel = (SocketChannel) key.channel();\n        channel.configureBlocking(false);\n        int num;\n        if ((num = channel.read(read)) == -1) {\n            System.out.println(\"未读到信息\");\n        } else {\n            Selector selector = key.selector();\n            channel.register(selector, SelectionKey.OP_WRITE);\n            getStr = new String(read.array(), 0, num);\n        }\n    }\n\n}\n\n```\n\n###四、代码流程解析\n\n####以服务器端为例（客户端原理差不多）\n\n&ensp;**首先我们可以通过ServerSocketChannle的静态open方法产生一个ServerSocketChannel对象（其对应于一个ServerSocket对象，可以使用其socket（）方法产生，然后运用这个ServerSocket对象进行监听，那还就是使用原来的socket了）；有了ServerSocketChannel对象，使用configureBlocking（false）设置其为非阻塞模式，这样就可以异步处理其他的代码，可以在后面调用register方法注册Selector了。注册时会给其设置四种操作方法之一：**\n```\nSelectionKey.OP_ACCEPT\nSelectionKey.OP_CONNECT\nSelectionKey.OP_WRITE\nSelectionKey.OP_READ\n```\n&ensp;  ***代码很简单，基本的操作都写到注释中去了，这里不做详细说明***\n&ensp;  **要知道的是Selector与Channel没有主属关系，没有谁属于谁的关系，一个Selector可以注册多个Chennel，一个Channel能注册多个Selector。Selector像快递分拣员一样能处理来自于不同地方的物流请求，Selector相比之下分的更细，他可以按照不同的类型分拣。分拣后的结果保存在SelectionKey中，可以通过SelectionKey中的channel方法和selector方法获取相应的channel和selector，通过isAcctable（）、isConnectable（）、isWritable（）、isReadable（）判断请求属于什么操作！**\n\n###五、Buffer缓冲流\n我们可以看到每次进行写操作时会调用clear（），读取时使用flip（）方法，两个方法的具体操作在注释中已经写明，但这四个属性都有什么含义呢？\n答：**capacity**：容量，在初始化时已经设置好，使用过程中不能改变！\n**limit**:可以使用的范围的上限，开始时默认和capacity的值相等。当我们写入了一个字符串时，其大小就和该字符串的字节数相等，我们最多能操作的索引上限也就是这个数值！\n**position**：当前操作的索引值，从0开始，随着get和put方法的操作改变。\n**mark**：暂时保存position的位置，比如当前的position的值为10，我想现在访问15-20之间的内容，可以使用mark（）方法保存当前的position的值，然后通过position（int pos）方法设置position的值为15，访问完后调用reset（）方法使position = mark!需要注意的是如果将position的值设置得比mark小，mark就会被还原为默认值-1.\n四个属性的大小：mark <= position <= limit <= capacity\n\n后续更新！\n\n\n');
INSERT INTO `blog_content` VALUES (24, '参考大神的博客：https://blog.csdn.net/zengxiantao1994/article/details/77803960\n# Pattern的创建：\n**Pattern的构造器被保护了起来，创建Pattern对象要靠使用compile方法编译正则表达式的返回Pattern的对象实例来实现！**\n两种compile方法：\n```java\npublic class testCompileMethodInPattern {\n    public static void main(String[] args) {\n        String regex = \"[1-9]\\d*.+[1-9]\\d*=?\";\n        Pattern pattern = Pattern.compile(regex);\n        System.out.println(pattern.pattern());\n        System.out.println(pattern.flags());\n    }\n}\n```\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-98d5e1a713c2681c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> 使用**pattern.pattern()**获取编译的正则表达式，而**flags()**获得的是使用compile（String regex，int falg）创建Pattern对象时设置的！flag是用来控制正则表达式匹配行为的，默认值为0！\n\nPattern有几个内置的flag类型及作用：\n|名字|作用|十六进制值|\n|:--:|:--:|:--:|\n|Pattern.CANON_EQ|启用规范等价。当且仅当两个字符的“正规分解(canonicaldecomposition)”都完全相同的情况下，才认定匹配。默认情况下，不考虑“规范相等性(canonical equivalence)”。|0x80|\n|Pattern.CASE_INSENSITIVE|启用不区分大小写的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。这个标志能让表达式忽略大小写进行匹配，要想对Unicode字符进行大小不敏感的匹配，只要将UNICODE_CASE与这个标志合起来就行了。|0x02|\n|Pattern.COMMENTS|模式中允许空白和注释。在这种模式下，匹配时会忽略(正则表达式里的)空格字符(不是指表达式里的“s”，而是指表达式里的空格，tab，回车之类)。注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。|0x04|\n|Pattern.DOTALL|启用dotall模式。在这种模式下，表达式‘.’可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式‘.’不匹配行的结束符。|0x20|\n|Pattern.LITERAL|启用模式的字面值解析。|0x10|\n|Pattern.MULTILINE|启用多行模式。在这种模式下，‘^’和‘$’分别匹配一行的开始和结束。此外，‘^’仍然匹配字符串的开始，‘$’也匹配字符串的结束。默认情况下，这两个表达式仅仅匹配字符串的开始和结束。|0x08|\n|Pattern.UNICODE_CASE|启用Unicode感知的大小写折叠。在这个模式下，如果你还启用了CASE_INSENSITIVE标志，那么它会对Unicode字符进行大小写不敏感的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。|0x40|\n|Pattern.UNIX_LINES|启用Unix行模式。在这个模式下，只有‘\n’才被认作一行的中止，并且与‘.’、‘^’、以及‘$’进行匹配。|0x01|\n# Pattern之使用split进行字符串分割\n使用Pattern对象编译的正则表达式所匹配的子字符串对字符串进行分割：\n```java\npublic class testSplitMethodInPattern {\n    public static void main(String[] args) {\n        String regex = \"[+\\-*/]\";\n        Pattern pattern = Pattern.compile(regex);\n        String []nums = pattern.split(\"13+29-44*55/22\");\n        for (String num : nums) {\n            System.out.print(num + \" \");\n        }\n    }\n}\n```\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-9faf255b8113b76f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n将split方法改成：\n```java\nString []nums = pattern.split(\"13+29-44*55/22\", 2);\n```\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-9bd6c53b09cef895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>即后面的整数类型入参觉得的是字符串被分割后的段数\n# Pattern使用matchs进行字符串的全匹配\npattern的matches方法对字符串进行一次匹配，只有全部符合规则才能返回true！\n```java\npublic class testMatchesMethodInPattern {\n    public static void main(String[] args) {\n        String regex = \"[1-9]\\d*[+\\-*/][1-9]\\d*=?\";\n        System.out.println(Pattern.matches(regex, \"2315+5555=\"));\n        System.out.println(Pattern.matches(regex, \"123456*4556\"));\n        System.out.println(Pattern.matches(regex, \"0112897+440=\"));\n        System.out.println(Pattern.matches(regex, \"22+023\"));\n    }\n}\n```\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-62de709f6586526a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# Pattern的matcher（CharSequence input）方法\n该方法返回的是一个Matcher对象，Matcher类的构造方法也被peivate保护了起来，只能使用这个方法创建，Pattern类只能做一些简单的匹配操作，要想得到更强更便捷的正则匹配操作，那就需要将Pattern与Matcher一起合作。Matcher类提供了对正则表达式的分组支持，以及对正则表达式的多次匹配支持。\n```java\npublic class testMatcherMethodInPattern {\n    public static void main(String[] args) {\n        String regex = \"[1-9]\\d*[+\\-*/][1-9]\\d*=?\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(\"1+2\");\n        System.out.println(matcher.pattern());\n    }\n}\n```\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-9429fa7aecb67f90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 可以看出Matcher的pattern的方法也是显示生成自己的pattern编译的正则表达式！\n# Matcher类方法详解：\n## matches（String content）\n和Pattern的matches方法一样，不赘述\n## lookAt（）方法\n与字符串的前缀匹配。\n```java\npublic class testCompileMethodInPattern {\n    public static void main(String[] args) {\n        String regex = \"[1-9]\\d*[+\\-*/][1-9]\\d*=?\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(\"1+2dasfdsadfeeesdfxca\");\n        System.out.println(matcher.lookingAt());\n        matcher = pattern.matcher(\"a1+2asdfasdfsadf\");\n        System.out.println(matcher.lookingAt());\n    }\n}\n```\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-5386e3bf7a9e6c0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## find（）方法\n在字符串中找是否有匹配的子字符串，有则返回ture\n```java\npublic class testCompileMethodInPattern {\n    public static void main(String[] args) {\n        String regex = \"[1-9]\\d*[+\\-*/][1-9]\\d*=?\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(\"asdfasd11+2dasfdsadfeeesdfxca\");\n        System.out.println(matcher.find());\n        matcher = pattern.matcher(\"asdfasd12dasfdsadfeeesdfxca\");\n        System.out.println(matcher.find());\n        matcher = pattern.matcher(\"1+1\");\n        System.out.println(matcher.find());\n    }\n}\n```\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-b297918ef81b112d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## start（）和end（）方法\n前者是返回匹配到的字符串的第一个字符在字符串中的索引，后者则返回最后一个的索引+1\n```java\npublic class testCompileMethodInPattern {\n    public static void main(String[] args) {\n        String regex = \"[1-9]\\d*[+\\-*/][1-9]\\d*=?\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(\"a11+2dasfdsadfeeesdfxca\");\n        if (matcher.find()) {\n            System.out.println(\"The index of the final one character is \" + matcher.start());\n            System.out.println(\"The index of the last one character is \" + matcher.end());\n            System.out.println(\"The content of the corresponding substring of this string is \" + matcher.group());\n        }\n    }\n}\n```\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-a87135021511999b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 只有有匹配的子字符串的情况时才可以调用者几个方法，否则报错！\n\n## 对匹配到的字符串进行分割操作\n在正则表达式中使用括号对想要分割的方式进行添加！\n举例：\n```java\npublic class testCompileMethodInPattern {\n    public static void main(String[] args) {\n        String regex = \"([1-9]\\d*)([+\\-*/])([1-9]\\d*=?)\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(\"a11+2dasfdsadfeeesdfxca\");\n\n        System.out.println(matcher.find());\n\n        System.out.println(matcher.groupCount());\n\n        for (int i = 0; i <= matcher.groupCount(); i++) {\n            System.out.println(\"The index of the final one character is \" + matcher.start(i));\n            System.out.println(\"The index of the last one character is \" + matcher.end(i));\n            System.out.println(\"The content of the corresponding substring of this string is \" + matcher.group(i));\n        }\n    }\n}\n```\n> 注意对正则表达式的分割\n  \n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-df273d5e588e15a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n由图片可以看出，matcher中的group第一个显示的是匹配到的字符串及其信息后面才是我们分割的结果！\n\n## 一个字符串有多个匹配的子字符串的情况\n如果有多个匹配到的字符串，多用几次find就可以了！find方法第一次调用只匹配字符串中第一个匹配到的字符串，再调一次匹配第二个，以此类推！\n如在上面一段代码稍稍修改下：\n```java\npublic class testFindMethodInPattern {\n    public static void main(String[] args) {\n        String regex = \"([1-9]\\d*)([+\\-*/])([1-9]\\d*=?)\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(\"a11+2dasfdsa11+22esdfxca\");\n\n        System.out.println(matcher.find());\n        matcher.find();\n\n        System.out.println(matcher.groupCount());\n\n        for (int i = 0; i <= matcher.groupCount(); i++) {\n            System.out.println(\"The index of the final one character is \" + matcher.start(i));\n            System.out.println(\"The index of the last one character is \" + matcher.end(i));\n            System.out.println(\"The content of the corresponding substring of this string is \" + matcher.group(i));\n        }\n    }\n}\n```\n![运行结果](https://upload-images.jianshu.io/upload_images/9031347-1da5a9531d665f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n看！多调用一次find方法就匹配到第二段字符串了！\n\n####或者还可以在find方法中添加一个开始匹配的索引值，正则表达式只匹配这个整形参数索引后面的子字符串：\n```java\nmatcher.find(12)\n```\n效果和使用两次find的一样！\n');
INSERT INTO `blog_content` VALUES (27, '> JMM,即java内存模型，是在硬件基础上抽象出来的模型，不是实际存在的。其将内存主要分为两个部分：主内存和工作内存。前者为所有线程共享区域，后者为线程私有。\n\n> 线程被创建出来，就会有一个工作内存区域，其所需要的一些数据也会从主内存中拷贝至私有内存中，而不是直接在主内存中操作。线程与线程之间的数据交换也是通过主内存来传递的。\n\n>并发编程的三个概念：可见性、原子性、有序性。并发程序的正确执行需要确保这三个性质的正确性。\n\n> 缓存一致性问题：即可见性问题。前面所说线程不会直接在主内存中工作，而是从主内存中拷贝一份至私有内存。当电脑为单核时这样做不会影响可见性，可如今电脑多为多核，在每个cpu中都有一个线程执行。多核就有多线程**并行**。当一个线程修改了主内存的值时，另一个线程使用的确实修改前的值。这就是缓存一致性问题。以下测试缓存一致性代码：\n```java\npublic class TestVisibility {\n\n    /**\n     *如果没有加volatile，下面的第一个启动的子线程就会一直呈现阻塞状态。\n     * 这也就体现了volatile可以解决缓存一致性问题！\n     */\n    private static volatile boolean stop = false;\n\n    public static void main(String[] args) throws InterruptedException {\n        new Thread(()->{\n            int i = 0;\n            while (!stop) {\n                i++;\n            }\n        }).start();\n//        测试可见性下面的延时必不可少，我们知道，原子性无法保证，上面的对于stop变量还需要进行load操作\n//        只有当stop被上面的线程导入进了线程工作区才可体现可见性问题\n        TimeUnit.SECONDS.sleep(1);\n        System.out.println(\"线程启动成功！\");\n        new Thread(() -> {\n            stop = true;\n        }).start();\n    }\n}\n```\n\n>如何保证可见性呢？\n解决缓存一致性问题有两种方式：总线锁和缓存锁。我们知道cpu从主存中读取数据必通过总线，总线锁就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就可以独占共享锁。但是显然这样效率就会很低了！\n缓存锁即在主内存中变量行加锁，遵循MESI协议，加锁后数据既有四种状态：S：此变量已被多核拷贝。E:此变量被单核拷贝。M:此变量被修改。I：如此数据被某个线程修改，其他线程中拷贝的值失效。        缓存锁保证了当一个线程修改了某个变量后即修改锁至M，此后其他线程想使用这个变量时，检测到主内存中的变量值已被修改，私有工作内存中的变量失效，重新载入新的值！\n\n> volatile为什么不能保证原子性？\n答：因为volatile算能在读取内存中的数据会加一个锁，其他线程在使用期间会察觉出变量的改变。但是线程从主内存中载入数据和修改数据值后更新主内存中数据的操作期间其他线程修改了值是察觉不到的。\n\n>如何保证原子性？\n答：使用synchronized/Atomic/java.Util.Concurrent.Lock。\nsynchronized在域中所有数据加锁，这些数据每次只能有一个线程使用。\nLock效果1.能够去把当前处理器缓存的数据写到系统内存。2.是其他处理器缓存行数据失效。岂能出发总线锁或缓存锁没具体取决于cpu自己！以下是测试原子性问题代码：\n```java\npublic class TestAtomic {\n    private static class innerClass {\n        public static int count = 0;\n\n        private static void sleep(long millisecond) {\n            try {\n                Thread.sleep( millisecond);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public static synchronized void inc() {\n            //加上synchronized然后注释掉sleep就可以实现每次获取的结果为1000，否则为4，想想为什么！\n//            sleep(1000);\n            count++;\n        }\n\n\n        private static Lock lock = new ReentrantLock();\n\n        /**\n         * 使用java.util.Concurrent包中的lock也能解决原子性问题！\n         */\n        public static void incWithLock() {\n            lock.lock();\n            count++;\n            lock.unlock();\n        }\n\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 1000; i++) {\n            new Thread(()->{\n                innerClass.incWithLock();\n            }).start();\n        }\n        innerClass.sleep(4000);\n\n        //得到的值可能为1000也可能是小于1000，这就证明了count++不是原子性操作！\n        System.out.println(\"count :\" + innerClass.count);\n    }\n}\n\n```\n');
INSERT INTO `blog_content` VALUES (29, '### Pattern\n\n1. `pattern.matches(regex， text)` 返回boolean对象，表示一个句子是否符合正则表达式！\n\n2. ```java\n   Pattern pattern = Pattern.compile(regex);\n   Matcher matcher = pattern.matcher(text)\n   ```\n\n   其也有一个matches方法判断是否匹配！\n\n3. Pattern.split() 方法可以用正则表达式作为分隔符来断句。\n\n   ```java\n   Pattern pattern = Pattern.compile(patternString);\n   String[] split = pattern.split(text);\n   ```\n\n4. Pattern.pattern()其实就是获取编译了的regrex！即compile方法的参数！\n\n### Matcher\n\njava.util.regex.Matcher 类用于匹配一段文本中多次出现一个正则表达式，Matcher 也适用于多文本中匹配同一个正则表达式。构造方式：\n\n```java\nString text    =\n        \"This is the text to be searched \" +\n        \"for occurrences of the http:// pattern.\";\nString patternString = \".*http://.*\";\nPattern pattern = Pattern.compile(patternString);\nMatcher matcher = pattern.matcher(text);\n```\n\n1. `boolean matches = matcher.matches();`\n\n2. **lookingAt()** 与matches() 方法类似，最大的不同是，lookingAt()方法对文本的开头匹配正则表达式；而\n\n   matches() 对整个文本匹配正则表达式。\n\n3. #### find() + start() + end()\n\n   **find()** 方法用于在文本中查找出现的正则表达式，文本是创建Matcher时，通过 Pattern.matcher(text) 方法传入的。如果在文本中多次匹配，find() 方法返回第一个，之后**每次调用 find() 都会返回下一个**。\n\n   **start() 和 end()** 返回每次匹配的字串在整个文本中的开始和结束位置。实际上, end() 返回的是字符串末尾的后一位，这样，可以在把 start() 和 end() 的返回值直接用在String.substring() 里。\n\n4. #### reset()\n\n   **reset()** 方法会重置Matcher 内部的 匹配状态。当find() 方法开始匹配时,Matcher 内部会记录截至当前查找的距离。调用 reset() 会重新从文本开头查找。\n\n    **reset(CharSequence)** 方法. 这个方法重置Matcher,同时把一个新的字符串作为参数传入，用于代替创建 Matcher 的原始字符串。\n\n5. #### group()\n\n   假设想在一个文本中查找URL链接，并且想把找到的链接提取出来。当然可以通过 start()和 end()方法完成。但是用group()方法更容易些。\n\n   使用**group(int groupNo)** 方法访问一个分组。一个正则表达式可以有多个分组。每个分组由一对括号标记。想要访问正则表达式中某分组匹配的文本，可以把分组编号传入 group(int groupNo)方法。\n\n   group(0) 表示整个正则表达式，要获得一个有括号标记的分组，分组编号应该从1开始计算。\n\n   ```regex\n   ((John) (.+?))\n   ```\n\n   当遇到嵌套分组时, 分组编号是由左括号的顺序确定的。上例中，分组1 是那个大分组。分组2 是包括John的分组，分组3 是包括 .+? 的分组。当需要通过groups(int groupNo) 引用分组时，了解这些非常重要。\n\n6. #### replaceAll() + replaceFirst()\n\n   replaceAll() 和 replaceFirst() 方法可以用于替换Matcher搜索字符串中的一部分。replaceAll() 方法替换全部匹配的正则表达式，replaceFirst() 只替换第一个匹配的。\n\n   在处理之前，Matcher 会先**reset()重置**。所以这里的匹配表达式从**文本开头**开始计算。两个方法返回替换后的文本！\n\n7. #### appendReplacement() + appendTail()\n\n   appendReplacement() 和 appendTail() 方法用于替换输入文本中的字符串短语，同时把替换后的字符串附加到一个 StringBuffer 中。\n\n   当find() 方法找到一个匹配项时，可以调用 appendReplacement() 方法，这会导致输入字符串被增加到StringBuffer 中，而且匹配文本被替换。 从上一个匹配文本结尾处开始，直到本次匹配文本会被拷贝。\n\n   appendReplacement() 会记录拷贝StringBuffer 中的内容，可以持续调用find(),直到没有匹配项。\n\n   直到最后一个匹配项目，输入文本中剩余一部分没有拷贝到 StringBuffer. 这部分文本是从最后一个匹配项结尾，到文本末尾部分。通过调用 appendTail() 方法，可以把这部分内容拷贝到 StringBuffer 中.\n\n   ```java\n   String text    =\n             \"John writes about this, and John Doe writes about that,\" +\n                     \" and John Wayne writes about everything.\"\n           ;\n   \n   String patternString1 = \"((John) (.+?)) \";\n   Pattern      pattern      = Pattern.compile(patternString1);\n   Matcher      matcher      = pattern.matcher(text);\n   StringBuffer stringBuffer = new StringBuffer();\n   \n   while(matcher.find()){\n       matcher.appendReplacement(stringBuffer, \"Joe Blocks \");\n       System.out.println(stringBuffer.toString());\n   }\n   matcher.appendTail(stringBuffer);\n   System.out.println(stringBuffer.toString());\n   ```\n\n   注意我们在while循环中调用appendReplacement() 方法。在循环完毕后调用appendTail()。 代码输出如下:\n\n   ```plain\n   Joe Blocks\n    Joe Blocks about this, and Joe Blocks\n    Joe Blocks about this, and Joe Blocks writes about that, and Joe Blocks\n    Joe Blocks about this, and Joe Blocks writes about that, and Joe Blocks\n    writes about everything.\n   ```\n\n### 基本语法\n\n- **字符** ： 作用是简单的匹配一个确定的字符。可以在表达式中使用任意英文字符。也可以使用字符对于的8进制，16进制或unicode编码表示。\n\n- **字符分类**，用[]表示匹配中括号中的任意字符比如： [Jj]ohn\n\n- **预定义字符**：比如 d 表示数字，s 表示空白字符，S表示非空白字符\n\n- **边界匹配**：w 匹配一个单词，^匹配行首,$ 匹配行尾。\n\n- **量词匹配**：*表示0次或多次，+表示一次或多次，？表示零次或一次\n\n  > 量词匹配的三种模式，饥饿模式(.*?)，贪婪模式(.*)，独占模式(.*+)！\n  >\n  > 饥饿和贪婪略！\n  >\n  > 贪婪和独占模式的区别：\n  >\n  > `John went for a walk, and John fell down, and John hurt his knee.`\n  >\n  > 使用`John.*hurt`即贪婪模式来匹配能匹配到`John went for a walk, and John fell down, and John hurt`，如果用独占模式的话会直接`John.*+`匹配整个句子而忽略hurt导致匹配不成功！\n\n- ### 逻辑操作符\n\n  正则表达式支持少量的逻辑运算(与，或，非)。\n\n  与操作是默认的，表达式 John ,意味着J 与 o与h与n。\n\n  或操作需要显示指定，用 | 表示。例如表达式 John|hurt 意味着John 或 hurt 。\n\n- ## 字符\n\n  | .      | 任意英文字母                                                 |\n  | ------ | :----------------------------------------------------------- |\n  | \\     | 反斜杠, 单独的反斜杠做为转义字符,与其他特殊字符一起使用。如果想匹配反斜杠本身,需要转义。两个反斜杠实际匹配一个反斜杠n字符的8进制表示.n 在0至7之间取值 |\n  | nn     | 字符的8进制表示.n 在0至7之间取值                             |\n  | mnn    | 字符的8进制表示. m 在0至3之间取值, n 在0至7之间取值          |\n  | xhh   | 字符的16进制表示.                                            |\n  | uhhhh | 字符的16进制表示 0xhhhh. 对应unicode 编码字符                |\n  | 	     | 缩进符.                                                      |\n  | \n     | 换行符 (unicode: ‘u000A’)                                   |\n  | \r     | 回车符 (unicode: ‘u000D’)                                   |\n  | f     | 制表符 (unicode: ‘u000C’)                                   |\n  | a     | 警报（铃声）字符 (unicode: ‘u0007′)                         |\n  | e     | 转义符 (unicode: ‘u001B’)                                   |\n  | cx    | 控制符 x                                                     |\n\n- ## 字符分类\n\n  | [abc]         | 匹配 a, 或 b 或 c                                            |\n  | ------------- | ------------------------------------------------------------ |\n  | [^abc]        | 匹配不是a,b,c 的字符，是否定匹配                             |\n  | [a-zA-Z]      | 匹配a 到 z ，A到Z 直接的字符，是范围匹配                     |\n  | [a-d[m-p]]    | 匹配a到d之间字符或 m到p之间字符，是并集匹配                  |\n  | [a-z&&[def]]  | 匹配 d, e, 或 f. 是交集匹配 (这里是在范围 a-z和字符def之间取交集). |\n  | [a-z&&[^bc]]  | 匹配a-z 之间所有字符，排除bc的字符。是减法匹配               |\n  | [a-z&&[^m-p]] | 匹配a-z 之间所有字符,排除m-p之间的字符是减法匹配             |\n\n- ## 内置字符分类\n\n| .    | 匹配任意一个字符,根据创建Pattern是传入的标志,可能匹配行结尾符 |\n| ---- | ------------------------------------------------------------ |\n| d   | 匹配任意数字 [0-9]                                           |\n| D   | 匹配任意非数字 [^0-9]                                        |\n| s   | 匹配任意空白符 (空格, 缩进, 换行,回车)                       |\n| S   | 匹配任意非空白符                                             |\n| w   | 匹配任意单词                                                 |\n| W   | 匹配任意非单词                                               |\n\n## 边界匹配\n\n| ^    | 匹配行首                                                     |\n| ---- | ------------------------------------------------------------ |\n| $    | 匹配行尾                                                     |\n|    | 匹配单词边界                                                 |\n| B   | 匹配非单词边界                                               |\n| A   | 匹配文本开头                                                 |\n| G   | 匹配前一匹配项结尾                                           |\n| \Z   | Matches the end of the input text except the final terminator if any |\n| z   | 匹配文本结尾                                                 |\n\n## 量词\n\n![](https://upload-images.jianshu.io/upload_images/9031347-33ec11a88a15b68b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n');
INSERT INTO `blog_content` VALUES (30, '原文：[Java8的HashMap详解（存储结构，功能实现，扩容优化，线程安全，遍历方法）](https://blog.csdn.net/login_sonata/article/details/76598675)\nJDK1.8对HashMap底层的实现进行了优化，**例如引入红黑树的数据结构和扩容的优化等**。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理，**文章末尾附有HashMap的put方法和resize方法的源码解析**。\n\n简介\n==\n\nJava为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：  \n![map类继承关系](http://upload-images.jianshu.io/upload_images/9031347-f32bd355a5af2b33?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n下面针对各个实现类的特点做一些说明：\n\n(1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，**但遍历顺序却是不确定的**。 **HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全**，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。\n\n(2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，**键值都不可为null，并且是线程安全的**，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。\n\n> 简单来说，Hashtable通过给方法加synchronized实现线程安全。而**ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成**。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。  \n> 分段锁可理解为，把整个Map分成了N个Segment，put和get的时候，根据key.hashCode()找到该使用哪个Segment，这个Segment做到了类似于Hashtable的线程安全，**分段锁就是说用到哪部分就锁哪部分。ConcurrentHashMap键值不能为null**。\n\n(3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，**保存了记录的插入顺序**，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。\n\n(4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，**默认是按键值的升序排序，也可以指定排序的比较器**，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。\n\n对于上述四种Map类型的类，**要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变**。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。\n\n通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。\n\n存储结构\n====\n\n从结构实现来讲，HashMap是**数组+链表+红黑树**（JDK1.8增加了红黑树部分）实现的，如下图所示：  \n![存储结构](http://upload-images.jianshu.io/upload_images/9031347-daab9b4873b30711?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里需要讲明白两个问题：数据底层具体存储的是什么（上图的黑点）？这样的存储方式有什么优点呢？\n\n(1) 从源码可知，HashMap类中有一个非常重要的字段，**就是Node[] table，即哈希桶数组**，明显它是一个Node的数组，我们来看Node[JDK1.8]是何物：\n\n    static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;    //用来定位数组索引位置\n        final K key;\n        V value;\n        Node<K,V> next;   //链表的下一个node\n    \n        Node(int hash, K key, V value, Node<K,V> next) { ... }\n        public final K getKey(){ ... }\n        public final V getValue() { ... }\n        public final String toString() { ... }\n        public final int hashCode() { ... }\n        public final V setValue(V newValue) { ... }\n        public final boolean equals(Object o) { ... }\n    }\n\n**Node是HashMap的一个内部类，实现了Map.Entry接口，本质就是一个映射(键值对)**。上图中的每个黑色圆点就是一个Node对象。\n\n(2) HashMap就是使用**哈希表**来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，**Java中HashMap采用了链地址法**。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：\n\n    map.put(\"美团\",\"小美\");\n\n系统将调用”美团”这个**key的hashCode()方法得到其hashCode 值**（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（**高位运算和取模运算**，下文有介绍）来**定位该键值对的存储位置**，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。\n\n如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组（Node[] table）的大小，并在此基础上设计好的hash算法减少Hash碰撞。**所以好的Hash算法和扩容机制至关重要**。\n\n在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化：\n\n    int threshold;             // 扩容阈值 \n    final float loadFactor;    // 负载因子\n    transient int modCount;  // 出现线程问题时，负责及时抛异常\n    transient int size;     // HashMap中实际存在的Node数量\n\n首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。\n\n结合负载因子的定义公式可知，**threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍**。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，比如内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。\n\nsize这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而**modCount字段主要用来记录HashMap内部结构发生变化的次数**。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。\n\n> 我们知道java.util.HashMap不是线程安全的，因此在使用**迭代器Iterator**的过程中，如果有其他线程修改了map，将抛出ConcurrentModificationException，这就是所谓fail-fast策略。**这一策略在源码中的实现就是通过modCount**，它记录修改次数，在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount，在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map。所以遍历那些非线程安全的数据结构时，尽量使用迭代器Iterator。\n\n**在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计**，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考[http://blog.csdn.net/liuqiyao_01/article/details/14475159](http://blog.csdn.net/liuqiyao_01/article/details/14475159)，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，**主要是为了在取模和扩容时做优化，同时减少冲突**，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。\n\n这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。**而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能**。想了解更多红黑树数据结构的工作原理可以参考：[红黑树算法原理（从二叉搜索树讲起）](http://blog.csdn.net/login_sonata/article/details/76691027)。\n\n功能实现\n====\n\nHashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入讲解。\n\n1. 确定哈希桶数组索引位置\n---------------\n\n不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):\n\n    // 方法一，jdk1.8 & jdk1.7都有：\n    static final int hash(Object key) {\n         int h;\n         return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n    // 方法二，jdk1.7有，jdk1.8没有这个方法，但是实现原理一样的：\n    static int indexFor(int h, int length) {\n         return h & (length-1);  \n    }\n\n**这里的Hash算法本质上就是三步：**  \n(1) **取key的hashCode值**，h = key.hashCode()；  \n(2) **高位参与运算**，h ^ (h >>> 16)；  \n(3) **取模运算**，h & (length-1)。\n\n对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。\n\n这个方法非常巧妙，它通过h & (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。**当length总是2的n次方时，h& (length-1)运算等价于对length取模**，也就是h%length，但是&比%具有更高的效率。\n\n在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到**高低Bit都参与到Hash的计算中**，同时不会有太大的开销。\n\n下面举例说明下，n为table的长度：  \n![高位运算](http://upload-images.jianshu.io/upload_images/9031347-67ef1e2c8d48cae0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 分析HashMap的put方法\n-------------------\n\nHashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习，源码在本文最后可以找到。  \n![put](http://upload-images.jianshu.io/upload_images/9031347-8f94d8e8e6f9f067?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3. 扩容机制\n--------\n\nHashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。\n\n首先举个例子直观感受下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。  \n![resize](http://upload-images.jianshu.io/upload_images/9031347-674c0e0435bcfc45?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n简单说就是**换一个更大的数组重新映射**。下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，**元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置**。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。  \n![这里写图片描述](http://upload-images.jianshu.io/upload_images/9031347-2f51abda399681e1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：  \n![这里写图片描述](http://upload-images.jianshu.io/upload_images/9031347-f5c85a6b0fb5c18d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n因此，我们在扩充HashMap的时候，**不需要像JDK1.7的实现那样重新计算hash**，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：  \n![这里写图片描述](http://upload-images.jianshu.io/upload_images/9031347-32368e0a1120d732?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，**JDK1.8不会倒置**。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，在本文最后可以找到。\n\n线程安全性\n=====\n\n在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。主要是多线程同时put时，如果同时触发了rehash操作，会导致HashMap中的链表中出现循环节点，进而使得后面get的时候，会死循环。具体原因可以看原文或者这篇文章：  \n[http://blog.csdn.net/xuefeng0707/article/details/40797085](http://blog.csdn.net/xuefeng0707/article/details/40797085)\n\n遍历Map对象\n=======\n\n既然java中的所有map都实现了Map接口，以下方法适用于任何map实现（HashMap, TreeMap, LinkedHashMap, Hashtable, 等等）：\n\n**方法一： 在for-each循环中使用entries来遍历**\n\n这是最常见的并且在大多数情况下也是最可取的遍历方式。在键值都需要时使用。但是如果你遍历的是一个空的map对象，for-each循环将抛出NullPointerException，因此**在遍历前你总是应该检查空引用**。\n\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n        System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue());\n    }\n\n**方法二：在for-each循环中遍历keys或values**\n\n如果只需要map中的键或者值，你可以通过性能稍好的keySet()或values()来实现遍历，而不是用entrySet()。\n\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n    //遍历map中的键\n    for (Integer key : map.keySet()) {\n        System.out.println(\"Key = \" + key);\n    }\n    //遍历map中的值\n    for (Integer value : map.values()) {\n        System.out.println(\"Value = \" + value);\n    }\n\n**方法三：使用Iterator遍历**\n\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n    // 使用泛型\n    Iterator<Map.Entry<Integer, Integer>> entries = map.entrySet().iterator();\n    while (entries.hasNext()) {\n        Map.Entry<Integer, Integer> entry = entries.next();\n        System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue());\n    }\n\n你也可以在keySet和values上应用同样的方法。  \n该种方式看起来冗余却有其优点所在。首先，在老版本java中这是惟一遍历map的方式。另一个好处是，你可以在遍历时调用iterator.remove()来**删除** entries，另两个方法则不能。\n\n小结\n==\n\n(1) 扩容是一个特别耗性能的操作，所以使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。\n\n(2) HashMap是线程不安全的，在并发的环境中建议使用ConcurrentHashMap。\n\n(3) JDK1.8引入红黑树大程度优化了HashMap的性能，这主要体现在hash算法不均匀时，即产生的链表非常长，这时把链表转为红黑树可以将复杂度从O(n)降到O(logn)。\n\n（4）HashMap是如何工作的？面试时可以这么回答：  \nHashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值。\n\n附put方法源码\n========\n\n    public V put(K key, V value) {\n        // 对key的hashCode()做hash\n        return putVal(hash(key), key, value, false, true);\n    }\n    \n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        // 步骤①：tab为空则创建\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n        // 步骤②：计算index，并对null做处理 \n        if ((p = tab[i = (n - 1) & hash]) == null) \n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n            // 步骤③：节点key存在，直接覆盖value\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            // 步骤④：判断该链为红黑树\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            // 步骤⑤：该链为链表\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key,value,null);\n                         //链表长度大于8转换为红黑树进行处理\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st  \n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                     // key已经存在直接覆盖value\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k)))) \n                               break;\n                    p = e;\n                }\n            }\n    \n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n    \n        ++modCount;\n        // 步骤⑥：超过最大容量 就扩容\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n\n附resize方法源码\n===========\n\n    final Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            // 超过最大值就不再扩充了，就只好随你碰撞去吧\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            // 没超过最大值，就扩充为原来的2倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        // 计算新的resize上限\n        if (newThr == 0) {\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            // 把每个bucket都移动到新的buckets中\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                        // 链表优化重hash的代码块\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            // 原索引\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            // 原索引+oldCap\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        // 原索引放到bucket里\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        // 原索引+oldCap放到bucket里\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n');
INSERT INTO `blog_content` VALUES (31, '> 以前想使用wget下载jdk包，手动安装jdk时，总是会遇到这种问题。现在终于得到解决！\n转自：https://blog.csdn.net/lwgkzl/article/details/79889983\n\n##坑点:\n直接在jdk官网右键复制链接地址，然后wget + 地址.\n\n这样下下来的文件只是一个HTML文件，然后当你tar 解压的时候，你会很惊喜的发现这个错误。\n\n    gzip: stdin: not in gzip format\n    tar: Child returned status 1\n    tar: Error is not recoverable: exiting now\n\n因为HTML是不能够解压的，虽然他的名字也是*.tar,gz，下载速度还特别快。\n\n##正确姿势：\n```\nwget --no-check-certificate --no-cookies --header \"Cookie: oraclelicense=accept-securebackup-cookie\" + 右键复制的链接\n```\n> 注意接收他的协议，不然你不能复制。\n\n##原因：\n这个网址并不可以直接下载，貌似还经过了两次重定向，所以你直接wget是不行的。\n\n## 参数含义：\n\n> --no-check-certificate表示不校验SSL证书，因为中间的两个302会访问https，会涉及到证书的问题，不校验能快一点，影响不大，\n\n> --no-cookies表示不使用cookies,当然首次在header里指定的会带上，后面重定向的就不带了，这个影响也不大，可以不加\n');
INSERT INTO `blog_content` VALUES (33, '[博客](https://blog.csdn.net/jxufecodelong/article/details/16591369)\n');
INSERT INTO `blog_content` VALUES (34, '#### 以其中一个名为rsync的文件为例：\n命令：```cat rsync  查看```\n显示如下：\n```\n# default: off\n# description: The rsync server is a good addition to an ftp server, as it \n#	allows crc checksumming etc.\nservice rsync\n{\n	disable	= yes\n	flags		= IPv6\n	socket_type     = stream\n	wait            = no\n	user            = root\n	server          = /usr/bin/rsync\n	server_args     = --daemon\n	log_on_failure  += USERID\n}\n```\n\n详解：\n![](https://upload-images.jianshu.io/upload_images/9031347-9dc07a21384b9b0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n');
INSERT INTO `blog_content` VALUES (35, 'buffer和cache都有缓存之意，但是在谷歌翻译中buffer只是缓存，而cache的意思是高速缓存！\n谷歌搜索两者的区别：\n![图片来自youtube](https://upload-images.jianshu.io/upload_images/9031347-3b47e7133963e973.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n|buffer|cache|\n|:--:|:--:|\n|短时间保存数据的容器|数据高速操作的缓冲区|\n|buffer是常速缓冲区|cache是高速缓冲区|\n|buffer用于i/o操作|cache在R/W时使用|\n|buffer是内存的一部分|cache是硬盘的一部分|\n|buffer来自于动态内存|cache来自于静态内存|\n|buffer先进后出|cache先进先出|\n');
INSERT INTO `blog_content` VALUES (36, '参考博客：https://blog.csdn.net/luckywang1103/article/details/50829812（想留言感谢但学校网（呕~）不支持，qq登录会加载失败。在这里，感谢博主！）\n> 初探Linux系统，老师的非常简单的实验报告1就花去了我很多的时间，但这些时间是值得的，搜索到的扩展了课内所学知识，磕磕碰碰时打了那么多的命令也会让我更加熟练。总之，linux还是很有趣的！\n\n实验的12题是我花时间最多的题目，它是关于linux下的系统挂载问题，不仅要解决虚拟机读取u盘的问题，还要关闭centos的自动挂载，然后才能手动挂载。\n\n```\n12.在linux系统上挂装优盘，并将优盘中的一个文件复制到系统的用户主目录中，再把用户主目录\n   中的一个文件复制到优盘，最后卸装优盘。\n```\n### 使虚拟机能读取u盘\n1. 开启服务\n开始菜单搜索服务，找到```VMware USB Arbitration Service```：\n![](https://upload-images.jianshu.io/upload_images/9031347-e223b0324412ff0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n开启此服务！\n2. 切换usb版本\n开启服务后还是读取不到怎么办，网上说换插孔试试，细细一想赶紧是usb版本问题，我们更换下虚拟机读取的usb版本试试看：\n右键虚拟机点击设置，然后找USB控制器（或USB Controller），找不到可以点击下方的添加按钮添加：\n![一开始我的是usb2.0](https://upload-images.jianshu.io/upload_images/9031347-b28a65196fef798e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n重启下系统就能在桌面看到：\n![没有u盘，kindle上](https://upload-images.jianshu.io/upload_images/9031347-995af78b0649821d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 关闭自动挂载\n3. 关闭自动挂载\n此时我们还是不能手动挂载的，因为系统以及帮我们自动挂载了，这也就是为什么后面手动挂载时运行命令mount显示的结果是```XXX已挂载或XXX正忙```的原因了吧（猜的，但估计八九不离十！）\n**如何挂载呢？**\n- 首先切换roo权限：```su root```\n- 通过命令：```fdisk -l```获取设备名称！\n![输入命令后回车在最下面会看到多了这个，即设备名称！](https://upload-images.jianshu.io/upload_images/9031347-35bc481a566804a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 命令 ```ll /dev/disk/by-uuid```获取设备的uuid\n![uuid即蓝色部分](https://upload-images.jianshu.io/upload_images/9031347-af53e0fb62787bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 注意！名字要与上面的那个相同，但我这边的设备名不同，是因为之前借室友的u盘没用，然后kindle试了试就好了，即截图时间不一样！我也懒得截过图了！\n\n- 编辑/etc/fstab：``` vi /etc/fstab```在尾部添加：\n```UUID=\"设备的uuid号\" /media vfat noauto 0 0```\n然后再重启下就行了，系统不会再自动加载u盘了！\n- 如果想开启自动挂载，直接把刚刚在文件中添加的一行去掉就行了，不用重启，系统就会自动挂载！\n\n### 挂载u盘\n4. 手动挂载及卸载U盘\n这个操作网上很多教程，步骤也很简单\n```mount /dev/设备名 /mnt```\n即挂载成功！接下来就可以像操作普通目录般操作mnt目录下的u盘文件了！\n**卸载：**\n```umount /dev/设备名```\n即可，/mnt文件显示为空！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n');
INSERT INTO `blog_content` VALUES (37, '[TOC]\n\n> 在了解linux权限时发现了一篇关于umask非常不错的文章，但他是用英语写的，对英语要求不用太高就能看懂，感兴趣的可以看[原文](https://www.computerhope.com/unix/uumask.htm)。前面说了英语要求不高，所以我干这个不是为了彰显什么我的英语水平（有些句子都还需靠谷歌翻译...），纯属无聊和对这篇文章的喜欢，有错虚心接受，没有错最好！\n\n#####以下翻译后的所有内容：\n\n\n\n![](https://upload-images.jianshu.io/upload_images/9031347-f32318105e5c55e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n---\n\n## 关于umask\n返回或设置系统文件模式创建掩码的值\n\n---\n## 具体描述\n在Linux和其他类Unix的操作系统中，新的文件被创建是会有一系列默认权限设置。可以通过一个应用名为umask设置掩码，专门限制新文件的权限。umask命令用来设置掩码，或者获取它当前的值。\n\n---\n## umask命令语法格式\n> umask [-s] [mask]\n\n---\n## 选项\n|选项|含义|\n|:--:|:--:|\n|-s|接受或返回一个代表掩码的符号|\n|mask|如果指定了一个合理的掩码，这个umask就将被设置为这个值。如果没有指定掩码，返回当前的掩码值|\n\n---\n## 什么是权限，它们是怎么工作的\n我们都知道系统里的每个文件都被绑定一系列权限去保护文件，一个文件的权限决定了那个用户能操作它，能进行什么操作。\n\n大体上有三种用户类别：\n- 文件的拥有者（“User”）\n- 和文件拥有者一组的组员（“Group”）\n- 除了root和以上两种的其他用户（“Other”）\n\n反过来，对于这几类的用户，有三种对文件的操作分类：\n- 查看文件内容的权限--读（“Read”）\n- 改变文件内容的权限--写（“Write”）\n- 在系统中将文件内容作为一个程序运行的权限--执行（“Execute”）\n\n因此，对于每一类的用户，都有三种权限，这些信息加在一起构成了文件的权限。\n\n## 如何表示权限\n有两种方法表示一个文件的权限：符号表示（用像“r”对应读，“w”对应写，“x”对应执行这样的符号）或者用一个八进制数值表示。\n\n比如，当用下面的命令行列出一个目录下的内容\n> ls -l\n\n你能看到（在其他别的信息中）每个文件的文件权限信息，通过符号的方式显示，向下面这样：\n```-rwxr-xr--```\n有十个符号，第一个横线“-”表示这是一个“普通”文件，不是一个目录（或者其他快文件或者其他之类的）。其余的九个符号代表的是用户权限：**rwxr-xr--**。这从九个符号左到右其实就是三组对应于三类用户的文件权限：\n\n|符号|含义|\n|:--:|:--:|\n|rwx|**文件所有者**可以**读、写**或者**执行**文件|\n|r-x|**组员**可以**读**或者**执行**这个文件，但是不能修改|\n|r--|**其他用户**可以读这个文件，但是不能写或者执行这个文件|\n\n## 用符号指定新建文件的掩码\n组成掩码的符号通常如下所示：\n> [user class symbol(s)][permissions operator][permission symbol(s)][,]...\n\n权限符号可以是r（读），w（写），x（执行）的任意组合，就像上面的那样。\n\n用户类别符号可以是以下的一个或者多个：\n\n|符号|含义|\n|:--:|:--:|\n|u|User（文件所有者）|\n|g|Group（在文件定义组中的任一成员）|\n|o|Other（其他成员）|\n|a|All（相当于**ugo**）|\n权限操作符可能是以下的一种：\n\n|符号|含义|\n|:--:|:--:|\n|+|允许赋予指定用户指定的文件权限（没有指定的权限在掩码中是不能被改变的）|\n|-|禁止特定的文件权限被赋予给某一种用户类别（没有指定的权限在掩码中是不能被改变的）|\n|=|赋予一种用户拥有其他某种用户的文件权限（在文件创建时没有指定的权限将会被禁止被掩码赋予给用户）|\n\n比如下面的这个**umask**命令行：\n> umask u+w\n\n就是设置掩码去赋予创建文件的用户（也就是文件拥有者）写的权限。其他的文件权限将不能被系统默认的所改变。\n\n一次可以通过几组逗号隔开的符号（而不是空格）指定多个权限：\n> umask u-x,g=r,o+w\n\n这个命令可以设置掩码这样后面新建的文件我们就能有下面的这样的权限：\n1. 禁止文件所有者的写的权限，而其他所有者权限没有改变；\n2. 赋予了组员读文件权限，而禁止了其写和执行的权限；\n3. 赋予其他用户写的权限，而其他权限没有改变\n值得注意的是如果你用了“=”却没有指定权限如下面这样：\n> umask a=\n\n将会设置掩码让文件对所有用户没有任何操作权限！\n\n## 用数字指定新建文件的掩码\n新建文件的掩码也能通过用八精制数字表示。当使用这些八进制文件表示时，特定我的狮子代表特定的权限，而且这些数字通过相互加减来代表最终的权限组合值，特别是数字1,2和4分别代表以下权限：\n\n|数字|权限|\n|:--:|:--:|\n|4|read|\n|2|write|\n|1|execute|\n用这些数字是因为这三个数字组成的值都是独一无二的，下表演示的就是他们组成的值：\n\n|读 + |写 + |执行=|组合值|对等的符号|\n|:--:|:--:|:--:|:--:|:--:|\n|0|0|0|0||\n|0|0|1|1|x|\n|0|2|0|2|w|\n|0|2|1|3|wx|\n|4|0|0|4|r|\n|4|0|1|5|rx|\n|4|2|0|6|rw|\n|4|2|1|7|rwx|\n\n> 即读 + 写 + 运行 = 组合值，读是4，写是2， 执行时1，既能读又能写就是**2+4=6**，以此类推.\n对于每种用户来说，一个数字就可以代表他们的权限；上面的例子我们能代表想**rwxr-xr-- **这样的符号表示，使用三个八进制数字**754**，每个个数字的代表的顺序是：**User，Group，Other**。\n\n## 其他权限数\n在八进制代表文件权限方法的表示中，却有有四个数字。其中后三个数字是我们需要重点谈论的，而第一个数字是一个特殊文件权限表示符。出于（for the purpose of）讨论的目的我们暂且将其认为是0.因此现在开始（from here on out）我们讨论文件权限为777时，表示的是**0777**。\n\n## 所以Umask是具体是怎么工作的呢？\n```The umask masks permissions by restricting them by a certain value.```\numask通过权将权限限制为某个值来屏蔽权限（from google translate）\n\n实质上（Essentially），umask的每个数字都会被系统自带的默认值“减去”来达到你所定义的默认值。不是真的减去；技术上来说（technically），掩码的补码（它的按位补码```bitwise compliment```）然后它的将被使用逻辑and操作去做默认权限。结果就是在创建文件时umask告诉系统哪些权限位关闭。因此这不是真的减法，但是是相似的概念，把它想成减法有助于理解。\n\n在linux中，一个普通文件的默认权限值是***666***，文件夹的是**777**。当创建一个文件或文件夹时，[内核](https://www.computerhope.com/jargon/k/kernel.htm)（kernel）会调用默认值“减去”umask值，去得出新文件的权限。\n\n这个列表展示的是umask中每个数字对应的文件或文件夹的权限：\n\n|umask数字值|默认的文件权限|默认的文件夹权限|\n|:--:|:--:|:--:|\n|0|rw|rwx|\n|1|rw|rw|\n|2|r|rx|\n|3|r|r|\n|4|w|wx|\n|5|w|w\n|6|x|x\n|7|(no permission allowed)|(no permission allowed)|\n\n因此，如果umask的值是022，默认新文件的有默认权限值是644**（666-022）**。类似的（Likewise），新新文件夹的权限就是755**（777-022）**\n\n## umask 例子\n查看当前umask的值，输入命令行：\n> umask\n\n会返回你系统四位八进制的umask值。\n![](https://upload-images.jianshu.io/upload_images/9031347-f22adfd186656774.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n再者，第一个0是个特殊权限值而且不可忽视，在这里对我们来说，0002相当于002。\n\n我们可以在后面加上-S标签查看其符号表示\n> umask -S\n\n会显示符号信息：\n![](https://upload-images.jianshu.io/upload_images/9031347-0538b8b3abe8b48e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上面的u表示的是user，g表示group，o就表示其他用户。这告诉我们如果我们创建一个文件，会有默认权限664，是由666-002得出的！\n\n我们用touch命令新建一个文件测试下：\n> umask -S\ntouch testfile\nls -l testfile\n\n![](https://upload-images.jianshu.io/upload_images/9031347-b940707d5facb5bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```译者注：rw就等于6，所以上面显示的-rw-rw-r--的八进制表示就是664（即 666 - 002得出！）```\n\n正如预期的那样,新文件的权限为**-rw-rw-r--**，或者是**664**，owner和group能读和写，other只能读。\n\n现在修改umask，通过以下命令行设置umask为022\n> umask 022\n\n这个和运行**umask 0022**是一样的；如果你只指定三个数字，第一个数字将会被假设为0。让我们验证这个改变的发生：\n> umask\n\n再创建一个文件：\n> touch testfile2\n\n现在我们可以看下列出的文件信息，使用通配符去看所有testfile开头的文件：\n> ls -l \"testfile*\"\n![](https://upload-images.jianshu.io/upload_images/9031347-18dfb368ad5b26a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如图，testfikle2的权限就成为了***644***。\n\n下面是一些其他**umask**的命令行：\n> umask a+r\n\n设置掩码让所有用户能读新文件，其他的权限不能从默认修改。\n\n> umask a-x\n\n设置掩码让所有用户都不能执行这个新文件，其他的默认权限不能从默认中修改！\n\n> umask u=we,go=\n\n设置文件拥有者能读写但不能执行新文件，组成员其他用户不能操作此文件。\n\n> umask 777\n\n设置文件不能被所有用户操作\n\n> umask 000;\n\n让新建的文件可被所有用户读写和执行，然而这是个坏主意，最好不要这样做！\n\n## 相关命令\n**chmod**  --- 改变文件或文件夹的权限\n**csh**         ---  C chell命令解释器\n**ksh**         --- Korn . . . \n**sh**            --- Bourne shell . . .\n\n');
INSERT INTO `blog_content` VALUES (38, '> linux的思想是“一切基于文件”，它将设备等均看成是文件，并可以通过与文件操作有关的系统调用对它们进行操作。\n\n---\n###文件的四种用户：\n- root:表示管理员，也可以叫超级用户\n- owner:文件所有者\n- group：用户所在组成员\n- other: 以上三类以外的其 他用户\n\n---\n### ls -l\n- 以列表的形式打印文件的具体信息\n-rw-r--r--       1  root     root            0      3月   2 11:22    ls1\n-rwxr-xr-x     1  root     root         4627   3月   2 11:21   test5\n-rw-r--r--       1  root     root            5       3月  2 11:19  umask\n- 先看第一列信息所表示的意思：\n以第二行为例：**-rwxr-xr-x**\n\n|符号表示|含义|备注|\n|:--:|:--:|:--:|\n|-|例子第一列的第一个字符表示文件的种类，“-”表示普通文件，**p**表示管道文件，**b**表示块设备，**c**表示字符设备，**l**表示符号链接|**块设备**和**字符设备**的区别就在于前者能随机写入而字符设备必须按顺序写入，常见的块设备比如硬盘，软盘什么的，字符设备比如键盘鼠标都算，**符号链接**是一类特殊的文件， 其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用。**管道**从本质上说也算是文件，其主要功能是把一个程序的输出直接连接到另一个程序的输入|\n|rwx|表示的是文件所有者对此文件的权限|这里表示文件所有者可以对文件r（读）w（写）执行（x）操作|\n|r-x|表示的是与文件所有者同组的其他用户的权限|表示可以读和执行，但不能写|\n|r-x|除了root，owner，group的其他用户对此文件的操作权限|其他用户可以读和执行，不能写|\n\n\n> 创建链接的方式\n    ln -s source dist        # 建立软连接\n    ln source dist            # 建立硬连接\n\n> 符号链接就相当于windows系统下的快捷方式，硬链接和符号链接（即软链接）的区别就是符号链接能链接两个不同文件系统的文件而硬链接不能，而且目录没有硬链接但可以有软链接！\n\n> 具体区别看[这个](https://www.jianshu.com/p/dde6a01c4094)\n文章大致意思就是：\n**硬链接**：可以看成一个文件名，其inode与文件的inode相同，即使是删除了原文件，因为其指向的是文件所在硬盘的位置，删除文件硬盘中数据还在，所以还能正常读写。\n**软链接**：相当于新建了一个保存源文件的绝对路径的文件，inode与源文件不同，类似于windows系统的快捷方式。当我们删除原文件，这个软链接找不到原文件，就打不开了，但是如果我们重新写入这个软链接文件，就继续有内容了！\n\n> Linux目录也有r/w/x权限：\nr：可以列出目录中的内容（对目录列表）\nw：可以在目录中新建/删除/重命名/剪切移动  文件和子目录\nx：可以进入该目录，使该目录成为工作目录（即当前目录），比如用cd命令\n在开放目录给他人浏览时，至少要给他r和x权限，但w权限不能随便给\n\n\n- **ls  -l  /tmp**的运行效果:\n![](https://upload-images.jianshu.io/upload_images/9031347-695ceffe103175f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###掩码umask\n是什么：每个进程都有自己的掩码umask，umask是一个系统变量，它的作用是为文件的访问权限设置一个掩码，当用open或creat系统调用创建文件时，mode参数将会与掩码比较。\n actual_permission=(requested_permission&(~umask))\n用标准工具创建文件时，文件缺省权限是0666\n用umask命令可以对umask掩码进行设置。\n对root而言，umask缺省值是0022（普通用户是0002）\n\n![](https://upload-images.jianshu.io/upload_images/9031347-449f6e74bca0ca5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n具体可以看我的另一个[翻译的博客](https://www.jianshu.com/p/8018b53f64ec),我感觉原文写的很详细！\n\n# 文件和索引节点\n\n索引节点inode，即是“index node”的缩写，在linux系统中一个inode节点可以包含以下内容：\n* 文件的字节数\n* 文件拥有者的User ID\n* 文件的Group ID\n* 文件的读、写、执行权限\n* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。\n* 链接数，即有多少文件名指向这个inode\n* 文件数据block的位置\n\n我们可以通过\n> stat testfile\n\n命令查看文件的inode包含的信息\n![](https://upload-images.jianshu.io/upload_images/9031347-7bceeb6af6d20cd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> ls -il\n\n查看目录下所有文件的的inode号码：\n![](https://upload-images.jianshu.io/upload_images/9031347-d4ee8b8a75087518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> ln aaa   bbb                 \n\nln命令增加硬链接：ln old  new\n\n![](https://upload-images.jianshu.io/upload_images/9031347-a1d11f85d86f4ff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看到硬链接和源文件的inode号码是相同的！\n\n>rm new\n\n删除硬链接 \n\n> 硬链接文件有两个限制  \n1、不允许给目录创建硬链接；  \n2、只有在同一文件系统中的文件之间才能创建链接。\n\n> find -inum num   查找某节点号是num的文件\n\n比如：\n![](https://upload-images.jianshu.io/upload_images/9031347-bd5350fd6d2bf13c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n具体：[阮一峰的网络日志了解inode](http://www.ruanyifeng.com/blog/2011/12/inode.html)\n\n\n# 文件和目录的特殊权限（suid/sgid/sticky bit）\n\n查看linux下的passwd文件\n![](https://upload-images.jianshu.io/upload_images/9031347-4d56038a62d53541.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n发现这个文件中有一个**s**权限，这是什么呢？\n');
INSERT INTO `blog_content` VALUES (39, 'jdk安装：\n下载jdk\n![](https://upload-images.jianshu.io/upload_images/9031347-ddaeb904d0e17b39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n解压文件\n> tar -zxvf  jdk-8u181-x64.tar.gz\n\n更改解压后的文件名为jdk1.8:\n> mv jdk-8u181-x64.tar.gz  jdk1.8\n\n配置环境变量（有[三种方式](https://blog.csdn.net/qq_21765903/article/details/52802088)这里只写一种）：\n编辑文件```/etc/profile```在尾行添加：\n```\nexport  JAVA_HOME=/home/hesw/jdk1.8\nexport JRE_HOME=/home/hesw/jdk1.8/jre\nexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib\nexport PATH=$JAVA_HOME/bin:$PATH\n```\n> 附上vi编辑时的退出操作：\n按ESC键跳到命令模式，然后：\n:w 保存文件但不退出vi.\n:w file 将修改另外保存到file中，不退出vi.\n:w! 强制保存，不推出vi.\n:wq 保存文件并退出vi.\n:wq! 强制保存文件，并退出vi.\nq: 不保存文件，退出vi.\n:q! 不保存文件，强制退出vi.\n:e! 放弃所有修改，从上次保存文件开始再编辑\n\n然后```source /etc/profile``` 运行新配置！\n```java -version```测试是否安装成功！\n\n');
INSERT INTO `blog_content` VALUES (40, '### 下载tomcat8\n![](https://upload-images.jianshu.io/upload_images/9031347-42a0091a5c2fef0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 解压tomcat\n> tar -zxvf apach-tomcat-8.5.34.tar.gz\n\n重命名及移动到目标文件夹\n> mv apach-tomcat-8.5.34  tomcat8.5.34\nmv tomcat8.5.34  /home/hesw/tomcat/tomcat1\n\n### tomcat的环境变量的配置和内存设置\n进入tomcat8.5.34中bin目录\n> vi catalina.sh\n\n在文件末尾加入：\n```\nJAVA_OPTS=\"-Xms512m -Xmx1024m -Xss1024K XX:PermSize=512m -XX:MaxPermSize=1024m\"\nexport TOMCAT_HOME=/home/hesw/tomcat/tomcat1/tomcat8.5.34\nexport CATALINA_HOME=/home/hesw/tomcat/tomcat1/tomcat8.5.34\nexport JRE_HOME=/home/hesw/jdk1.8/jre\nexport JAVA_HOME=/home/hesw/java/jdk1.8\n```\n然后```:wq```保存退出，返回bin目录：\n> ./startup.sh\n\n运行tomcat：\n![显示即成功](https://upload-images.jianshu.io/upload_images/9031347-46faaecceac2b346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 运行\n在浏览器中输入\n> http://你的域名:8080/\n\n![tomcat配置成功](https://upload-images.jianshu.io/upload_images/9031347-9833eb258df852d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###不能打开\n如果输入网址还是打不开可能就是Linux下的防火墙问题！需要打开防火墙的8080端口。\n\n> vi /etc/sysconfig/iptables\n\n切换编辑模式加入：\n> -A INPUT -m statr --state NEW -m tcp --dport 8080 -j ACCEPT\n\n重启防火墙：\n> service iptables restart \n\n### 修改端口为http默认端口80\n将端口改成80，既可以不用输入8080访问！\n> vi /tomcat8.5.34/conf\n\n将其中的<connector标签的port属性改成80即可！\n![](https://upload-images.jianshu.io/upload_images/9031347-bacecb84a30845ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后回到bin目录重启即可！\n\n![](https://upload-images.jianshu.io/upload_images/9031347-1768a33d730265ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n');
INSERT INTO `blog_content` VALUES (41, '> 参考网站https://blog.csdn.net/mico_cmm/article/details/59108651\n\n>  在centos中，mysql被mariaDB代替了，所以我们可以直接使用yum下载安装mariabd\n\n#### 安装mariaDB\n> yum -y install mariadb*\n\n#### 开启mariaDB服务\n> systemctl start mariadb.service\n\n#### 设置开机自启服务\n> systemctl enable mariadb.service\n\n#### 设置mysql的root的密码及完成相关配置\n> mysql_secure_installation\n\n#### 测试是否安装成功\n> mysql -u root -p\n\n#### 输入刚才设置的密码\n![成功](https://upload-images.jianshu.io/upload_images/9031347-e4cc1ee26d355fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n[mysql权限管理](https://www.cnblogs.com/Richardzhu/p/3318595.html)\n[mysql权限设置](https://www.cnblogs.com/candle806/p/4048651.html)\n[CentOS 修改 Yum 安装的 MySQL 的默认路径](https://blog.csdn.net/yszll/article/details/53318687)\n');
INSERT INTO `blog_content` VALUES (42, '经常用```netstat -tunlp```查看端口占用情况，tunlp是什么意思呢？\nt：表示查看tcp\nu：表示查看udp\np：表示占用端口的进程\n![用netstat -tulp命令查看](https://upload-images.jianshu.io/upload_images/9031347-41fe28c33d08ba3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 端口可以被理解成服务所对应的地址！！！上图可以看到，telnet的地址被xinetd监听，所以可以知道telnet是一个非独立守护进程！\n\nn：表示端口以数字形式表示，没有n直接显示服务名。\n![没有n的情况](https://upload-images.jianshu.io/upload_images/9031347-07a3daa55254f0e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nl：表示显示所监听的端口\n');
INSERT INTO `blog_content` VALUES (43, '在做实验时，老师叫我们在FC12系统中下载telnet，安装telnet之前就得安装xinetd，但是当使用以下命令安装xinetd时，却出现以下错误：\n```\nroot@localhost hsw]# rpm -ivh xinetd-2.3.14-20.el5_10.i386.rpm \nwarning: xinetd-2.3.14-20.el5_10.i386.rpm: Header V3 DSA signature: NOKEY, key ID e8562897\nerror: Failed dependencies:\n	libc.so.6 is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libc.so.6(GLIBC_2.0) is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libc.so.6(GLIBC_2.1) is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libc.so.6(GLIBC_2.1.3) is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libc.so.6(GLIBC_2.2) is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libc.so.6(GLIBC_2.3) is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libc.so.6(GLIBC_2.3.4) is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libc.so.6(GLIBC_2.4) is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libcrypt.so.1 is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libm.so.6 is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libnsl.so.1 is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libselinux.so.1 is needed by xinetd-2:2.3.14-20.el5_10.i386\n	libwrap.so.0 is needed by xinetd-2:2.3.14-20.el5_10.i386\n```\n\n询问同学，只要加上一个--nodeps选项即可！\n\n![](https://upload-images.jianshu.io/upload_images/9031347-b2774c2e3e95fa53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后以相同命令安装telnet也行了！\n\n![成功](https://upload-images.jianshu.io/upload_images/9031347-222fb8f85a1c69eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n');
INSERT INTO `blog_content` VALUES (46, '# 用户账户的维护命令\n##### 1. 增加用户帐号 useradd\n- 在命令行下使用 useradd 命令： useradd  用户名 \n- 该命令做了下面几件事：\n  1. 在 /etc/passwd 文件中增添了一行记录；\n  2. 在 /home 目录下创建新用户的主目录，并将 /etc/skel 目录中的文件拷贝到该目录中去；\n  3. 但是使用了该命令后，新建的用户暂时还无法登录，因为还没有为该用户设置口令，需要再用 passwd 命令为其设置口令后，才能登录。\n  4. 用户的 UID 和 GID 是 useradd 自动选取的，它是将 /etc/passwd 文件中的 UID 加 1，将 etc/group 文件中的 GID 加 1。\n##### 2. 删除用户 userdel\n- userdel命令用于删除指定的用户账号。其使用的语法格式为：\n	       ```userdel [-r][用户账号]```\n- 需要补充说明的是userdel命令可删除用户账号与相关的文件。若不加参数，则仅删除用户账号，而不删除相关文件。\n- 下面举例说明该命令的使用方法：\n  1. userdel lyd      //删除lyd账号\n  2. userdel –r lyd   //删除用户的同时删除其工作主目录\n#####3. 用户切换 su\n- root用户登录：\n 命令提示符为：＃\n 主目录为： /root\n- 普通用户登录：\n命令提示符为： $\n主目录为：/home/jiangjian    //假定用户名为jiangjian\n- 在以普通用户身份登录后，\n使用命令：su -，再输入root用户密码就可以暂时切换到root用户身份。\n使用命令： su - zhangsan，就可以切换到zhangsan用户身份\n- 或者可以用su root或者su zhangsan切换\n \n![su root和su -效果上的区别](https://upload-images.jianshu.io/upload_images/9031347-55990e2b11510573.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 目录操作常用命令\n#### 4. 文件显示命令 ls\n- 显示指定工作目录中所包含的内容的指令是ls，要说明的是ls命令列出文件的名字，而不是文件的内容。该命令的使用方式如下：\n```ls [选项] [文件目录列表]```\n- ls命令中的常用选项如下：\n\n| 条件 | 功能 |\n| :--------: | :----: |\n|-a|显示所有文件及目录 (ls规定将文件名或目录名中开头为“.”的视为隐藏文件，不会列出) |\n|-l|除文件名外，也将文件状态、权限、拥有者、文件大小	等信息详细列出 |\n|-A|同 -a ，但不列出 \".\" (目前目录) 及 \"..\" (父目录) |\n|-t|根据文件建立时间的先后次序列出 |\n|-c|按列输出，纵向排序|\n|-x|按列输出，横向排序|\n|-X|按扩展名排序显示|\n|-R|递归显示下层子目录|\n|--help|显示帮助信息|\n|--version|显示版本信息|\n##### 5. 进入目录 cd\n- 功能：切换目录\n- 用法：\n```\n cd /some/dir/\n cd ~     //~表示用户主目录，也可以直接写成cd\n cd ..     //..表示当前目录的父目录 \n cd ../..   //../..表示当前目录的父目录的父目录\n cd -   //返回最近所在的目录\n```\n\n##### 6. 显示文本文件内容 cat\n- 显示文本文件内容的命令是cat命令，用来将文件的内容显示到终端上，其命令语法如下：\n          ```cat  [选项]  文件列表```\n- 用法：\n  ``` $ cat file```\n- 分屏显示：\n cat test.txt|more 或 more test.txt\n 然后按空格键（按enter键是一行一行往下翻，按b键上翻）\n less类似于more，还可以上下翻页\n##### 7. 显示文本文件内容 head/tail\n- 用法：\n```\nhead/head -10/head -n 10\ntail/tail -7/tail -n 7\n```\n##### 8. 显示当前所在目录 pwd\n- 用法：pwd\n#####9. 生成一个新文件或是更改文件的时间 touch\n- 用法：\n```touch xxx```\n\n##### 10. 删除文件或目录 rm\n-用法：\n ```rm /some/dir/file1 \n rm -i /some/dir/file1   交互式删除，也就是有警告。\n rm -f /some/dir/file1    -f表示不给出提示\n rm -r /some/dir/         -r删除目录及目录下的子目录和文件\n rm -rf /some/dir/       上两种功能结合\n```\n\n\n##### 11. 复制文件或目录 cp\n- Linux下的cp命令用于复制文件或目录，该命令是最重要的文件操作命令，其命令格式如下：\n	cp　[选项]　 源文件　目标文件\n 	cp　[选项]　 源文件组 　目标目录\n- 功能：复制文件或目录\n- 用法：\n ```cp file1 file2\n cp /some/dir/file1 /someother/dir/\n cp /some/dir/file1 file2  /someother/dir/\n cp /some/dir/file1 /someother/dir/file2\n cp -r /some/dir/ /other/dir/     //-r 表示连目录和目录中的内容一起复制\n cp -p /some/dir/ /other/dir/     //-p 表示保留源文件或目录的属性\n```\n\n#####12. 移动或重命名文件或目录 mv\n- 功能：移动文件或目录、文件或目录改名\n- 用法：\n```\n mv /some/dir/file1 /someother/dir/\n mv /some/dir/file1 /someother/dir/file2\n mv /some/dir/files /someother/dir/\n mv -r /some/dir/ /someother/dir/\n```\n##### 13. mkdir\n-功能：创建目录\n-用法：\n```\n mkdir /some/path/dir/\nmkdir -p dir1/dir2      //-p表示可以同时建立dir1和dir2  \n```\n##### 14. rmdir\n- 功能：删除空目录\n- 用法：\n rmdir somedir/\n#####15. whereis\n- 在命令whereis后面加上文件/目录,即可获得该文件或目录及有关文档的完整路径。\n- 用法：\n whereis mount; \n  whereis man \n- 在which后面加上命令名，可以找到与之相关的位于系统路径中的命令、文档的完整路径。\n- 用法：\n$ which mount\n##### 16. wc命令\n- 作用：计算目标文件的字节数、字数、行数，并将其打印出来！\n- 用法：wc [选项] filename\n- 选项：\n\n|选项名|功能|\n|:---:|:---:|\n|-c|计算文件字节数|\n|-m|计算文件字符数，不能与-c一起用|\n|-w|统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串|\n|-L |打印最长行的长度。|\n\n##### 17. usermod命令行\n**usermod命令**用于修改用户的基本信息。usermod命令不允许你改变正在线上的使用者帐号名称。当usermod命令用来改变user [id](http://man.linuxde.net/id \"id命令\")，必须确认这名user没在电脑上执行任何程序。你需手动更改使用者的[crontab](http://man.linuxde.net/crontab \"crontab命令\")档。也需手动更改使用者的[at](http://man.linuxde.net/at \"at命令\")工作档。采用NIS server须在server上更动相关的NIS设定。\n\n**语法**\n> usermod [选项] <参数>\n\n**选项**\n> -c<备注>：修改用户帐号的备注文字；\n-d<登入目录>：修改用户登入时的目录；\n-e<有效期限>：修改帐号的有效期限；\n-f<缓冲天数>：修改在密码过期后多少天即关闭该帐号；\n-g<群组>：修改用户所属的群组；\n-G<群组>；修改用户所属的附加群组；\n-l<帐号名称>：修改用户帐号名称；\n-L：锁定用户密码，使密码无效；\n-s<shell>：修改用户登入后所使用的shell；\n-u<uid>：修改用户ID；\n-U:解除密码锁定。\n\n**参数**\n用户名\n\n**用例**\n将newuser2添加到组staff中：\n> usermod -G staff newuser2\n\n修改newuser的用户名为newuser1：\n> usermod -l newuser1 newuser\n\n锁定账号newuser1：\n>usermod -L newuser1\n\n解除对newuser1的锁定：\n>usermod -U newuser1\n\n##### 18. 其他（后面继续添加）（用到时再了解）\n- echo 功能：在屏幕上打印出指定的字符串。\n- grep：\nLinux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。（后面遇到详细了解）\n');
INSERT INTO `blog_content` VALUES (48, '### 错误描述：\n> 今天写linux的试验报告四，有一道题要修改系统应道程序的配置文件grub.conf（有些系统是menu.lst）让开机菜单的等待时间为10秒并在标题的后面加上自己姓名的拼音！可是在我找到这个配置文件的时候修改完，```w!```命令强制保存，提示的是只读文件打开但不能修改，然后搜索很多人说应该用```w !sudo %```命令，可是还是没用，然后就直接修改文件的只读文件为可写文件```chmod a+w filename```,提示该文件为系统只读文件，所以不能修改权限，我就很疑惑了。老师说```w！```肯定能强制保存的。\n\n### 错误解决：\n> 然后询问老师，老师说可能是最新版系统的vi单纯的只是vi，而不是vim的别名。\n于是``` yum install vim``` 下载vim，然后修改配置文件\n若要每次登入就自动生效别名，则把别名加在/etc/profile或~/.bashrc中。然后# source ~/.bashrc\n若要让每一位用户都生效别名，则把别名加在/etc/bashrc最后面，然后# source /etc/bashrc\n参考：https://blog.csdn.net/doiido/article/details/43762791\n');
INSERT INTO `blog_content` VALUES (49, '> 由于本人实在是懒，内容都写下来有点浪费时间，不写又怕没几天就忘记，所以我找到了一位勤劳美丽的小仙女，向她要了这份笔记，在这里感谢哟~\n\n![](https://upload-images.jianshu.io/upload_images/9031347-deb1b056dba6979f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 重要的目录描述：\n**Bin** 全程binary,含义是二进制。文件都是可运行的。\n**Dev**:该目录中主要存放的是外接设备，例如U盘，移动硬盘，光盘。在其中的外接设备是不能直接被使用的，需要挂载（类似于Windows下的分配盘符）。\n**Etc**：该目录主要是存储一些配置文件。\n**Home**:类似于User,除了Root意外的用户目录。\n**Proc**:全程process（进程），存储Linux运行的进程。\n**Root**：该目录是Root的家目录；\n**Sbin**:全程 suber binary,该目录也是存放一些可以执行的二进制文件，但是必须得有super权限的用户才能执行\n**Tmp**:存放临时文件；（类似于Windows的Temp）\n**Usr**：存放的用户自己安装的软件；类似于program files;\n**Var**:存放是程序/系统的日志文件；\n**Mnt**:当外接设备如果需要挂载的时候就需要挂载到Mnt目录下；\n# 指令和选项：\n**Linux下指令通用的格式：**\n```~$  指令主题 [选项] [操作对象]```\n> 一个指令可以包含多个选项和多个操作对象。\n列如：需要让张三同学去留下小卖部去买一瓶肥宅快乐水和清风餐巾纸 \n               买东西是指令的主体 ，买的水和餐巾纸是操作对象，肥宅快乐水和清风是选项；\n# 基础命令 \n\n### ls (list) 列出 \n**用法1：ls**\n含义：列出当前目录所有文件\n\n**用法2 ：ls 路径**\n含义：列出给出路径下面的文件\n关于路径：路径可以分为两种：相对路径和绝对路径\n相对路径：相对首先得有一个参照物（一般就是当前的工作路径）；\n相对路劲的写法：在相对路径中通常会用到两个符号\n“./”   [表示当前目录下]\n“../”  [表示上一级目录下]\n	绝对路径：绝对路径不需要参照物 直接从根“/”开始寻找对应路径\n\n**用法3：ls 选项 路径**\n含义：在列出路径下的文件/文件夹的名称，并以指定的格式进行显示。\n常见的语法 ls -l 路径\n ls -la 路径\n参数（选项）： -l 表示 list,表示以详细列表的形式进行展示；\n列表中的第一列字符表示文档类型；\n“-”表示该行文档类型问文件：“d”表示文件夹\n -a 表示显示所有的文件和文件夹（包含了隐藏文件和文件夹）\n隐藏文件一般是以“.”开头\n\n**用法4**：ls -l[a]h 路径\n        含义：列出指定路径下的所有文件和文件夹的名称以列表的形式并且在显示文档大小的时候以可读性较高的形式来进行显示；\n		\n--------------------\n###pwd\n\n用法：pwd (print working directory)打印当前工作目录\n\n----------------------\n###cd 命令 （change directory 改变目录）切换当前的工作目录\n\n语法:cd 路径\n补充： Linux中有一个“~”表示当前用户的家目录\n-----------------------\n### mkdir 命令\n\n用户：mkdir (make directory 创建目录)\n语法: mkdir [路径] 文件名\n案例：在当前路径下创建目录“yunwei” mkdir xx\n注意：ls 列出结果颜色说明：其中蓝色的名称表示文件夹，黑色的表示文件，绿色的表示其权限未不是只读拥有所有权限。\n\n案例：指定的目录下面创建  mkdir /root/xx\n \n用法2：mkdir -p[文件路径] 多层创建\n\n案例:mkdir -p /root/yunwei/a/b/c/d\n查看 ls /root/yunwei/a/b/c/d\n\n语法3: mkdir 路径1 路径2 路径...\n\n----------------------\n### touch （创建指令）\n\n指令：touch 创建文件 \n语法: touch 路径\n案例: 用touch在当前目录下创建一个文件名，命名为Linux.txt; touch Linux.txt \n 	  用touch在执行目录Home下创建文件Linux123.txt; touch /home/Linux123\n注意：文件不能包含多层 所以没有-p 但是可以创建多个文件\n\n--------------------\n### cp （copy 复制）\n作用：复制文件/文件夹到指定的位置\n语法：cp 被复制的文档路径 文档被复制到的路径\n案例：使用cp来复制文件 \n注意：可以在复制过程中改名，cp在命令文件夹复制的时候添加 -r（递归复制）\n	\n---------------\n\n###mv 指令 （move 移动 剪切）\n作用：移动文档位置\n语法：mv 需要移动的文档路径 需要保存的位置路径\n主语：原始文件不在原位置\n案例：mv移动命令一个文件\n	    mv 文件 路径\n            mv -r移动命令一个文件夹\n\n作用2：重命名\n语法: mv 需要移动的文档路径 需要保存的位置路径\n------------\n### rm 命令（移除 remove）\n作用：移除删除一个文档\n语法 rm 选项 移除的路径\n选项：\n	-f 再删除时不想频繁确认可以在指令中添加 表示 force(强制)\n	-r 删除文件夹 递归删除 一般 -rf联合使用\n案例：不用选项删除文件 rm /路径 ？？？？没提示/会提示是否删除\n	删除一个文件夹 rm -r /文件夹路径	\n	删除文件夹和文件 rm -rf /路径 路径\n	删除一个目录下有公共特性的文件 例如Linux开头 rm -f /关键词 *（通配符）\n------------\n### vim 命令 \n指令：vim（vim是一款文本编辑器）\n语法：vim 文件的路径\n作用：打开一个文件(可以存在也可以不存在)\n在没有按下其他命令的时候 :q（不保存退出） :wq(保存退出) :q！(强制退出)\n\n-----------\n### 输出重定向\n指令：一般的命令都会显示在终端中，有时候讲一些命令的执行结果保存到文件中进行后续的分析统计这个时候需要输出重定向;\n> 表示覆盖输出\n>> 追加输出\n注意：文件不存在自动新建\n案列：使用覆盖重定向，保存ls -la的结果  ls -la > 文件\n\n-----------\n### cat 指令\n**作用1**：cat 直接打开一个文件的功能 不同于vim\n语法 cat 文件的路径\n\n**作用2**：cat还可以对文件进行合并\n语法：cat 待合并的路径1 待合并的路径2 合并路径n > 新文件路径\n案列 cat a b > c 配合输出重定向\n\n\n\n# 进阶命令\n\n###1. df指令\n作用:查看磁盘的空间\n语法: # df \n# df -h 可读性较高(显示储存单位)\n\n---------------------------------------\n\n###2. free指令\n 作用:查看内存使用情况\n语法: # free\n # free -m 表示以MB为单位\n\n----------------------------------------\n\n###3. head指令\n作用:查看一个文件的前n行,如果不指定n,则默认显示前10行\n语法: #head -n 文件路径	\n\n----------------------------------------\n\n###4.  tail指令\n作用1:查看一个文件的末n行,如果不指定n,则默认显示后10行\n语法: #tail -n 文件路径\n作用2:可以通过tail指令来查看一个文件的动态变化(文件不能为手动输入)\n语法: #tail -f 文件路径\n该命令一般用于查看系统的日志比较多\n\n----------------------------------------\n\n###5. less指令\n作用:查看文件,以较少的内容进行输出,按下辅助功能键(shift+: 后 数字+回车 , 空格+上下 )查看更多\n语法: #less 文件路径\n退出按q\n\n----------------------------------------\n\n###6. wc指令\n作用:统计文件内容信息(包含行数,单词数,字节数)\n语法: #wc -lwc 需要统计的文件路径\n     -l :表示lines ,行数\n     -w :表示word  ,单词数  依照空格来判断单词数量\n     -c :表示bytes ,字节数\n\n----------------------------------------\n\n###7. date指令(重点)***\n作用:表示操作时间日期(读取,设置),shell\n语法1:# date 查看当前时间     				输出的形式:2018年9月19日 星期三 19:30:50         CST表示当地时间\n语法2:# date +%F (等价于 #date +\"%Y-%m-%d\")             输出的形式:2018-09-19\n语法3: %date \"+%F %T\"					输出的形式:2018-9-19 19:30:40  (引号表示让年月日时分秒成为一个整体)\n等价于 # date \"+%Y-%m-%d %H:%M:%S\"\n\n语法4:获取之前获取之后的某个时间(备份)\n# date -d \"-1 day\" \"+%Y-%m-%d %H:%M:%S\"   获取一天前的时间\n# date -d \"+1 day\" \"+%Y-%m-%d %H:%M:%S\"   获取一天后的时间\n时间单位:day(天),mouth(月),year(年)\n%F:表示完整的年月日\n%T:表示完整的时分秒\n%Y:表示四位年份\n%m:表示两位月份(带前导0)\n%d:表示日期(带前导0)\n%H:表示小时(带前导0)\n%M:表示分钟(带前导0)\n%S:表示秒数((带前导0)\n\n----------------------------------------\n\n###8. cal指令\n作用:操作日历的\n语法1:# cal 等价于 # cal -1  直接输出当前月份的日历\n语法2:# cal -3 		     表示前一个月+当月+下个月的日历\n语法3:# cal -y 年份 表示输出某一年月份的日历\n\n----------------------------------------\n\n###9. clear/ctrl + L指令\n作用:清除终端中已经存在的命令和结果(信息)\n语法: # clear  或者 ctrl + L\n\n----------------------------------------\n\n###10. 管道(重要)***\n管道符: | \n作用:管道一般可以用于\"过滤\",\"特殊\",\"扩展处理\" .\n\n语法:管道不能单独使用,必须需要配合前面所讲的一些指令来一起使用,起作用主要是辅助作用\n\n①过滤案例(100%使用):需要通过管道查询出根目录下包含\"y\"字母的文档名称\n#ls /|grep y\n\n针对上面这个命令说明:\n1.以管道作为分界线,前面的命令有个输出 后面需要先输入在过滤再输出\n通俗的讲就是管道前面的输出就是后面指令的输入\n2.grep指令: 主要用于过滤 \n\n②特殊用法案例:通过管道的操作方法来实现less的等价效果(了解)\n之前通过less查看一个文件,可以# less 路径\n现在可以通过管道还可以这么: # cat 路径 | less\n\n③扩展处理:请使用学过的命令,来统计某个目录下的文档的总个数\n# ls / | wc -l\n# ls / | wc -w    \n\n----------------------------------------\n\n#高级指令\n\n### 1. hostname指令\n作用:操作服务器的主机名(***读取,设置)\n语法1: # hostname      含义:表示输出完整的主机名\n语法2: # hostname -f   含义:表示输出当前主机名的FQDM(全限定域名)\n\n-----------------------------------\n\n2. id指令\n作用:查看一个用户的基本信息(包含用户id,用户组id,附加组id...),该指令如果不指定用户则默认当前用户\n语法1: # id        默认显示当前执行该命令的用户\n语法2: #id 用户名  显示指定用户的基本信息\n> 验证上述信息是否正确?\n验证用户信息,通过文件/etc/passwd\n验证用户组信息:通过文件/etc/group\n\n-----------------------------------\n\n3.whoami指令\n作用:\"我是谁?\" 显示当前登录的用户名,一般用于shell脚本,\n用于获取当前操作的用户名方便记录日志\n语法: # whoami	\n\n-----------------------------------\n\n4. ps -ef指令(重点***)\n指令:ps     \n作用:主要是查看服务器的进程信息\n选项含义:\n	-e:等价于\"-A\" 表示列出全部的进程\n	-f:显示全部的列(显示全字段)\n列的含义:\nUID:该进程执行的用户id;\n***PID:进程id;\n***PPID:该进程的父级进程id;如果一个程序的父级进程找不到,该程序的进程称之为僵尸进程\n***C: cpu的占用率,其形式是百分数\nSTIME:进行的启动时间\nTTY:终端设备,发起该进程的设备识别,如果显示\"?\"则表示该进程不是由终端发起 ;\nTIME:进程的执行时间; \nCMD:该进程的名称或者对应的路径 ;\n\n案例(100%使用的命令)在ps的结果中过滤出想要查看的进程状态\n# ps -ef | grep gnome-panel         # 本身指令这条指令也算进程\n\n-----------------------------------\n\n5.top指令 (重点***)\n作用:查看服务器的进程占的资源	\n语法:\n	进入命令: #top   (动态显示)\n	退出命令: 按q\n表头含义:\nPID:进程id;\nUSER:该进程对应的用户;\nPR(权重):优先级;\nNI(nice):用户进程空间内改变过优先级的进程占用CPU百分比 (基本不会用)\nVIRT:虚拟内存;\nRES:常驻内存;\nSHR:共享内存;\n	计算一个进程实际使用的内存 = 常驻内存(RES) - 共享内存(SHR)\n*** S:表示进行的状态(sleeping,其中S表示睡眠,R表示进行) ;\n*** %CPU:表示CPU的占用百分比\n*** %MEM:表示内存的占用百分比\nTIME+ :执行的时间; \n*** COMMAND:进程的名称或者路径 ;\n\n\n例如chrome进行:\n	虚拟内存:申请500兆 实际使用了320MB 此时虚拟内存就是500兆	\n	常驻内存:申请500兆 实际使用了320MB 此时常驻内存就是320兆\n	共享内存:申请500兆 实际使用了320MB,但是其中还包含对其他进程的调用开销则需要扣除\n\n在运行top的时候,可以按下方便的快捷键:\n	M: 表示将结果按照内存(MEM)从高到低进行降序排列;\n	P:表示将结果按照CPU使用率从高到低进行降序排列;\n	1:当服务器拥有多个CPU核心的时候可以使用\"1\"快捷键来切换是否展示显示各个CPU核心的详细信息\n\n-----------------------------------\n\n6.du -sh指令\n	作用:查看目录的真实大小\n选项含义:\n	-s:summaries ,只显示汇总的大小\n	-h:表示以较高可读性的形式进行显示\n案例:统计\"/root/a\"的实际大小 \n	# du -sh /root/a\n\n-----------------------------------\n\n7.find指令\n	作用:用于查找文件(其参数有55个之多)\n语法: # find 路径范围 选项 选项的值\n选项:\n	-name:按照文档名称进行搜索(支持模糊搜索)\n	-type:按照文档的类型进行搜索\n		文档类型:\"-\"表示文件(在使用find的时候需要用f来替换),\"d\"表示文件夹\n\n案例:使用find来搜索httpd.conf\n	# find / -name httpd.conf\n\n案例:搜索etx目录下的所有的conf后缀文件\n# find /etx -name *.conf\n\n案例:使用find来搜索/etc/sane.d/目录下所有的文件\n# find /etx/sane.d -type f\n\n案例:使用find来搜索/etc/目录下所有的文件夹\n# find /etc/ -type d\n\n-----------------------------------\n\n8.service指令(重点***)\n	作用:用于控制一些软件的服务启动/停止/重启\n语法: # service 服务名 start/stop/restart\n\n例如:需要启动本机安装的Apache(网站服务器软件),其服务名叫httpd\n# service httpd start\n\n通过ps命令来检查httpd是否启动\n# ps -ef | grep httpd\n\n-----------------------------------\n\n9.kill指令(***重点)\n	作用: 表示杀死进程(当遇到僵尸进程或者处于某些原因需要关闭进程的时候)\n语法1: # kill 进程id\n语法2: killall 进程名称\n	\n-----------------------------------\n\n10.ifconfig指令(***重点)\n语法: # ifconfig(获取网卡信息)\n\n-----------------------------------\n\n11.reboot指令\n	作用:重新启动计算机\n语法1:# reboot     重启\n语法2:# reboot -w  模拟重启,但是不重启 (只写关机与开机的日志信息)\n\n-----------------------------------\n12.shutdowm指令\n	作用:关机 (慎用)\n语法1: # shutdown -h now (立即关机) 或者 # shutdowm -h 9:15 \"提示信息\"(9.15关机)\n案例:设置Linux系统关机时间自9.15\n想取消定时关机的话\n①针对centos7.0x之前: ctrl+c \n②针对centos7.0x(包含)之后: # shutdowm -c\n\n除了shutdown关机以外,还有以下几个关机命令:\n# init 0\n# halt\n# poweroff\n\n\n-----------------------------------\n\n13.uptime指令\n	作用:输出计算机的持续在线时间(计算机从卡机到现在运行的时间)\n语法: # uptime\n\n-----------------------------------\n\n14.uname指令\n	作用:获取计算机系统相关信息\n语法1: # uname 		获取操作系统的类型\n语法2: # uname -a  	表示获取系统的全部信息(类型,全部主机名,内核版本,发布时间,开源计划)\n\n-----------------------------------\n\n15.netstat -tnlp指令\n	作用:查看网络连接状态\n语法: # netstat -tnlp	\n选项说明:\n	-t:表示只列出tcp协议的连接;\n	-n:表示将地址从字母组合转化成ip地址,将协议转化成端口号来显示;\n	-l:表示过滤\"state(状态)\"列出其值为LINTEM(监听)的连接;\n	-p:表示显示发起连接的进程pid和进程名称;\n	\n-----------------------------------\n\n16.man指令\n作用:manual,手册\n语法:# man 命令   (退出按下q键)\n\n案例:通过man命令查询cp指令的用法(全是英文)\n# man cp\n\n-----------------------------------\n-----------------------------------\n-----------------------------------\n-----------------------------------\n	\n\n	\n');
INSERT INTO `blog_content` VALUES (50, '> 感觉写的很好的两篇文章:[All You Need To Know About Processes in Linux ](https://www.tecmint.com/linux-process-management/)和[Processes in Linux/Unix](https://www.geeksforgeeks.org/processes-in-linuxunix/),本来想像文件权限那篇文章那样全文翻译过来，这样既能锻炼英语，又能加深linux相关知识。可是作业要紧，做完作业，找时间吧！\n\n转自[Linux查看和关闭正在执行的程序](https://my.oschina.net/u/1866459/blog/423732)\n\n#  有关进程的几种常用方法\n---\n### & 符号\n\n在执行某个命令的后面加上一个 & 符号，表示该命令放在后台执行.\n\n---\n### Jobs 命令\n\n该命令可以查看当前有多少在后台运行的命令，jobs 列出当前shell环境中已启动的任务状态，若未指定jobs id，则显示所有活动的任务状态信息。\njobs命令执行的结果，＋表示是一个当前的作业，减号表是是一个当前作业之后的一个作业，jobs -l选项可显示所有任务的PID,jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息。如：\n```\n[noc@dpi_netquery_new01 ~]$ jobs\n ```\n\n> 当前任务的概念：如果后台的任务号有2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码“[2]”的后台任务。所以可以得出一点，即当前任务是会变动的。当用户输入“fg”、“bg”,\"stop”等命令时，如果不加任何引号，则所变动的均是当前任务。\n---\n### fg 命令（foreground）\n该命令将后台运行的进程调到前台来运行。 具体用法： fg %n。\n这里的N 是jobs 看到的job number。 如：\n```\n [noc@dpi_netquery_new01 ~]$ fg\n-bash: fg: current: no such job\n```\n \n---\n### ctrl + z 组合键\n该命令将一个正在前台执行的命令放到后台，并且暂停。\n\n \n---\n### bg命令（background）\n\n该命令将一个在后台暂停运行的命令，变成继续在后台执行的命令。\n用法：bg %n。 N 是jobs命令查看到的job number。 如：\n```\n[oracle@singledb ~]$ /u02/rman_incremental_backup.sh\n[1]+  Stopped                 /u02/rman_incremental_backup.sh\n```\n--我们运行备份命令，然后按下CTRL+Z\n```\n[oracle@singledb ~]$ jobs\n[1]+  Stopped                 /u02/rman_incremental_backup.sh\n```\n--用jobs查看进程状态\n```\n[oracle@singledb ~]$ fg %1\n/u02/rman_incremental_backup.sh\n```\n--用fg将进程调到前台运行\n```\n[1]+  Stopped                 /u02/rman_incremental_backup.sh\n```\n--按下ctrl+z\n```\n[oracle@singledb ~]$ bg %1\n[1]+ /u02/rman_incremental_backup.sh &\n```\n--用bg将后台暂停的进程继续执行，这里自动加了一个& 符号\n```\n[oracle@singledb ~]$ jobs\n[1]+  Running                 /u02/rman_incremental_backup.sh &\n```\n--查看job 状态\n\n## 结束正在运行的进程\n### 结束前台进程\n这种只需要按下组合键： ctrl + c 即可。\n---\n### 结束后台运行的进程\n这种情况下也有两种方法：\n\n（1）用jobs查看进程的job number，然后用命令：kill %n 来结束。\n（2）用ps 查看进程的pid，然后用命令：kill pid 来结束。\n 这里对kill 做点说明，kill除了可以终止进程，还能给进程发送其它信号，使用kill -l 可以察看kill支持的信号。\n```\n[oracle@singledb ~]$ kill -l\n\n 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL\n\n 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE\n\n 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2\n\n13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT\n\n17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\n\n21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU\n\n25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH\n\n29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN\n\n35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4\n\n39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n\n43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12\n\n47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14\n\n51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\n\n55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6\n\n59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\n\n63) SIGRTMAX-1  64) SIGRTMAX\n```\nSIGTERM是不带参数时kill发送的信号，意思是要进程终止运行，但执行与否还得看进程是否支持。如果进程还没有终止，可以使用kill -SIGKILL pid，这是由内核来终止进程，进程不能监听这个信号。\n\n \n---\n### ps 命令\n该命令用户列出系统中正在运行的进程。 常用的参数：ps -ef\n关于这2个参数含义，参考ps 命令的帮助：\n```\n[oracle@singledb ~]$ ps --help\n\n********* simple selection *********  ********* selection by list *********\n\n-A all processes                      -C by command name\n\n-N negate selection                   -G by real group ID (supports names)\n\n-a all w/ tty except session leaders  -U by real user ID (supports names)\n\n-d all except session leaders         -g by session OR by effective group name\n\n-e all processes                      -p by process ID\n\nT  all processes on this terminal     -s processes in the sessions given\n\na  all w/ tty, including other users  -t by tty\n\ng  OBSOLETE -- DO NOT USE             -u by effective user ID (supports names)\n\nr  only running processes             U  processes for specified users\n\nx  processes w/o controlling ttys     t  by tty\n\n*********** output format **********  *********** long options ***********\n\n-o,o user-defined  -f full            --Group --User --pid --cols --ppid\n\n-j,j job control   s  signal          --group --user --sid --rows --info\n\n-O,O preloaded -o  v  virtual memory  --cumulative --format --deselect\n\n-l,l long          u  user-oriented   --sort --tty --forest --version\n\n-F   extra full    X  registers       --heading --no-heading --context\n\n                    ********* misc options *********\n\n-V,V  show version      L  list format codes  f  ASCII art forest\n\n-m,m,-L,-T,H  threads   S  children in sum    -y change -l format\n\n-M,Z  security data     c  true command name  -c scheduling class\n\n-w,w  wide output       n  numeric WCHAN,UID  -H process hierarchy\n```\n\n# 前台进程和后台进程的一点讨论\n整理这篇文章的目的就是弄清楚在实际使用中这两种进程的区别。 一般情况下，我们都是通过shell 连接到linux 服务器上，那么，假如我们在这个shell 窗口执行一个备份或者其他命令，即前台命令。 在这个时候，前台命令没有执行完，我们把这个终端关闭了，那么这个命令也就会中断。 即使我们在执行命令时加了& 符号，让进程在后台执行，终端的关闭也会造成命令的结束。\n\n解决这个问题有两种方法：\n\n（1）将命令添加到crontab里，让系统自己调用。\n\n这种方法将使命令在服务器端执行，这样即使终端关闭，也不影响命令的执行。\n\n（2）使用nohup命令（no hang up）。\n\n该命令用于保证不挂断地运行命令。如：\n```\n[oracle@singledb ~]$ nohup /u02/rman_incremental_backup.sh &\n\n[1] 4409\n\n[oracle@singledb ~]$ jobs\n\n[1]+  Running                 nohup /u02/rman_incremental_backup.sh &\n```\n> 这里要注意：运行nohup命令后，按任意键返回shell 窗口，然后输入exit退出终端，不能直接关闭窗口，直接关闭窗口的话，还是会造成命令进程和终端一起结束。\n在Unix中永久的后台进程称为守护进程（daemon）。守护进程通常从系统启动时自动开始执行，系统关闭时才停止。而nohup 启动的进程虽然也是不中断的执行，但是当进程执行完毕后就会退出。\n\n\n\n\n\n\n');
INSERT INTO `blog_content` VALUES (51, '在Linux系统中,内核为每一个新创建的文件分配一个Inode(索引结点),每个文件都有一个惟一的inode号。文件属性保存在索引结点里，在访问文件时，索引结点被复制到内存在，从而实现文件的快速访问。\n\n链接是一种在共享文件和访问它的用户的若干目录项之间建立联系的一种方法。Linux中包括两种链接：硬链接(Hard Link)和软链接(Soft Link),软链接又称为符号链接（Symbolic link）。符号连接相当于Windows下的快捷方式。\n\n# 硬链接\n\n硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。可以用:ln命令来建立硬链接。\n语法:\n```\nln [options] existingfile newfile（sexistingfile 待建立链接文件的文件，newfile是新创建的链接文件）\nln [options] existingfile-list directory\n```\n\n-f 建立时，将同档案名删除.\n-i 删除前进行询问.\n\n```\nln -s abc cde 建立abc 的软连接\nln abc cde 建立abc的硬连接，\n```\n\n**用法**:\n第一种:为”existingfile”创建硬链接,文件名为”newfile”。\n第二种:在”directory”目录中,为”existingfile-list”中包含的所有文件创建一个同名的硬链接。\n常用可选[options] –f 无论”newfile”存在与否,都创建链接。-n 如果”newfile”已存在,就不创建链接。\n\n##### 下面举一些例子:\n\n```\n[root@rekfan.com test]# ls -il\n总计 0\n1491138 -rw-r–r– 1 root root 48 07-14 14:17 file1\n1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2\n[root@rekfan.com test]# ln file2 file2hand\n[root@rekfan.com test]# ls -il\n总计 0\n1491138 -rw-r–r– 1 root root 48 07-14 14:17 file1\n1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2\n1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2hand\n[root@rekfan.com test]#\n```\n\n> 注意 : 在创建链接前,file1 显示的链接数目为1,创建链接后file1和file1hard的链接数目都变为2;file1和file1hard在inode号是一样的file1和file1hard显示的文件大小也是一样。可见进行了ln命令的操作结果：file1和file1hard是同一个文件的两个名字，它们具有同样的索引节点号和文件属性，建立文件file1的硬链接，就是为file1的文件索引节点在当前目录上建立一个新指针。你可以删除其中任何一个,如rm file2 ,每次只会删除一个指针,链接数同时减一,当链接数减为0时，内核才会把文件内容从磁盘上删除。\n\n还可以在不同目录，但同一文件系统中建立文件的硬链接。设file1、file2在目录/home/root/dir1中，下面的命令，在/home/root中建立file2的硬链接。\n\nln file2 /home/root/file2hard\n下面的程序，是将dir1目录中所有文件，在目录dir2中建立硬链接\n```\n#mkdir dir2\n#ln /home/root/dir1/* /home/root/dir2\n```\n\n如果使用了 ln –f existingfile newfile,如果newfile已经存在，则无论原来newfile是什么文件，只用当前用户对它有写权限，newfile就成为exisitngfile的硬链接文件。\n\n尽管硬链接节省空间，也是Linux系统整合文件系统的传统方式，但是存在一下不足之处：\n（1）不可以在不同文件系统的文件间建立链接\n（2）只有超级用户才可以为目录创建硬链接。\n\n****\n\n# 软链接（符号链接）\n\n软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。\n建立软链接，只要在ln后面加上选项 –s，下面举个例子\n\n```\n[root@rekfan.com test]# ls -il\n总计 0\n1491138 -rw-r–r– 1 root root 48 07-14 14:17 file1\n1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2\n1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2hand\n\n[root@rekfan.com test]# ln -s file1 file1soft\n[root@rekfan.com test]# ls -il\n总计 0\n1491138 -rw-r–r– 1 root root 48 07-14 14:17 file1\n1491140 lrwxrwxrwx 1 root root 5 07-14 14:24 file1soft -> file1\n1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2\n1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2hand\n```\n从上面链接后的结果可以看出来软链接与硬链接，区别不仅仅是在概念上，在实现上也是不同的。区别：硬链接原文件＆链接文件公用一个inode号，说明他们是同一个文件，而软链接原文件＆链接文件拥有不同的inode号，表明他们是两个不同的文件；在文件属性上软链接明确写出了是链接文件，而硬链接没有写出来，因为在本质上硬链接文件和原文件是完全平等关系；链接数目是不一样的，软链接的链接数目不会增加；文件大小是不一样的，硬链接文件显示的大小是跟原文件是一样的，这用强调，因为是等同的嘛，而这里软链接显示的大小与原文件就不同了，file1大小是48B，而file1soft是5B，这里面的5实际上就是“file1”的大小。\n\n总之，建立软链接就是建立了一个新文件。当访问链接文件时，系统就会发现他是个链接文件，它读取链接文件找到真正要访问的文件。\n在不同系统之间建立软链接、对目录建立链接，这里就不举例了，读者可以自己去尝试，我也是在不断实践中学习的。\n当然软链接也有硬链接没有的缺点，因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了～～，而硬链接就没有这个缺陷，你想怎么移就怎么移（呵呵）；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。\n\n补充一下：可以通过symlink来查看链接文件，可以用 man symlink来学习。\n\n# 删除链接\n\n有创建就有删除\n```\nrm -rf symbolic_name 注意不是rm -rf symbolic_name/\n \n\n[root@rekfan.com test]# ls -il\n总计 0\n1491138 -rw-r–r– 1 root root 0 07-14 14:17 file1\n1491140 lrwxrwxrwx 1 root root 5 07-14 14:24 file1soft -> file1\n1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2\n1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2hand\n[root@rekfan.com test]# rm -rf file1soft\n[root@rekfan.com test]# ls -il\n总计 0\n1491138 -rw-r–r– 1 root root 0 07-14 14:17 file1\n1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2\n1491139 -rw-r–r– 2 root root 0 07-14 14:17 file2hand\n[root@rekfan.com test]#\n```\n****\n# linux 软连接和硬链接的区别\n\n4点不同 ：\n（1）软连接可以 跨文件系统 ，硬连接不可以 。\n实践的方法就是用共享文件把windows下的 aa.txt文本文档连接到linux下/root目录 下 bb,cc . ln -s aa.txt\n/root/bb 连接成功 。ln aa.txt /root/bb 失败 。\n\n（2）关于 I节点的问题 。硬连接不管有多少个，都指向的是同一个I节点，会把 结点连接数增加 ，只要结点的连接数不是 0，文件就一直存在 ，不管你删除的是\n\n源文件还是 连接的文件 。只要有一个存在 ，文件就 存在 （其实也不分什么 源文件连接文件的 ，因为他们指向都是同一个 I节点）。 当你修改源文件或者连接文件\n\n任何一个的时候 ，其他的 文件都会做同步的修改 。软链接不直接使用i节点号作为文件指针,而是使用文件路径名作为指针。所以 删除连接文件 对源文件无影响，但\n\n是 删除 源文件，连接文件就会找不到要指向的文件 。软链接有自己的inode,并在磁盘上有一小片空间存放路径名.\n\n（3）软连接可以对一个不存在的文件名进行连接 。\n\n（4）软连接可以对目录进行连接。\n\n> 备注：I节点 :它是UNIX内部用于描述文件特性的数据结构.我们通常称I节点为文件索引结点(信息结点).i节点 含有关于文件的大部分的重要信 息,包括文件数据块在\n\n磁盘上的地址.每一个I节点有它自己的标志号,我们称为文件顺序号.I节点包含的信息 1.文件类型 2.文件属主关系 3.文件的访问权限 4.文件的时间截.\n');
INSERT INTO `blog_content` VALUES (54, '> [shiro中文官方文档](http://greycode.github.io/shiro/doc/reference.html)\n做项目要用到shiro，花了几天做了些简单的理解，有错误欢迎纠正。\n\n# 简单的认识\nshiro作为一个很简单的java安全框架，提供了认证、授权、加密、session管理等功能。没有使用其他安全框架，没有参照物对比的情况下，我依然觉得shiro使用真的好简单（我听说好像还有个什么spring security，但使用很复杂）。为了加深印象，写篇博客加深下印象。\n# 使用\n## 认证\n所谓认证，不过是输入用户信息，密码然后登录的过程。从使用角度看，shiro提供了很简单的接口。\n在controller获取账号密码后封装```UsernamePasswordToken```对象：\n```java\nUsernamePasswordToken token = new UsernamePassword(username, password);\n```\n获取当前对象然后登录即可：\n```java\nSubject user = SecurityUtils.getSubject();\nuser.login(token);\n```\n> 当然在登录之前也可以先判断是否已经登录，或者被记住：\n```java \nif (!user.isAuthenticated() && !user.isRemembered()) {\n     token.setRememberMe(true);\n     user.login(token);\n }\n```\n当然，作为一个安全框架，就要监视请求，所以要配置   **拦截器**   ，认证就需要获取数据库（或者在缓存中，后面讲）中的用户登录信息，获取信息的过程shiro是交给realm（翻译 “域”）做，所以我们还需要     **实现realm**。    实现了realm怎么告诉框架呢，在shiro中是realm是交给securityManager管理的，所以我们还需要  **配置securityManager**。\n\n 在Spring+SpringMVC环境下，这些操作发生在web.xml和application文件中，其他配置不多说，重点讲shiro配置：\n### 拦截器：\n在web.xml文件中配置拦截器拦截请求：\n```xml\n<filter>\n        <filter-name>shiroFilter</filter-name>\n        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>shiroFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n```\n> 这里配置的是DelegatingFilterProxy，顾名思义啊，可以看出这是个代理类，那么代理的是哪个具体对象呢？\n代理的对象我们配置在applicationContext.xml文件中：\n```xml\n<bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n        <property name=\"securityManager\" ref=\"securityManager\"/>\n        <property name=\"loginUrl\" value=\"login.html\"/>\n        <property name=\"successUrl\" value=\"home.html\"/>\n        <property name=\"unauthorizedUrl\" value=\"/error.html\"/>\n        <property name=\"filterChainDefinitions\">\n            <value>\n                /logout=anon\n                /user/root=roles[root]\n                /user/admin=roles[admin]\n                /user/**=anon\n                /login.html=anon\n                /home.html=authc\n                /**=authc\n            </value>\n        </property>\n    </bean>\n```\n> 这是我的配置，值得注意的是bean的id要和web.xml文件中一样，不然会报错```NoSuchBeanDefinitionException```。或者也可以配置初始化参数配置指定要代理bean对象id：\n```xml\n    <filter>\n        <filter-name>shiroFilter</filter-name>\n        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n        <init-param>\n            <param-name>targetBeanName</param-name>\n            <param-value>shiroFilter</param-value>\n        </init-param>\n    </filter>\n```\n 注意还有一个属性为：\n```xml\n        <init-param>\n            <param-name>targetFilterLifecycle</param-name>\n            <param-value>true</param-value>\n        </init-param>\n```\n> 该属性默认为false，当为true时表示要代理filter的init方法。\n### 然后配置realm\n首先继承AuthenticatingRealm，当然如果还要实现授权功能可以直接继承AuthorizingRealm。前者是后者的父类，在父类doGetAuthenticationInfo认证方法的基础上还增加了一个doGetAuthorizationInfo授权抽象方法。\n```java\npublic class MyRealm extends AuthenticatingRealm{\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) \n                          throws AuthenticationException {\n        System.out.println(\"do authentic\");\n        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;\n         \n        String username = token.getUsername();\n        String password = token.getPassword();\n        System.out.println(\"username : \" + username + \" password : \" + password);\n\n        //下面的root和123456模拟为从数据库中取出的用户名和密码。\n        return new SimpleAuthenticationInfo(\"root\", \"123456\", null, getName());\n    }\n}\n```\n> 返回的是从数据库中获取的数据，封装成SimpleAuthenticationInfo返回，交给shiro框架比对，参数中null相当于盐值。这里先不提加密，所以设置为null。其他参数依次为principle，credentials，然后就是getName，即此realm的名字。\n然后就是配置在IOC容器中即可：\n```xml\n<bean id=\"myRealm\" class=\"realm.MyRealm\">\n</bean>\n```\n## securityManager\nSecurityManager是shiro的核心，shiro作为一个java安全框架，而此类的字面意思又为安全管理，可见其重要性。在shiro中，用此类实现门面模式管理其他组件，所以我们的realm需要配置在这里。\n```xml\n    <bean class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\" id=\"securityManager\">\n        <property name=\"realm\" ref=\"myRealm\"/>\n    </bean>\n```\n## 其他\n然后再创建几个简单的html文件和controller即可。\n```java\n@RequestMapping(value = \"/user/toLogin\")\n    public String login(@RequestParam String username, @RequestParam String password, HttpSession httpSession) {\n        System.out.println(\"do login\");\n        Subject user = SecurityUtils.getSubject();\n        try {\n            UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n            if (!user.isAuthenticated() && !user.isRemembered()) {\n                token.setRememberMe(true);\n                user.login(token);\n            }\n        } catch (Exception e) {\n            System.out.println(\"登录发生错误！\");\n            return \"redirect:/login.html\";\n        }\n        return \"home\";\n    }\n```\n## 配置好后我们试着打断点分析认证的工作流程\nctrl+f9启动后：\n![](https://upload-images.jianshu.io/upload_images/9031347-5343324f9c826031.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n1. 输入用户名密码点击登录首先停留在**controller**方法中的第一个断点，进入shiro框架的登录接口：\n![](https://upload-images.jianshu.io/upload_images/9031347-0d022aa360de5136.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2. 进入subject子类的**DelegatingSubject**的login方法，可以看到subject的登录方法还是要交给securityManager。\n![](https://upload-images.jianshu.io/upload_images/9031347-773b803e1314f63a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n3. 点击继续，停留在SecurityManager的子类**DefaultSecurityManager**类的login方法中，然后调用自身的认证方法。\n![](https://upload-images.jianshu.io/upload_images/9031347-336b1dadd0906039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在认证方法中调用自身属性```private Authenticator authenticator = new ModularRealmAuthenticator();```来验证。\n![](https://upload-images.jianshu.io/upload_images/9031347-223a45e3cf8c0127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n4. 下一步，可以看到不是直接到子类中去，而是调用抽象父类AbstractAuthenticator的authenticate方法：\n![](https://upload-images.jianshu.io/upload_images/9031347-7adc50c0d49c39de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在次方法中调用自身的抽象方法（即模板方法模式）。调用此方法后就可以跳转到子类ModularRealmAuthenticator对象中。\n![截不下那么长的...](https://upload-images.jianshu.io/upload_images/9031347-4efc159e6418010d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 这个方法的意思就是获取realm的集合，然后判断是单个还是多个realm，然后分别进入不用的处理方法，我们这里只配置了单个realm，所以进入doSingleRealmAuthentication方法，否则进入doMultiRealmAuthentication方法。\n进入该方法!\n![](https://upload-images.jianshu.io/upload_images/9031347-95c176f02456f085.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n就到了使用realm的时候了。\n5. 下一步，进入到Realm接口的实现类也是我们实现的MyRealm的父类AuthenticatingRealm的getAuthenticationInfo方法：\n![](https://upload-images.jianshu.io/upload_images/9031347-e5575f123ff4614a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 在此方法中主要有两步：1. 首先从缓存中获取数据，这里没有配置缓存，所以先试着手动走一走这个流程：\n![](https://upload-images.jianshu.io/upload_images/9031347-c28d864066018b2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在此方法中获取缓存然后返回。回到上一张图的方法中判断是否为空，为空则进入realm获取数据。\n6. 点击下一步，可以看到来到了熟悉的代码界面了\n![](https://upload-images.jianshu.io/upload_images/9031347-e6cd134d8308c162.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n返回数据后返回。\n7. 返回的数据回到AuthenticatingRealm类中，通过assertCreddentialsMatch方法比对。\n![](https://upload-images.jianshu.io/upload_images/9031347-0b14ee21bf93f011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n8. 看看比对密码的方法：\n![](https://upload-images.jianshu.io/upload_images/9031347-8aaee3a780e94fbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n主要内容就是先获取CredentialsMatcher对象，这个作为AuthenticatingRealm的一个属性，在加密时是要在applicationContext.xml文件中配置好的（因为我这里是配置了这个的，所以就会跳转到这一步，请忽略这些细节~），如果没有配置后面再讲。\n然后就是比对了。\n一层层返回。\n9. 返回到DefaultSecurityManager类中，登录成功，调用自身onSuccessfulLogin方法，\n![](https://upload-images.jianshu.io/upload_images/9031347-d50f93d2c80180cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nrememberMeSuccessfulLogin方法：\n调用![](https://upload-images.jianshu.io/upload_images/9031347-5c3b63d73a4d4849.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n判断是否配置了记住密码。然后调用AbstractRememberMeManager类的rememberSerializedIdentity方法（抽象方法，子类中实现），到子类CookieRememberMeManager实现的方法，\n![](https://upload-images.jianshu.io/upload_images/9031347-11b9008f8f11e9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n操作很明了。\n\n10. 最后跳转到home.html界面。我们查看浏览器端的cookie，在chrome中可以看到名为rememberMe的cookie：\n![](https://upload-images.jianshu.io/upload_images/9031347-770015c4c80ce19a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n11. 后面登录时就可以直接发送此cookie直接登录了。\n# 授权\n');
INSERT INTO `blog_content` VALUES (55, '# 加密\n密码保存在数据库中肯定不能明文保存，如果被获取或着拖库，用户账号信息就很危险了。之前想过用MD5加密，后来听说MD5使用彩虹表也能倒推出明文，而且像要让不同用户的相同密码在数据库中也不同，就要加上盐值了。\n## 代码示例\n在密码验证阶段，我使用了一个main函数求出了以用户名加密后的值作为盐值的密码密文：\n```java\n    public static void main(String[] args) {\n\n        // 用户名具有唯一性，所以其作为盐值的原始值\n        ByteSource salt = ByteSource.Util.bytes(\"admin\");\n        //加密1024次\n        int hashIterations = 1024;\n         /*\n         对应于applicationContext中得配置\n            shiro.xml 中  storedCredentialsHexEncoded=true 则需要 .toHex() 就是原始值\n            shiro.xml 中  storedCredentialsHexEncoded=false 则需要 .toBase64()\n         */\n        String hashPw = new SimpleHash(\"MD5\", \"123\", salt, hashIterations).toHex();\n        System.out.println(hashPw);\n\n    }\n```\n在认证方法中模拟出从数据库中获取密码密文的过程带上盐值一起返回，交给shiro框架与前台传进来的信息做比对。\n```java\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) \nthrows AuthenticationException {\n        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;\n        System.out.println(\"do authentic\");\n\n        if (\"root\".equals(token.getUsername())) {\n\n            //使用用户名作为盐值(都是模拟从数据库中取出来的，下面密码也是。还有盐值也是，作为解密用)盐和密码一起存入数据库\n            ByteSource salt = ByteSource.Util.bytes(token.getUsername());\n            //密码时hash后的\n            return new SimpleAuthenticationInfo(\"root\", \"b1ba853525d0f30afe59d2d005aad96c\", salt, getName());\n        } else if (\"admin\".equals((token.getUsername()))) {\n            ByteSource salt = ByteSource.Util.bytes(token.getUsername());\n            //admin密码时123\n            return new SimpleAuthenticationInfo(\"admin\", \"c41d7c66e1b8404545aa3a0ece2006ac\", salt, getName());\n        }\n        return null;\n    }\n```\n前台传来的是明文，如何和密文比对呢，shiro需要知道的是加密算法、加密次数，配合realm中传回的密文和盐值才可完成匹配，所以我们要告诉shiro加密信息，在applicationContext.xml文件中加上属性credentialsMatcher设置加密算法属性和加密次数属性，然后最后一个属性告诉匹配器是用hex还是base64：\n```xml\n    <bean id=\"myRealm\" class=\"realm.MyRealm\">\n        <property name=\"credentialsMatcher\">\n            <bean class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\">\n                <!--加密算法名称-->\n                <property name=\"hashAlgorithmName\" value=\"MD5\"/>\n                <!--重复加密次数-->\n                <property name=\"hashIterations\" value=\"1024\"/>\n                <!--是否存储散列后的密码为16进制，为 true：.toHex()，为 false：.toBase64()-->\n                <property name=\"storedCredentialsHexEncoded\" value=\"true\"/>\n            </bean>\n        </property>\n    </bean>\n```\n这样就完成了代码，测试也能通过。\n## 流程分析\n1. 认证流程前面基本一样无非subject调用securityManager等等，详情看（一）\n2. 直到MyRealm返回密文和盐值到AuthenticatingRealm中，开始比对。\n![](https://upload-images.jianshu.io/upload_images/9031347-756a009adcd8b2b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n3. 判断属性credentialsMatcher是否为空，因为我们配置文件中有配置，所以不为空。\n![](https://upload-images.jianshu.io/upload_images/9031347-8376b173d6d537a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n4. 进入到credentialsMatcher的doCredentialsMatch方法中进行校验：\n![](https://upload-images.jianshu.io/upload_images/9031347-144432fb28be9976.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n此方法有三步，第一步对前台传进来的信息加密，第二部获取数据库密文，第三部两个密文对比，返回验证信息。下面分别看三部流程：\n5.  加密前台信息：\n（1）首先判断MyRealm传来的是不是包含盐值的SaltedAuthenticationInfo类，是则获取盐值。\n![](https://upload-images.jianshu.io/upload_images/9031347-3dac7d22d7730654.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n（2）然后获取加密算法字段：\n![](https://upload-images.jianshu.io/upload_images/9031347-8f89a98387afa0da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n（3）最后获取加密次数：\n是直接从属性中获取，加上这一步会更具体。\n（4）加密\n使用前文main方法中相同的加密方式：\n![](https://upload-images.jianshu.io/upload_images/9031347-90e738424589990e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n6. 获取数据库中密文，直接info.getCredentials()即可。\n7. 比对密码\n转换成字节后比对：\n![](https://upload-images.jianshu.io/upload_images/9031347-e25d14ee05bb3e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n8. 后面也和（一）中一样，不多描述。\n\n# 会话管理\n\n');
INSERT INTO `blog_content` VALUES (57, '\n');
INSERT INTO `blog_content` VALUES (58, 'redis缓存基本是可以了，就是他喵的序列化问题真的让我自闭了好几天，我真的无语了，肯定不是我的问题，fastjson的问题很明确，能序列化非静态内部类，但反序列化就呵呵，说是已经解决了无法分序列化非静态内部类，可是最新的还是报错，很多人说换成静态内部类或者单独类不就行了，官方代码怎么动，我也试过仿照官方重写一个，可这个没问题，有遇到一个对象属性无中生有序列化出一个没有的属性，jackson也是因为这个。反序列化就报错。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。我脱鞋了，无语，爱谁谁，我不搞了，我就用JdkSerializationRedisSerializer了。管他性能不性能的。\n');
INSERT INTO `blog_content` VALUES (59, '> bean的生命周期是面试题中出现频率很高的一题，以前总是靠死记硬背来记住（毕竟在对bean的使用中这些操作很少），现在才尝试着用代码一试。\n\n直接上代码：\n### xml配置bean：\n```xml\n        <bean id=\"person\" class=\"bean.Person\" init-method=\"initMethod\" destroy-method=\"destroyMethod\">\n            <property name=\"name\" value=\"hsw\"/>\n            <property name=\"age\" value=\"12\"/>\n        </bean>\n```\n这里只配置了属性的值和init-method以及destroy-method两个方法。\n### bean的类代码：\n```java\n@ToString\npublic class Person implements BeanNameAware, BeanFactoryAware, ApplicationContextAware, DisposableBean, InitializingBean {\n\n   private String name;\n   private int age;\n\n   public Person() {\n      System.out.println(\"无参构造函数！\");\n   }\n\n   public String getName() {\n      return name;\n   }\n\n   public void setName(String name) {\n      System.out.println(\"setter begin！\");\n      this.name = name;\n   }\n\n   public int getAge() {\n      return age;\n   }\n\n   public void setAge(int age) {\n      System.out.println(\"setter begin！\");\n      this.age = age;\n   }\n\n   public String getBeanName() {\n      return beanName;\n   }\n\n   public BeanFactory getBeanFactory() {\n      return beanFactory;\n   }\n\n   private String beanName;\n   private BeanFactory beanFactory;\n   private ApplicationContext applicationContext;\n\n   @Override\n   public void setBeanName(String s) {\n      System.out.println(\"beanNameAware\");\n      this.beanName = s;\n   }\n\n   @Override\n   public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n      System.out.println(\"beanFactoryAware\");\n      this.beanFactory = beanFactory;\n   }\n\n   @Override\n   public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n      System.out.println(\"applicationContextAware\");\n      this.applicationContext = applicationContext;\n   }\n\n   private void initMethod() {\n      System.out.println(\"init-method\");\n   }\n\n   private void destroyMethod() {\n      System.out.println(\"destroy-method\");\n   }\n\n   @Override\n   public void afterPropertiesSet() throws Exception {\n      System.out.println(\"InitializingBean afterPropertiesSet\");\n   }\n\n   @Override\n   public void destroy() throws Exception {\n      System.out.println(\"Disposable destroy\");\n   }\n}\n```\n可以看到bean实现的方法有很多，首先是xxxAware三个接口，能让bean察觉到spring容器存在的三个接口。然后就是两个非方法对应xml配置中的两个配置：initMethod、destroyMethod。最后就是实现了InitializingBean 的 afterPropertiesSet 方法和 Disposable 的 destroy 方法。这些方法都会在bean的生命周期中被调用以实现一些自定义的功能。\n### PostProcessor即bean的后处理器\n#### 自定义InstantiationAwareBeanPostProcessor：\n```java\npublic class MyInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {\n    @Override\n    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {\n        System.out.println(\"postProcessBeforeInstantiation\");\n        return null;\n    }\n\n    @Override\n    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {\n        System.out.println(\"postProcessProperties\");\n        return null;\n    }\n\n    @Override\n    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {\n        System.out.println(\"postProcessAfterInstantiation\");\n        return true;\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        System.out.println(\"postProcessBeforeInitialization\");\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        System.out.println(\"postProcessAfterInitialization\");\n        return bean;\n    }\n}\n```\n在xml文件中配置一下：\n```xml\n<bean id=\"myInstantiationAwareBeanPostProcessor\" class=\"others.MyInstantiationAwareBeanPostProcessor\"/>\n```\n> 这里有必要说一下：此自定义类命名为MyInstantiationBeanPostProcessor，实现了InstantiationAwareBeanPostProcessor 的几个方法。意思是对实例化阶段处理。但却多出了与接口不太相符的初始化方法，这是因为InstantiationAwareBeanPostProcessor的父接口是BeanPostProcessor，这个接口有两个默认自定义类的接口没有实现(postProcessBeforeInitialization 和 postProcessAfterInitialization)，我直接在自定义类中实现了（当然也可以自己自定义一个如MyInitialazation...自定义类实现）。\n\n### 测试方法：\n```java\n    @Test\n    public void testOne() {\n        ClassPathXmlApplicationContext context\n                = new ClassPathXmlApplicationContext(\"/bean.xml\");\n        Person person = (Person) context.getBean(\"person\");\n        System.out.println(person);\n        context.close();\n    }\n```\n启动容器获取bean打印后关闭容器。\n\n### 运行结果：\n```plain text\npostProcessBeforeInstantiation\n无参构造函数！\npostProcessAfterInstantiation\npostProcessProperties\nsetter begin！\nsetter begin！\nbeanNameAware\nbeanFactoryAware\napplicationContextAware\npostProcessBeforeInitialization\nInitializingBean afterPropertiesSet\ninit-method\npostProcessAfterInitialization\nPerson(...)//person信息，这里略\nDisposable destroy\ndestroy-method\n```\n\n### 流程梳理\n所以根据输出结果可以得出bean的生命周期大致为：\n1. InstantiationAwareBeanPostProcessor 的 postProcessBeforeInstantiation，顾名思义实例化之前调用，方法有两个参数，bean所属class对象和beanName，返回Object对象。\n2. 实例化，配置时使用的是set注入属性，所以这里调用无参构造方法。如果使用的是有参构造方法就不会了。\n3. InstantiationAwareBeanPostProcessor 的 postProcessAfterInstantiation，顾名思义实例化之后调用，方法依旧两个参数：Object bean, String beanName，返回boolean。\n> 这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null。如果该方法返回false，会忽略属性值的设置；如果返回true，会按照正常流程设置属性值\n4. InstantiationAwareBeanPostProcessor 的 postProcessProperties 。\n> 方法对属性值进行修改(这个时候属性值还未被设置，但是我们可以修改原本该设置进去的属性值)。如果postProcessAfterInstantiation方法返回false，该方法不会被调用。可以在该方法内对属性值进行修改\n5. 开始调用bean的setter方法注入配置的属性值。\n6. 注入配置好的aware接口的属性。\n7. BeanPostProcessor 的 postProcessBeforeInitialization方法，即调用初始化方法前进行相关处理，方法参数同样为Object bean, String beanName，返回Object对象。这里可以返回已经初始化好了bean，也可以返回包装后的bean，甚至其他bean。\n8. bean实现的接口InitializingBean 的 afterPropertiesSet方法，无参数无返回值，但在bean内部可以访问bean的相关属性。\n9. 然后就是init-method方法了，无参数无返回值，在bean内部。\n10. BeanPostProcessor 的 PostProcessAfterInitialation方法，参数返回值和before相同。\n11. 至此相关作用域获取到bean，这里是打印了bean的信息。如果是原型模式，bean的生命周期随其作用域。如果配置的是单例，则由spring容器管理，后面容器关闭时会有后续过程。\n12. 调用DisposableBean 的 destroy 方法，  无参数无返回值。\n13. 调用xml文件配置的destroy-method。\n');
INSERT INTO `blog_content` VALUES (61, '\n# 异常内容\n错误：\n> Exception in thread \"main\" org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from class path resource [applicationContext.xml]; nested exception is java.io.FileNotFoundException: class path resource [applicationContext.xml] cannot be opened because it does not exist\n	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:344)\n	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304)\n	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:188)\n	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224)\n	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:195)\n	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:257)\n	at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:128)\n	at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:94)\n	at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:133)\n	at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:624)\n	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:520)\n	at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:144)\n	at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:85)\n	at cnjxufe.Main.main(Main.java:13)\nCaused by: java.io.FileNotFoundException: class path resource [applicationContext.xml] cannot be opened because it does not exist\n	at org.springframework.core.io.ClassPathResource.getInputStream(ClassPathResource.java:180)\n	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:330)\n	... 13 more\n\n在使用Spring时，总会碰见这个问题，提示的是spring的配置文件找不到或不存在，即时是在文件在程序目录中的相对路径正确的情况下，也依然会报错！\n\n# 产生异常的原因\n需要了解的是，在java程序中，一个文件要使用到另一个文件，其路径完全并不是在开发程序目录中的相对路径，而是在编译的输出目录下的相对路径，这路径可能会有偏差，甚至输出目录下根本没有这个文件。\n上述异常发生的原因就是后者，在我spring-maven程序的输出目录中根本没有applicationContext.xml。\n![程序输出目录](https://upload-images.jianshu.io/upload_images/9031347-7832a735c99080e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 解决异常\n我们要做的就是手动将applicationContext.xml即spring配置文件复制到输出目录下的相应路径下！\n![移动文件](https://upload-images.jianshu.io/upload_images/9031347-129a47926acb27e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n再次运行即可成功！\n\n\n');
INSERT INTO `blog_content` VALUES (62, '> 对于AOP的理解一直很模糊，学习Spring的[视频](https://www.bilibili.com/video/av21335209/?p=16)正好讲到，老师讲的很好，我也稍微懂了点，在这里针对其内容整理下。\n\n# 简单概念\nAOP（Aspect-Oriented Programming）即面向切面编程，是对于OOP的补充。不同于OOP的面向纵向编程，AOP面向的是切面即横向编程，她将纵向的某个流程提取出来，给其添加相应的功能。这里不做过多的解释先来看一个例子。\n#代码示例\n\n###需求\n实现一个计算机类，能进行加减乘除运算，而且还需要添加**日志功能**记录进行了那些运算和**调试功能**在运行方法时就返回结果！\n\n接口\n```java\ninterface CalculatorInterface {\n    int add(int a, int b);\n\n    int sub(int a, int b);\n\n    int mul(int a, int b);\n\n    int div(int a, int b);\n}\n```\n\n实现类计算器类：\n```java\npackage cnjxufe.beans_12_AOP;\n\n/**\n * @author hsw\n * @create 2018-11-07  15:37\n */\npublic class Calculator implements CalculatorInterface {\n\n    @Override\n    public int add(int a, int b) {\n        System.out.println(\"add方法被调用，参数 : a = \" + a + \", b = \" + b);\n        int result = a + b;\n        System.out.println(\"a + b = \" + result);\n        return result;\n    }\n\n    @Override\n    public int sub(int a, int b) {\n        System.out.println(\"sub，参数 : a = \" + a + \", b = \" + b);\n        int result = a - b;\n        System.out.println(\"a - b = \" + result);\n        return result;\n    }\n\n    @Override\n    public int mul(int a, int b) {\n        System.out.println(\"mul方法被调用，参数 : a = \" + a + \", b = \" + b);\n        int result = a * b;\n        System.out.println(\"a * b = \" + result);\n        return result;\n    }\n\n    @Override\n    public int div(int a, int b) throws ArithmeticException{\n        System.out.println(\"div方法被调用，参数 : a = \" + a + \", b = \" + b);\n        int result = a / b;\n        System.out.println(\"a / b = \" + result);\n\n        return result;\n    }\n}\n```\n这样每次我们调用计算方法时都会有日志与结果的输出。\n![](https://upload-images.jianshu.io/upload_images/9031347-d85f093e8797dd47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 问题\n上面的代码是没有用到AOP编程的，这样做会造成两个问题：\n- **代码混乱**：越来越多的非业务需求（比如上面的日志记录和结果显示）会是业务处理代码急剧膨胀，业务方法除了处理业务逻辑外还要兼顾其他内容。\n-**代码分散**：单一的需求相同代码在多个模块或方法中分散，一旦需求变更就必须改变多出的模块，这会给代码的维护和更新带来巨大成本！\n\n### 解决问题\n如何解决上面两个问题呢？这里我们就要使用AOP了！这里先不用Spring的AOP，而是用动态代理来实现AOP。要了解动态代理原理就要先了解代理设计模式，可以自己去了解下，一遍理解下面的代码：\n\n之前的计算机实现类不动，新建一个计算机原始类其每个方法只实现业务逻辑：\n```java\npackage cnjxufe.beans_12_AOP;\n\n/**\n * @author hsw\n * @create 2018-11-07  16:05\n */\npublic class OriginalCalculator implements CalculatorInterface {\n    @Override\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    @Override\n    public int sub(int a, int b) {\n        return a - b;\n    }\n\n    @Override\n    public int mul(int a, int b) {\n        return a * b;\n    }\n\n    @Override\n    public int div(int a, int b) {\n        return a / b;\n    }\n}\n```\n再实现动态代理类：\n```java\npackage cnjxufe.beans_12_AOP;\n\nimport java.lang.reflect.Proxy;\n\n/**\n * @author hsw\n * @create 2018-11-07  16:06\n */\npublic class DynamicProxy {\n\n//    要代理的对象\n    private CalculatorInterface target;\n\n    public DynamicProxy(CalculatorInterface target) {\n        this.target = target;\n    }\n\n    public CalculatorInterface getDynamicProxy() {\n        CalculatorInterface proxy = null;\n        ClassLoader loader = target.getClass().getClassLoader();\n        proxy = (CalculatorInterface) Proxy.newProxyInstance(loader, new Class[]{CalculatorInterface.class}, \n        (object, method, args) -> {\n            System.out.println(method.getName() + \"方法被调用，参数 : a = \" + args[0] + \", b = \" + args[1]);\n            int result = (int) method.invoke(target, args[0], args[1]);\n            System.out.println(\"a \" + method.getName() + \" b = \" + result);\n            return result;\n        });\n        return proxy;\n    }\n}\n```\n> 其中lambda表达式（这个就是我们使用代理对象其中的方法时，被调用的方法！）代表的是：\n```java\n        new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                return null;\n            }\n        };\n```\n> 参数解释：\nproxy：正在返回的代理对象，一般情况下invoke方法不使用该对象！\nmethod：正在被调用的方法\nargs：被调用的方法的入参\n\nMain类执行两个对象的计算方法：\n```java\npublic static void main(String[] args) {\n\n        System.out.println(\"没有使用代理的结果：\");\n\n        Calculator calculator = new Calculator();\n        System.out.println(calculator.add(12, 10));\n\n        System.out.println(\"以下是使用代理后的结果：\");\n\n        CalculatorInterface calculatorWithProxy = new OriginalCalculator();\n        CalculatorInterface proxy = new DynamicProxy(calculatorWithProxy).getDynamicProxy();\n        System.out.println(proxy.add(12, 10));\n    }\n```\n\n#### 结果：\n![结果一样](https://upload-images.jianshu.io/upload_images/9031347-455370738a6730a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####原理：\n动态代理模式实现了AOP，让一个代理包裹住原对象的业务方法，当用户使用对象的某个方法时，其必先经过代理的某个对应的方法，然后由代理对象决定何时和怎样调被代理对象！\n\n# AOP简介\nAOP是一种新的方法论，是对传统oop的补充，AOP的主要编程对象是切面，在上述例子中我们添加的代码并不是针对整个逻辑流程而编码，而是为了四个计算方法，这个四个方法在整个流程中属于同一级，类似于一个切面。嗯，，，可以这么理解！\nAOP的好处：\n-  每个事务逻辑位于一个位置，代码不分散，便于维护和升级\n- 代码模块更加简洁，只包含核心代码\n\n# AOP概念\n### 切面\n横切关注点（跨越应用程序多个模块的功能，比如位置功能）被模块化的多个对象。像上面例子中的日志功能就是一个切面！\n### 通知\n切面必须要完成的工作，在切面中的每一个方法就可以被称之为通知！\n### 目标\n被通知的对象 ，上述例子中的add，sub等计算方法就是目标。\n### 代理\n就是上面例子中的proxy对象\n### 连接点\n程序执行的某个特定的位置：如类某个方法调用前、调用后，方法抛出异常后等。**连接点有两个信息确定：方法表示程序执行点相对点表示方位。**比如说***add方法执行前***就是一个连接点，执行点就是***add方法***，方位为***执行前***。\n### 切点（不懂，以后加）\n![](https://upload-images.jianshu.io/upload_images/9031347-91f77cf47b15e8d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n');
INSERT INTO `blog_content` VALUES (64, '[initializer tool](https://start.spring.io/)\n[掘金关于mvn](https://juejin.im/post/5b5c742751882508603d005e)\n[https://www.jianshu.com/p/1864ba77a836](https://www.jianshu.com/p/1864ba77a836)\n\nswagger\n');
INSERT INTO `blog_content` VALUES (66, '# spring boot 的自动加载机制\n> 视频的第20集仔细的和我们讲了spring boot开启时是如何加载组件的。速度有些快，我是看来四遍才懂的。\n接下来先讲下大概。\n\n1. spring boot在启动时会加载大量形如xxxAutoConfiguration即自动配置类。具体那些类会被加载取决于配置文件中是否有相应的配置。\n\n2. 这些类是如何根据配置决定是否加载的呢，加载做了什么事？\n我们那HttpEncodingAutoConfiguration类作为例子讲解，看其部分源码：\n```java\n// 注解其为配置类，当此类被加载，就会将某些组件添加进spring容器中。\n@Configuration\n// 如果此类被加载，激活xxxProperties类与配置文件的绑定，\n// 在spring boot中，配置文件中的每一项都有与之对应的properties类的属性。\n// 自动配置类也会使用该类中的属性值来生成组件。\n@EnableConfigurationProperties({HttpProperties.class})\n// 以下三个@ConditionalXxx就是判断是否加载此类的属性\n// 判断是否为web应用，如果其为web应用且classpath中存在CharacterEncodingFilter.class\n// 而且还有spring.http.encoding属性配置了且值为enable(matchIfMissing则表示没有也没关系，\n// 默认值为true)，则就加载。\n@ConditionalOnWebApplication(\n    type = Type.SERVLET\n)\n// 比如需要有Aspect类，但没有导入相关依赖，classpath中没有该类，就不加载\n@ConditionalOnClass({CharacterEncodingFilter.class})\n@ConditionalOnProperty(\n    prefix = \"spring.http.encoding\",\n    value = {\"enabled\"},\n    matchIfMissing = true\n)\npublic class HttpEncodingAutoConfiguration {\n    private final Encoding properties;\n\n    public HttpEncodingAutoConfiguration(HttpProperties properties) {\n        this.properties = properties.getEncoding();\n    }\n\n    // 添加组件到容器中\n    @Bean\n    // 如果spring容器中没有这个bean对象的话（conditional扩展注解还有很多！）\n    @ConditionalOnMissingBean\n    public CharacterEncodingFilter characterEncodingFilter() {\n        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();\n        filter.setEncoding(this.properties.getCharset().name());\n        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));\n        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));\n        return filter;\n    }\n    //...\n}\n```\n***注意，我们可以通过设置 debug=true 来控制程序将自动配置报告打印在控制台中，方便我们查看！***\n\n> 实现自动加载功能的类都存在于spring-boot-starter依赖所依赖的spring-boot-autoconfiguration中。\n');
INSERT INTO `blog_content` VALUES (67, '\n> 以前写项目，静态资源一般都是放在webapp文件夹下，使用spring initializer创建的项目根本没有webapp文件夹，但spring boot有自己的映射规则。且看分析。\n\n#### 一、之前所说的配置文件访问路径\n- 规则1：之前说配置文件可以放置的位置：\"classpath:/META-INF/resources/\",\n                            \"classpath:/resources/\",\n                            \"classpath:/static/\", \n                            \"classpath:/public/\"。\n来源自类ResourceProperties自身的一个final属性。\n```java\n// 所以当前spring.resources前缀的配置可以设定与静态资源相关的参数，比如缓存时间什么的！\n@ConfigurationProperties(\n    prefix = \"spring.resources\",\n    ignoreUnknownFields = false\n)\npublic class ResourceProperties {\n    private static final String[] CLASSPATH_RESOURCE_LOCATIONS\n       = new String[]{\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"};\n}\n```\n\n### 二、另外\n在spring boot的spring mvc中，相关配置都在WebMvcAutoConfiguration类里面，这也就是我们之前提到过的类自动装载类。\n他有一个addResourceHandler即资源处理方法。\n```java\n@Configuration\n@ConditionalOnWebApplication(\n    type = Type.SERVLET\n)\n@ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class})\n@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})\n@AutoConfigureOrder(-2147483638)\n@AutoConfigureAfter({DispatcherServletAutoConfiguration.class,\n                     TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class})\npublic class WebMvcAutoConfiguration {\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        if (!this.resourceProperties.isAddMappings()) {\n            logger.debug(\"Default resource handling disabled\");\n        } else {\n            Duration cachePeriod = this.resourceProperties.getCache().getPeriod();\n            CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\n            if (!registry.hasMappingForPattern(\"/webjars/**\")) {\n                this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{\"/webjars/**\"})\n                    .addResourceLocations(new String[]{\"classpath:/META-INF/resources/webjars/\"})\n                    .setCachePeriod(this\n                    .getSeconds(cachePeriod)).setCacheControl(cacheControl));\n            }\n    \n            String staticPathPattern = this.mvcProperties.getStaticPathPattern();\n            if (!registry.hasMappingForPattern(staticPathPattern)) {\n                this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern})\n                    .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\n                    .setCachePeriod(this.getSeconds(cachePeriod))\n                    .setCacheControl(cacheControl));\n            }\n        }\n    }\n}\n```\n- 规则2：所有```webjars/**```都去```classpath:/META-INF/resources/webjars/```路径找资源。\n```\nif (!registry.hasMappingForPattern(\"/webjars/**\")) {\n    this.customizeResourceHandlerRegistration(\n        registry\n            .addResourceHandler(new String[]{\"/webjars/**\"})\n            .addResourceLocations(new String[]{\"classpath:/META-INF/resources/webjars/\"})\n            .setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)\n    );\n}\n```\n> 那么何为webjars？即以jar包的方式导入静态文件。可以试试google webjars，可以进入网站https://www.webjars.org/导包。比如我已经导入的jquery包\n```\n    <dependency>\n       <groupId>org.webjars</groupId>\n       <artifactId>jquery</artifactId>\n       <version>3.4.1</version>\n   </dependency>\n```\n可以看到引入的webjars：\n![](https://upload-images.jianshu.io/upload_images/9031347-95b12626f9ab4231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n启动spring boot直接访问localhost:8080/webjars/jquery/3.4.1/jquery.js就可以访问到这个js文件。\n\n方法的源码向下看\n```java\nString staticPathPattern = this.mvcProperties.getStaticPathPattern();\nif (!registry.hasMappingForPattern(staticPathPattern)) {\n    this.customizeResourceHandlerRegistration(\n            registry.addResourceHandler(new String[]{staticPathPattern})\n                .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\n                .setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));\n}\n```\n> 上述源码可以看出```staticPathPattern```与 ```getResourceLocations(this.resourceProperties.getStaticLocations())```是映射的。\n那么两者的默认值是什么呢？\nctrl点进去：可以看到this表示的WebMvcProperties类中的无参构造函数中```this.staticPathPattern = \"/**\";```。所以其对应/**。\n同样ctrl点击后面的获取路径的方法：同样来到ResourceProperties类中。\n```java\npublic class ResourceProperties {\n    private static final String[] CLASSPATH_RESOURCE_LOCATIONS \n        = new String[]{\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"};\n    private String[] staticLocations;\n    \n    public ResourceProperties() {\n        this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;\n        this.addMappings = true;\n        this.chain = new ResourceProperties.Chain();\n        this.cache = new ResourceProperties.Cache();\n    }\n}\n```\n其默认构造函数将CLASSPATH_RESOURCE_LOCATIONS赋予staticLocations。所以没有特殊配置，其默认值和第final属性是一样的！\n- 规则3：/**映射{\"classpath:/META-INF/resources/\",\n \"classpath:/resources/\",\n  \"classpath:/static/\",\n   \"classpath:/public/\"}\n   我已经在项目文件夹下创建了对应的文件夹！\n   \n### 三、欢迎页面\n同样在WebMvcAutoConfiguration类里面的方法\n```java\npublic class WebMvcAutoConfiguration {\n    private Optional<Resource> getWelcomePage() {\n        String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());\n        return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();\n    }\n    \n    private Resource getIndexHtml(String location) {\n        return this.resourceLoader.getResource(location + \"index.html\");\n    }\n}\n```\n其中this.resourceProperties.getStaticLocations()获取的还是ResourceProperties类中的那个final属性中的路径，然后后面使用java 1.8中的流遍历将对应的路径和index.html结合获取首页地址。所以我们可以试试数组中的随便一份路径的文件夹下面创建一个index.html。\n然后直接访问localhost:8080就可以访问到欢迎页面了！我已在public文件夹下面创建。\n\n### 四、页面图标\n在WebMvcAutoConfiguration类的最后有一个静态内部类叫做FaviconConfiguration用来配置页面图标的。\n道理和前面差不多，不讲了。想要更换页面图标，只要将一个favicon.ico文件移到上述final属性所有的文件夹之一即可！\n');
INSERT INTO `blog_content` VALUES (68, '> 本以为这个聂鹏老师是个很水的老师，声音小，吐字不清，今晚没有抱多大的希望能听课。可不知道是有人提醒还是讲到了课程相关内容，突然就大声起来，讲课很注重细节，让我学到了很多已经涉足但并没有具体了解的东西！今夜的课范围很广，从计算机网络到操作系统再到j2ee，体现了这个老师极高的技术水平！\n\n> 今夜的课和曾经J2ee的第一节课很像，都是配置安装课程相关环境。都会讲解某个文件或者某个app的用途，不同的是今夜是老师给了我们一个很纯净的云系统手把手教学，还讲解了很多陈积富老师没有讲到的细节，使得这节课虽然很多与之前重复的内容，但是还是感觉学到了很多东西！\n\n> 现在在网上下个windows7的镜像搭建个虚拟机是来不及了，但是我又不想让这些很重要又很细节的东西消失在脑海里，只能在简书中将记忆以文字的形式记录下来自己看，给别人看也看不懂不是吗？\n\n>能实现的步骤就贴图（比如SQL Server 2008R2的安装和相关配置的操作），其他的文字吧，纯靠记忆，感觉有点悬！能看就看吧！\n\n# JDK的安装和tomcat的配置及相关操作\n\n```在听课前看到这标题估计我连课都逃了,但幸好没有，老师讲了很多不懂的！```\n### jdk安装配置细节\n1. 准备：将环境变量中的JAVA_HOME删掉，还原场景。。。\n2. 安装jdk和将tomcat解压后移至相应路径\n![我的tomcat文件夹目录](https://upload-images.jianshu.io/upload_images/9031347-f7a596e314dfffdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3. 然后cmd窗口进入这个目录，试着开启tomcat\n```cmd\nD:                                      转到D盘\ncd D:Tomcatin               进入tomcat的bin目录\nstartup.bat                         启动tomcat\n```\n然后就会提示\n![启动失败](https://upload-images.jianshu.io/upload_images/9031347-86e4d19139e2868e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n错误信息显示：\nJAVA_HOME和JRE_HOME环境变量都没有配置，只要配置了一个就可以运行了。\n4. 我们现在配置环境变量\n![](https://upload-images.jianshu.io/upload_images/9031347-4edbb5c4c0f31f49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n在系统变量中添加\nJAVA_HOME\njdk目录路径\n\nJRE_HOME\njre目录路径\n即可！\n```\n5. 现在再打开一个新的cmd窗口，重复3中的步骤就能启动成功\n6. 对比一下，在新旧窗口中都输入```set```回车：\n![左新右旧](https://upload-images.jianshu.io/upload_images/9031347-eeb1824b2881927b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n发现配置了环境变量后可以看到相关配置了，而之前打开的窗口却没有，所以不能运行tomcat！\n> 其实配置一个就行了，即JAVA_HOME和JRE_HOME配置其中一个就行了！\n\n###tomcat目录详解\n**具体可以看简书中一位大佬的博客：[Tomcat7配置及其servlet调用详解](https://www.jianshu.com/p/0042d976bb39)**\n- **/bin**：存放widows或Linux平台上启动和关闭Tomcat的脚本文件\n![](https://upload-images.jianshu.io/upload_images/9031347-f280b7f8c94fdf13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在bin目录下我们能看到很多文件能看到拥有相同文件名，后缀分别为bat和sh的，bat是在windows系统下运行的，而sh是在linux下运行，shell的简写而已！\n- **/conf**：存放Tomcat服务器的各种全局配置文件\n在这个文件夹下老师下老师提到了一个文件server.xml，打开这个文件找到\n![](https://upload-images.jianshu.io/upload_images/9031347-ae7ae292d780b950.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n之前我们访问我们自己的程序总得在localhost后面加上8080端口号，怎么可以省略这一步呢，我们知道浏览器http协议默认端口是80，我们把这里的连接端口改成80即可！修改后可以直接用```localhost```访问tomcat默认页面（要先启动tomcat，我就忘了...）。就不上图了！\n- **/lib**：这个就是相关的jar包了，这里储存的类的作用大致是将jsp转化成Servlet之类的功能了，jar包其实就是个压缩包，封装了许多类，这就和tomcat中存储程序的形式war相似，都是可访问执行压缩包。\n- **/logs**：存放Tomcat执行时的日志文件，不说\n- **/temp**：存放Tomcat运行时所产生的临时文件，临时存放服务器编译过后的jsp、servlet、字节码文件、图片之类的，相当于缓存，不用每次都编译，提高速度！\n- **/webapps**：Tomcat的主要Web发布目录，默认情况下把Web应用文件放于此目录。\n![目录下文件结构](https://upload-images.jianshu.io/upload_images/9031347-d1c163398b815278.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nROOT全大写感觉就是为了突出其是其他同目录下文件的根目录，也是我们前面说的默认访问目录，即localhost就是直接访问其目录下的index.jsp文件！\n> 在网站搭建时，就是在云服务器中配置好jdk和tomcat，直接将网站文件直接放入这里就可以通过ip地址访问了。\n\n实践下：**先证明ROOT是默认目录**\n我们把ROOT下的index.jsp修改下：\n![原来的代码全删掉，添加这个](https://upload-images.jianshu.io/upload_images/9031347-871be85babbfde68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n保存后访问localhost：\n![显示修改后的内容](https://upload-images.jianshu.io/upload_images/9031347-f834076b21b5e764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**证明ROOT是其他目录的根目录**\n现在我在ROOT同目录下的的docs目录下添加一个a.html文件内容为：\n```\nhello! I am a.html. what a happy evening!\n```\n然后再通过```localhost/docs/a.html```访问这个a.html文件：\n![](https://upload-images.jianshu.io/upload_images/9031347-99925c0de5b3268f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 之前一直就奇怪，为什么intellij执行的文件路径不像myeclipse还要加个项目名，原来intellij是直接将ROOT文件夹的所有文件换成了正在运行的程序的所有相关文件，而myeclipse则是直接将程序文件夹加在了webapps文件夹下，通过第二个示例可以看出。\n\n- /work：用于存放JSP应用程序在部署时编译后产生的java文件和class文件等\n一层层点进去可以看到，index被专成了java类和class文件：\n![](https://upload-images.jianshu.io/upload_images/9031347-845b01e5dd595103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>先写到这里吧，后面再添加点我安装SQLServer的步骤和一些操作\ntelnet、netstatu -an什么的命令的。。。\n有点晚了！\n\n\n\n\n\n');
INSERT INTO `blog_content` VALUES (69, '\n');
INSERT INTO `blog_content` VALUES (70, '&ensp; 正如许多网友所说，csdn越来越商业化了，广告多，许多功能不人性化。像什么回收站自己没有回收权限，微信很难解绑，最最最最最大的缺陷是使用markdown编辑器不能ctrl+V粘贴qq截屏的图片。csdn让我越来越失望，今天偶然看到简书，其简洁的ui让我一下就喜欢上了它，再试了下markdown编辑器，ctrl+V能粘贴图片！！！这就让我下定了决心，博客搬家至简书，或者，以后有条件自己搭建个人博客！\n&ensp; 正如上面所说，商业化的csdn只允许博客从别的平台搬进，而不允许搬出，商业目的明显，我现在只能一篇一篇赋值粘贴了。不过既然要一篇篇赋值粘贴的话，我就可以将以前的博客没有用markdown排版的杂乱的博客给好好整理下，也是好的！\n&ensp; 哎！看来要费点时间了！\n&ensp;也欢迎来访问我的[CSDN](https://blog.csdn.net/qq_38016931)！\n&ensp;以后部分博客在csdn和简书同步更新，虽然没人看\n![保持微笑](http://upload-images.jianshu.io/upload_images/9031347-8e70aa0dd6f2eb9e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n');
INSERT INTO `blog_content` VALUES (71, '刚刚考试不知怎的突然回想起昔日无聊就跑到新华书店看书的场景，当时面对着那么多有趣的书总有一种想一览而尽的冲动，心中也萌生出以后开家书店的想法。在那里总是能看到很多孩子或趴着或坐着在那里看书，这样的童年才算健康吧！\n\n可现如今，昔日的新华书店早已关门，政府门口的图书馆形同虚设，有没有书都不知道，反倒是网吧行业欣欣向荣，雨后春笋般的出现在各个街道，管理人员处于某些不可知的原因睁一只眼闭一只眼，该离学校多少米，该让多大的孩子进入网吧在利益面前变得无所谓。\n真的挺悲哀的，一个诺大的县城没有一个政府管理人员意思得到这个问题，管中窥豹，整个中国有多少个县城多少个镇处于这种状态，我不知道鼓励阅读的行为对政府来说有多难，我只是作为一个中国人对国家现状的情绪上的焦虑，不知是我太悲观还是如何，总觉得如今祖国发生的很多事情都向着坏的一面发展，虽然经济形势蒸蒸日上，可很多方面并没有跟上经济发展的速度。\n\n想想真的挺恐怖，作为一个成绩平平，考上一个很普通二本的我，在高考时候全省30多万的排名里能在前8万（或稍后面），后面的那些20多万的人在或在专科院校，或步入社会，我没有说成绩不好的人就一定不好，但放眼如今，大学里那些高中成绩比我好的现在颓废如此，后面的能好到哪去，这些人以后只是中国手工业的巨大劳动力的一部分吗？我衷心的希望以后祖国不再为别人打工，而是把工厂造到别的国家，同胞们的能在一些高新技术上提供劳动力。我很不懂，为什么中国这么多人，经济上去了不是理所应当吗？？？（肯定是我孤陋寡闻），很不喜欢很多祖国的小粉红，一个劲的喊高铁、动车，我说一个大国的刚需，举大国之力这东西出来不是理所当然吗？小粉红只会让更多人只看见好的一面而忽视我们的短处，让我们变得浮躁，让过去所谓“赶英超美”的思想死灰复燃。现在我们更应该做的是正视国家实力，应该做的是提升自己（有点浮夸哈！）而不是当个经济发展催生游手好闲无所事事的懒人，这样的人真的是浪费资源（虽然我自己没好到哪去，但最起码每日都有些进步吧）。\n\n说回正题，阅读对于一个人的改变我深有感受，如今的我却也因缺少阅读而惋惜，整个大学要么就是打代码落入所谓的舒适区，要么就是做些毫无营养的事情荒废时间，虽然一直以来觉得自己并没有那么荒废，可是有时候细细一想，自己的知识好像少得可怜，要知道，我是个大三的学生了，随着2018年的逝去，大学真的要到尾声了。就业压力跨越一年的时空涌上心头，现在空空如也的脑子里满是苦闷，心急如焚毫无办法。\n\n今日《编码》、《鸟哥的linux私房菜》到了，不是我钱多，也不是我没书看了，只是我想花钱买书来激励自己，平静浮躁的心，多看看书，让自己的能力做到实质性的提高！现在名著算是差不多买全了，只剩用时间催化，转化为脑海中的知识了！\n\n再次立一个一般不会实现只是为了激励自己努力\"三分钟\"的flag了（三分钟也是时间啊！总比没得好），复习完设计模式、操作系统、数据库，就去临幸这些书吧！！！坐着难受就站着看，站着难受就去运动运动呗！\n\n仅写给自己看的~\n');
INSERT INTO `blog_content` VALUES (72, '转自：  http://www.win7zhijia.cn/jiaocheng/win7_9990.html\n\n在使用[win7系统](http://www.win7zhijia.cn/)的时候，大家想必都喜欢将一些程序添加到任务栏，方便快速打开，一般只需要右键选择“将此程序锁定到任务栏”即可，可是有[**windows7旗舰版64位**](http://www.win7zhijia.cn/xitong/)系统用户右击IE浏览器的时候，却发现没有“将此程序锁定到任务栏”选项怎，导致IE浏览器无法锁定，该如何处理呢？现在给大家介绍一下具体的解决措施吧。\n\n![Win7电脑右击IE没有“将此程序锁定到任务栏”选项怎么办](http://upload-images.jianshu.io/upload_images/9031347-3dfc06f6b34ab30b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n具体步骤如下。\n把以下命令分别输入到开始-运行中（快速启动运行：Windows+R）\n1. cmd /k reg add \"HKEY_CLASSES_ROOTlnkfile\" /v IsShortcut /f\n2. cmd /k reg add \"HKEY_CLASSES_ROOTpiffile\" /v IsShortcut /f\n3. cmd /k taskkill /f /im explorer.exe & explorer.exe\n4. 这时会出现左面和任务栏消失的情况。```ctrl + shift + esc```跳出任务管理器，然后右键新建任务，在C:windowsexplore.exe,然后点击运行就行了！\n5. 现在你把桌面的图标或其他路径的程序直接拖到windows7的任务栏就可以了，拖到任务栏但没放开时就出现了“附到任务栏”的提示。\n');
INSERT INTO `blog_content` VALUES (73, '# 基本概念\n32位的CPU与64位CPU\n>以下内容摘自维基百科：\n64 位 CPU 是指 CPU 内部的通用寄存器的宽度为 64 比特，支持整数的 64 比特宽度的算术与逻辑运算。那么 32 位 CPU 同理。\n一个 CPU，联系外部的数据总线与地址总线，可能有不同的宽度；术语“64位”也常用于描述这些总线的大小。不过这一术语也可能指电脑指令集的指令长度，或其它的数据项。去掉进一步的条件，“64位”电脑架构一般具有 64 位宽的整数型寄存器，它可支持 64 位“区块”的整数型数据。\n64 位架构无疑可应用在需要处理大量数据的应用程序，如数字视频、科学运算、和早期的大型数据库。\n\n# 那么 32 位 CPU 与 64 位 CPU 到底有什么区别？\n\n**数据处理能力增强**：64 位 CPU 通用寄存器的位宽增加一倍，这也就意味着 64 位 CPU 可以一次性处理 64bit 的整形数据；\n**内存寻址能力增强**：如果是 32 位 CPU 的话，它的地址总线最多不会超过 32，那么它所能达到的寻址范围也就不会超过 2 的 32 次方字节（存储单元以字节为单位），也就是 4GB，而如果是 64 位处理器的话，它所能达到的寻址范围理论上就会是 2 的 64 次方字节（上亿 GB）。\n> 补充：一般处理器多少位是指通用寄存器的长度，当然数据线需要与之相同；地址线则不需要与之相等，好比 intel 64 位处理器则是 40 位地址总线，最大支持 1TB 的内存寻址。\n\n# 32位操作系统与64位操作系统\n平时我们所说的 32 位操作系统也被称为 X86 系统，x64 代表 64 位操作系统，关于它的简略解释：[为什么32位的计算机系统不叫x32而叫x86呢？](https://www.zhihu.com/question/49601232/answer/309709569)\n\n### 关于 32 位操作系统与 64 位操作系统的区别如下：\n\n**32 位操作系统**既可以运行在 32 位的 CPU 上，也可以运行在 64 位的 CPU 上，只不过，运行在 64 位 CPU 上的话，就有点“大马拉小车”的感觉了——无法发挥出 CPU 的全部能力。\n\n**64 位操作系统**只能运行在 64 位的 CPU 上，因此如果一个操作系统是 64 位，那么它的 CPU 架构也必定是 64 位。\n\n**64 位操作系统**相比于 32 位操作系统的优势正如上述 64 位 CPU 与 32 位 CPU 的优势一样。\n\n# 总线结构与主板构成\n\n>注：以下两部分内容摘抄自：[32位系统最大只能支持4GB内存之由来~](https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html)\n\n**在解决本文标题所述的问题之前，我们再来了解一些关于总线结构与主板构成的相关知识。**\n\n说起总线大家肯定不陌生，而且大家平时肯定跟它打过交道，我们在用U盘拷贝数据的时候先要把U盘通过USB接口与电脑相连才能拷贝。USB接口实际上就是一种总线，一般称这种总线为USB总线（也叫做通用串行总线）。\n\n在很久之前是没有USB总线的，那个时候每个外设各自采用自己的接口标准，举个最简单的例子：鼠标生产厂商采用鼠标特有的接口，键盘生产厂商用键盘特有的接口，这样一来的话，PC机上就必须提供很多接口，这样一来增加了硬件设计难度和成本，直到后来USB接口的出现，它统一了很多外设接口的标准，不仅使得用户可以很方便地连接一些外设，更增强了PC的可扩展性。\n\n所以现在大家看到的鼠标、键盘、U盘、打印机等等这些外设都可以直接通过USB接口直接插到电脑上的。\n\n在计算机系统中总线是非常重要的一个概念，正是因为有了总线，所有的组成部件才能一起正常协同分工合作。在很久以前的PC机中，采用的是三总线结构，即：数据总线、地址总线、控制总线。它们分别用来传输不同类型的数据，数据总线用来传输数据，地址总线用来传输地址，控制总线用来传输一些控制信号。\n\n随着时代的发展，这种简单的总线结构逐渐被淘汰。下面这幅图是现代计算机采用的结构：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-ab4d7e016a79f0bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n事实上这也是现代主板所采用的结构，当然可能部分地方有略微不同（大体结构是差不多的），仔细观察过主板构成的朋友可能对上面一幅图很熟悉。在主板上主要有两大主要部分：北桥（North Bridge也称Host Bridge）和南桥（South Bridge）。北桥主要负责CPU和内存、显卡这些部件的数据传送，而南桥主要负责I/O设备、外部存储设备以及BIOS之间的通信。现在有些主板已经没有北桥了，因为芯片厂商已经把北桥所负责的功能直接集成到CPU中了（不过暂且我们以上副图的模型来讨论）。\n\n在上副图中，我没有画出数据总线和地址总线等，因为在某些总线标准中它们被集成到一起了，比如在PCI总线中，地址总线和数据总线总是分时复用的（也就是说假如PCI总线有32位数据总线，这32位总线在某个时刻可以充当数据总线的作用，在下一时刻可以充当地址总线的作用）。有的总线同时提供了数据总线和地址总线。\n\n**下面来说一下几个主要总线和南北桥的作用：**\n\n**FSB总线**：即前端总线（Front Side Bus），CPU和北桥之间的桥梁，CPU和北桥传递的所有数据必须经过FSB总线，可以这么说，FSB总线的频率直接影响到CPU访问内存的速度。\n\n**北桥**：北桥是CPU和内存、显卡等部件进行数据交换的唯一桥梁，也就是说CPU想和其他任何部分通信必须经过北桥。北桥芯片中通常集成的还有内存控制器等，用来控制与内存的通信。现在的主板上已经看不到北桥了，它的功能已经被集成到CPU当中了。\n\n**PCI总线**：PCI总线是一种高性能局部总线，其不受CPU限制，构成了CPU和外设之间的高速通道。比如现在的显卡一般都是用的PCI插槽，PCI总线传输速度快，能够很好地让显卡和CPU进行数据交换。\n\n**南桥**：主要负责I/O设备之间的通信，CPU要想访问外设必须经过南桥芯片。\n\n#####在了解了这些基础东西之后，下面来讲解一下为何 32 位系统最大只支持 4GB 内存。（是的，就算是 64 位的 CPU，装载 32 位的操作系统，它的寻址能力还是 4GB。）\n\n对于标题的解释\n在使用计算机时，其最大支持的内存是由操作系统和硬件两方面决定的。\n\n#### 先说一下硬件方面的因素\n在上面已经提到了地址总线，在计算机中 CPU的地址总线数目 决定了CPU 的 寻址 范围，这种由地址总线对应的地址称作为物理地址。假如CPU有32根地址总线（一般情况下32位的CPU的地址总线是32位，也有部分32位的CPU地址总线是36位的，比如用做服务器的CPU），那么提供的可寻址物理地址范围 为 232=4GB（在这里要注意一点，我们平常所说的32位CPU和64位CPU指的是CPU一次能够处理的数据宽度，即位宽，不是地址总线的数目）。自从64位CPU出现之后，一次便能够处理64位的数据了，其地址总线一般采用的是36位或者40位（即CPU能够寻址的物理地址空间为64GB或者1T）。在CPU访问其它任何部件的时候，都需要一个地址，就像一个快递员送快递，没有地址他是不知道往哪里送达的，举个例子，CPU想从显存单元读取数据，必须知道要读取的显存单元的实际物理地址才能实现读取操作，同样地，从内存条上的内存单元读取数据也需要知道内存单元的物理地址。换句话说，CPU访问任何存储单元必须知道其物理地址。\n\n用户在使用计算机时能够访问的最大内存不单是由CPU地址总线的位数决定的，还需要考虑操作系统的实现。实际上用户在使用计算机时，进程所访问到的地址是逻辑地址，并不是真实的物理地址，这个逻辑地址是操作系统提供的，CPU在执行指令时需要先将指令的逻辑地址变换为物理地址才能对相应的存储单元进行数据的读取或者写入（注意逻辑地址和物理地址是一一对应的）。\n\n#### 对于32位的windows操作系统\n其逻辑地址编码采用的地址位数是32位的，那么操作系统所提供的逻辑地址寻址范围是4GB，而在intel x86架构下，采用的是内存映射技术(Memory-Mapped I/O, MMIO)，也就说将4GB逻辑地址中一部分要划分出来与BIOS ROM、CPU寄存器、I/O设备这些部件的物理地址进行映射，那么逻辑地址中能够与内存条的物理地址进行映射的空间肯定没有4GB了，看下面这幅图就明白了：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-a4daf067f41723a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n所以当我们装了32位的windows操作系统，即使我们买了4GB的内存条，实际上能被操作系统访问到的肯定小于4GB，一般情况是3.2GB左右。假如说地址总线位数没有32位，比如说是20位，那么CPU能够寻址到1MB的物理地址空间，此时操作系统即使能支持4GB的逻辑地址空间并且假设内存条是4GB的，能够被用户访问到的空间不会大于1MB（当然此处不考虑虚拟内存技术），所以用户能够访问到的最大内存空间是由硬件和操作系统两者共同决定的，两者都有制约关系。\n\n#### 于64位的操作系统\n其逻辑地址编码采用的地址位数是40位，能够最大支持1T的逻辑地址空间。考虑一种情况，假如CPU是64位的，地址总线位数是40位，操作系统也是64位的，逻辑地址编码采用的地址位数也是40位，内存条大小是64GB，那么是不是内存条的64GB全部都能被利用了呢？答案是不一定，因为这里面还要考虑一个因素就是内存控制器，内存控制器位于北桥之内（现在基本都是放在CPU里面了），内存控制器的实际连接内存的地址线决定了可以支持的内存容量，也就是说内存控制器与内存槽实际连接的地址线如果没有40位的话，是无法完全利用64GB的内存条的存储空间的。当然对于内存控制器这个问题几乎可以不用考虑，因为现在大多数的内存控制器至少都采用的是40位地址总线。\n\n#### 总结\n对于以上所述，我进行一下简单的总结：\n\n一个计算机，它的内存访问能力是由硬件和软件共同决定的。硬件层面就指 CPU 的寻址能力，也就是地址总线的个数。软件层面，指的就是操作系统。实际上我们（进程）在进行内存访问的时候，访问的都是逻辑地址，而逻辑地址是由操作系统提供的。对于 32 位的操作系统，其逻辑地址编码采用的地址位数是 32 位，那么操作系统所提供的逻辑地址寻址范围就是 4GB。从这个方面来说，纵使你的 CPU 实际寻址能力为 2 的 64 次方，由于操作系统只提供 4GB 的逻辑地址，那 CPU 透过操作系统所能访问到的内存大小也就只有4GB了。\n\n对与上述总结，我还有一个简单的补充：\n\n> 在和我的大神小伙伴讨论的时候，他对于“为什么 64 位 CPU 装载 32 位操作系统，它的寻址能力还是 4GB”这个问题的解答，只说了一句话：“32 位操作系统没有对应 64 位的寻址指令”。在细细品味之后，觉得颇有道理，我对于这句话的浅显理解是：32 位操作系统没有对应 64 位的寻址指令，所以它不能提供 4GB 以上的逻辑地址，所以 64 位 CPU 透过 32 位操作系统，它的寻址能力依旧是 4GB。\n\n参考阅读\n维基百科：[64位](https://zh.wikipedia.org/wiki/64%E4%BD%8D%E5%85%83)\n[32位系统最大只能支持4GB内存之由来](https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html)\n--------------------- \n作者：珩翊 \n来源：CSDN \n原文：https://blog.csdn.net/championhengyi/article/details/80458060 \n版权声明：本文为博主原创文章，转载请附上博文链接！\n');
INSERT INTO `blog_content` VALUES (74, '#归纳：\n|编码|大小|支持语言|\n|:--:|:--:|:--:|\n|ASCII|	1个字节|英文|\n|Unicode|2个字节（生僻字4个）|	所有语言|\n|UTF-8|	1-6个字节，英文字母1个字节，汉字3个字节，生僻字4-6个字节|所有语言|\n###具体解释：\n最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。\n\n但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。\n\n你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。\n\n因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。\n\nUnicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。\n\n新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。\n\n所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。\n\nUTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。\n\n### 字符集与字符编码：\n1. 字符集：\n字符集只是一个规则集合的名字，\n字符集 =字库表（characterrepertoire）、编码字符集（coded character set）、字符编码（character encoding form）。\n\n2. 字库表：\n字库表是一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。\n\n3. 编码字符集：（简称字符集，如Unicode、ASCII）\n编码字符集，用一个编码值code point来表示一个字符（即该字符在子库表中的位置），这个值称为字符对应于编码字符集（如：Unicode、ASCII）的序号。\n\n4. 字符编码：\n字符编码，是编码字符集和实际存储数值之间的转换关系。字符，是根据字符编码方案转换为一个二进制数值存储在计算机中的。\n所以，字符编码是定义在字符集上的映射规则。（字符-------->计算机中的实际存储值）\n\n \n\n> 注意：编码字符集Unicode，有UTF-8、UTF-16、UTF-32等多种字符编码\n');
INSERT INTO `blog_content` VALUES (76, '> 关于事务与锁的解释在很多博客中都很详细了，这里大致记下一些简要内容（方便以后复习时对照思考），重点是操作案例，以表现事务与锁的操作的具体样例！\n很多都是我自己的理解，有错望指出！\n参考：[mysql的锁（行锁、表锁）](http://www.cnblogs.com/chenqionghe/p/4845693.html)\n\n# 1. 锁\n### 1.1 锁的分类\n#### 按锁的粒度分类\n  - 行锁：即在数据行加锁\n    **优点**：尽可能的减低锁的粒度，降低了锁冲突发生的概率，提高并发度。\n    **缺点**：开销大，加锁慢，可能会出现死锁。\n> 注意： 行锁是针对索引的，加上行锁是在针对索引加锁，\n  - 表锁：对表加锁\n    **优点**：开销小，加锁和释放锁快，对表加锁可以很好避免了死锁问题。\n    **缺点**：锁的粒度太大，读取少数数据行也要锁定整张表，降低了并发度\n> 可是我疑惑为什么加表锁能避免死锁，当a事务访问A表时，后续还要访问B表；事务b访问B表时要访问a表，这不就死锁了吗？？？\n经查询，有知乎伙伴说，获取和释放锁的开销很小，可能事务一开始就将所有涉及的表都加上表锁，这样就不会出现死锁了！这好像才说得通！事实就是如此，如果一个事务真的涉及多张表，很容易产生死锁，所以最好将多张表一次性加上表锁。\n- 页锁\n略TODO\n\n#### 按封锁类型分类\n  - S锁（共享锁）：也可称为‘读锁’，一事务在某资源获取了S锁，则该事物只能读取该资源，不可修改，其他事务可以在此资源上获取S锁，实现同样操作。但不能获取该资源的X锁。\n  - X锁（互斥锁）：也可称为‘写锁’，一事务在某资源获取了X锁，则该事务可以对其进行读写操作，其他事务不能获取该资源的S锁和X锁。\n> 此外：mysql还是有意向锁，有数据库自动生成，不需要用户干预，这里了解下。顾名思义，意向锁即具有加某种锁的意向，所以也分为S和X，名为IS（intention S）和IX。意向锁都是表锁。\n- IX：事务要给某行记录加互斥锁，要先获得该表的意向锁IX。\n- IS：事务要给某行记录加共享锁，要先获取该表的意向锁IS。\n其兼容性如下表：\n\n|锁类型|S|X|IS|IX|\n|:---:|:---:|:---:|:---:|:---:|\n|S|兼容|冲突|兼容|冲突|\n|X|冲突|冲突|冲突|冲突|\n|IS|兼容|冲突|兼容|兼容|\n|IX|冲突|冲突|兼容|兼容|\n> 1. 如果某事务要对条记录加锁，若与当前锁兼容则获取该锁，否则就要等待锁的释放。\n> 2. 对于sql，只有在 **update**、 **delete**、 **insert**会给所涉及的数据项添加X锁，对于select，数据库不会加锁。\n> 3. 当然我们可以显式地加上S锁和X锁：\n```sql\n select * from test  where ... lock in share mode; \n```\n> 上述形式的使用场景可以用在某事务读取某数据后防止其他事务**update**和**delete**该数据，其他事务需要修改的话就要先加X锁，但因为该数据已加上S锁，所以需要等待。（**即防止可重复读问题**，但注意，如果本事务也对数据进行修改操作，就会发生死锁！）\n```sql\n select * from test where ... for update; \n```\n#### 间隙锁\n当我们使用的是范围查找而不是等值条件，并且还要加上共享锁和互斥锁时，mysql会将所在范围内的记录都加上锁，在这个范围内不存在的记录，称为**间隙**，也会加上锁。比如：\n```select * from where id > 100 for update;```这时候除了表中大于100的记录被加上锁，不存在的间隙也会被加上锁， 比如同时另外一个事务想插入一个id=101的记录，会插入失败。\n这就让我想到了之前项目中为了保证注册时用户名的唯一性，必须先查找一遍以确定是否已经存在即将注册的用户名，然后再插入。可是极有可能再查找完确定不存在并返回结果的同时，另外一个事务突然插入同一个用户名，注册就会失败。这种现象即是**幻读**，这个就可以用间隙锁解决。\n虽然间隙锁避免了我们为避免幻读而使事务隔离级别为**序列化**造成数据库的并发性严重降低的后果，但也要注意不要锁太大范围，即太大间隙。尽量优化业务逻辑，使用等值连接代替范围查找。\n### 1.2 锁操作示例\n> 示例主要是想通过实际操作对前面理论进行验证，顺序按照前面所述顺序来！\n\n#### 1.2.1 列锁\n**①列锁是针对索引的。 ②select不会加锁，所以不用获得锁**\n创建没有索引的表balance，然后插入两条数据。\n```sql\ncreate table balance (\nid int,\nbalance int);\n\ninsert into balance values(1, 500),(2,300);\n```\n打开两个事务：\n![](https://upload-images.jianshu.io/upload_images/9031347-e796e0c0b18f2877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 可以看到，第一个事务显式在id=1记录上加上行写锁，id=2也被锁住了，所以id没有索引时，会直接在表上加锁。\n下面试试有索引的情况：\n```sql\ncreate index id_index on balance(id);\n```\n![](https://upload-images.jianshu.io/upload_images/9031347-ec7a4c94de1d7598.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 题外话，如果同时查询了一个索引一个非索引，比如：\n```select * from balance where id = 1 and balance = 500 for update;```\n第二行记录 1，300还会锁吗？答案是会的，因为上面的sql命中了id=1的索引，只在索引1上加锁，第二行索引也为一，所以会加上。\n\n**③update，insert，delete自动加写锁，索引规则与前面相同。**\n![第一个事务只要提交，第二个事务就能出现查询结果！](https://upload-images.jianshu.io/upload_images/9031347-0e4948a1aca58093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 1.2.2 表锁\nTODO\n\n#### 1.2.3 间隙锁\n![间隙锁也符合索引那套规则，加锁不在索引，即锁表](https://upload-images.jianshu.io/upload_images/9031347-0dca43cbfb626507.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n再次创建索引：```create index id_index on balance(id);```\n![对id>1的间隙加锁，1能访问，2不能](https://upload-images.jianshu.io/upload_images/9031347-f8d7904ccc35508f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n现在插入一条id=3的记录```insert into balance values(3, 1000)```\n![直接在加不是间隙锁的事务中添加，被阻塞，因为3>1，在间隙中](https://upload-images.jianshu.io/upload_images/9031347-42984aa3e9426e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![](https://upload-images.jianshu.io/upload_images/9031347-ab045d941e1f6c74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 虽然添加数据成功，但第二个事务普通的select都访问不到，这不是锁的缘故，而是因为前面提到过的MVCC的原因（下面会提到），后面的事务因为访问的是快照中的数据，此时快照中的数据并没有将新添加的数据3加入，所以访问不到！添加一方提交后，另一方才能访问到，这避免了即将提到的脏读。\n![没有间隙锁，普通的select（不与任何锁冲突）也无法访问到](https://upload-images.jianshu.io/upload_images/9031347-ae99f2d438de6f83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>加上间隙锁后，别的事务也无法添加指定范围内新的数据，这即避免了幻读。\n\n# 2. 事务\n### 2.1 事务的属性ACID\n- A（Atomicity），原子性，即一个事务的所有操作要么全部执行，要么都不执行，就像一个原子操作一样。\n- C（Consistency），一致性，即事务执行前与执行后数据内在的逻辑始终是成立的。比如转账前与转账后两人存款的总和始终不变。\n- I（Isolation），隔离性，即数据库提供一些隔离机制，确定能多事务能一定程度地独立运行，互不干扰，意味着事务运行的中间状态是不会被别的事务看到的。\n- D（Durable），持久性，即事务对数据造成的影响是永久性的，即是出现故障都能保证。\n###2.2 事务并发带来的一些问题\n- 更新丢失：即两个事务对一个数据更新，一个事务覆盖另一个事务的问题。\n- 脏读：即一个事务读取了另一个事务为提交的更改。\n- 不可重复读：当一个事务访问某条数据后，另一事务更改了这条数据，再次访问，两次是不一样的数据。不可重复读。这个更改只涉及另一事务的Update和Delete操作。\n- 幻读：当一个事务以某种条件读取数据，另一事物插入了满足条件的数据，再次访问多出了之前没有访问的数据。重点是另一事物是insert的操作！\n> 追加：不可重复读和幻读的区别还是有些模糊，有很多博客都是像上面那样说，但有人说不可重复读比较偏向于两次读，而幻读则偏向于一读一写，比如某事务先select判断某数据字段并不存在，但当添加这一字段的数据时又说有冲突，可是再次读取还是没有这一字段（MVCC）。这时候可能是其他事务在这一事务读取之后添加了这一字段，此为幻读。理解自： [mysql 幻读的详解、实例及解决办法](https://segmentfault.com/a/1190000016566788)\n\n### 2.3 事务的隔离级别\n\n- READ_UNCOMMITED：读未提交\n- READ_COMMITTED：读提交\n- REPEATABLE_READ：可重复读\n可重复读的级别下也是可以防止幻读的，比如如果数据存在，则在此数据上加上X锁，如果数据不存在就是用next-key锁，放置其他事务添加或操作指定数据。\n- SERIALIZABLE：串行化\n串行化的原理就是将所有读取的数据都加上X锁，一旦读取其他事务就无法读取和操作。这虽保证了事务并发的安全性，但也使得并发效率大大降低。\n\n||脏读|不可重复读|幻读|\n|:---:|:---:|:---:|:---:|\n|读提交|解决|||\n|可重复读|解决|解决||\n|串行化|解决|解决|解决|\n> 参考的文章中说：\n在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。\n“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。\n一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。这势必会造成性能上的不好的影响。----悲观锁\n另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。----乐观锁\n### 2.4 事务操作示例\n####2.4.1 并发访问的问题实现\n- 丢失更新\n略\n- 脏读\n因为mysql默认隔离级别是可重复读：\n![](https://upload-images.jianshu.io/upload_images/9031347-e5b00b13c2b3206b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n所以我们要更改其隔离级别。\n```SQL\nselect @@transaction_isolation;\nSET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL\n {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}\n```\n![](https://upload-images.jianshu.io/upload_images/9031347-7d081d6b6339bfa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n修改为读未提交，后打开自动提交。\n![我们这里已经打开了](https://upload-images.jianshu.io/upload_images/9031347-f203fdd84c38e06b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 可以使用```set auto_commit=0（1关闭）```将其打开。\n\n![可以看到第二个事务读取到了第一个事务未提交的脏数据](https://upload-images.jianshu.io/upload_images/9031347-679fe0519355a38f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 第一个事务如果撤回，另一个事务就读取了完全错误的数据，这就是脏读。\n- 不可重复读\n略\n- 幻读\n略\n> 感觉挺简单的，懒得实现了。\n\n#### 2.4.2事务的隔离级别\n懂的，操作简单就不浪费时间了。\n');
INSERT INTO `blog_content` VALUES (77, '1. 脏读 ：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。\n\n2. 不可重复读 ：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不 可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果 只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。\n\n3. 幻读 : 是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。 如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。\n\n###补充 : 基于元数据的 Spring 声明性事务 :\n\n#####Isolation 属性一共支持五种事务设置，具体介绍如下：\n\n- 使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别 .\n\n- READ_UNCOMMITTED 会出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 )\n\n- READ_COMMITTED  会出现不可重复读、幻读问题（锁定正在读取的行）\n\n- REPEATABLE_READ 会出幻读（锁定所读取的所有行）\n\n- SERIALIZABLE 保证所有的情况不会发生（锁表）\n\n#####不可重复读的重点是修改 : \n同样的条件 ,   你读取过的数据 ,   再次读取出来发现值不一样了 \n#####幻读的重点在于新增或者删除 \n同样的条件 ,   第 1 次和第 2 次读出来的记录数不一样\n\n> 转自 https://www.cnblogs.com/phoebus0501/archive/2011/02/28/1966709.htm\n');
INSERT INTO `blog_content` VALUES (78, '权限两个字，一个**权力**，一个**限制**。在软件领域通俗的解释就是**哪些人**可以对**哪些资源**做**哪些操作**。在SQL Server中，”哪些人”，“哪些资源”,”哪些操作”则分别对应SQL Server中的三个对象，分别为主体(Principals),安全对象(Securables)和权限(Permissions)，而权力和限制则是对应了SQL Server中的GRENT和DENY。对于主体，安全对象和权限的初步理解，见下图：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-d2c4e8d9ed7719cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 主体\n\n“主体”是可以请求 SQL Server 资源的实体。主体可以是个体，组或者进程。主体可以按照作用范围被分为三类:\n\n*   Windows级别主体：包括**Windows 域登录名**和**Windows 本地登录名**。\n*   服务器级别主体：包括**服务器登录名**和**服务器角色**。\n*   数据库级别主体：包括**数据库用户、数据库角色、固定数据库角色**以及**应用程序角色**。\n\n可以看到主体包括**登录名**以及**角色**。\n\n### 角色\n\n角色可以看成是权限的集合体，为了方便权限管理，可以把一些常用权限赋予角色，然后再把角色赋予相关用户，则这些用户就继承了橘色中的所有权限。一般情况下，数据库会内置一些角色，用户也可以创建自定义角色。对角色进行权限管理的方式与对用户进行权限管理的方式是相同的。\n  角色在SQL Server中被分为三类，分别为:\n\n*   内置角色----这类角色在服务器安装时已经默认存在，其权限是固定的，并且不能被删除\n*   用户自定义角色----这类角色由用户按照需求自定义创建\n*   应用程序角色----这类特殊角色用于管理应用程序的数据访问\n\n角色也分为两个方面：\n\n*   服务器级别的角色，用于数据库服务器方面的控制权限\n*   数据库级别的角色，用于数据库中数据的控制权限。\n\n#### （1）服务器级别的角色\n\n服务器级角色的权限作用域为服务器范围。例如创建、修改、删除数据库，管理磁盘文件，添加或删除数据库连接等等，都是需要服务器上的权限才能进行操作。\n  固定服务器角色具有一组固定的权限，并且适用于整个服务器范围。 它们专门用于管理 SQL Server，且不能更改分配给它们的权限。 可以在数据库中不存在用户帐户的情况下向固定服务器角色分配登录。\n  **服务器级别的对象，只能包含登录名。**定义了服务器角色，你定义的登陆用户就有了相应的执行权限。先来看一下服务器级别的固定角色：\n\n| 服务器角色 | 含义 |\n| --- | --- |\n| sysadmin | 可以在服务器上执行任何活动 |\n| serveradmin | 可以更改服务器范围的配置选项和关闭服务器 |\n| securityadmin | 管理和审核登录用户。具有 GRANT、DENY 和 REVOKE 服务器和数据库级别的权限。此外，还可以重置 SQL Server 登录名的密码 |\n| processadmin | 管理SQL Server运行的进程 |\n| setupadmin | 可以使用 T-SQL 语句添加和删除连接服务器，并可以执行某些系统存储过程（如 sp_serveroption） |\n| bulkadmin | 可以运行 BULK INSERT 语句 |\n| diskadmin | 用于管理磁盘文件 |\n| **dbcreator** | 可以创建、更改、删除和还原任何数据库 |\n| public | public角色不同于其它角色在于其权限可以被修改，每个 SQL Server 登录名都属于 public 服务器角色。无法将用户、角色或组指派给它，因为默认情况下它属于该角色，且public不能被删除 |\n\n#### （2）数据库级别的角色\n\n数据库级角色的权限作用域为数据库范围。例如可以访问哪个数据库，可以访问哪个数据库中的哪些数据表、哪些视图、哪些存储过程等等，都需要数据库上的权限才能进行操作。\n  SQL Server存在两种类型的数据库级角色：数据库中预定义的“固定数据库角色”和可以创建的“用户定义的数据库角色”。\n  固定数据库角色是SQL Server预定义的数据库角色，具有数据库级别的管理权限，并且存在于每个数据库中。**db_owner **数据库角色的成员可以管理固定数据库角色成员身份。自定义数据库角色是当固定数据库角色不能满足要求时，可以自定义数据库角色。\n  **数据库级别的对象，只能包含数据库用户名。**先来看一下数据库级别的固定角色：\n\n| 数据库角色 | 含义 |\n| --- | --- |\n| db_owner | 可以执行数据库中技术所有动作的用户，执行所有的配置活动和维护活动 |\n| db_securityadmin | 管理数据库安全，可以修改角色成员身份和管理权限。向此角色中添加主体可能会导致意外的权限升级 |\n| db_accessadmin | 可以为 Windows 登录名、Windows 组和 SQL Server 登录名添加或删除数据库访问权限 |\n| db_backupoperator | 可以备份数据库 |\n| db_ddladmin | 可以在数据库中运行任何数据定义语言 (DDL) 命令 |\n| db_datawriter | 可以在所有用户表中添加、删除或更改数据 |\n| db_datareader | 可以从所有用户表中读取所有数据 |\n| db_denydatawriter | 不能添加、修改或删除数据库内用户表中的任何数据 |\n| db_denydatareader | 不能读取数据库内用户表中的任何数据 |\n| public | public角色不同于其它角色在于其权限可以被修改，每个数据库用户、角色或组都属于public数据库角色。无法将用户、角色或组指派给它，因为默认情况下它属于该角色，且public不能被删除 |\n\n### 登录账号和数据库用户\n\nSQL Server的服务器和数据库是两个层次的概念，SQL Server的用户也分为两种，一种是服务器登陆账号，另一种是数据库用户。\n  一个人要操作SQL Server数据库，首先要为其创建服务器登陆账号，使得他可以登录到服务器上，然后还要在要操作的数据库上创建和这个登陆账号对应的数据库用户。\n  可以给登陆账号赋予相应权限，使得这个账号可以执行指定的管理服务器的任务。也可以给数据库用户赋予相应权限，使得这个数据库用户可以在这个数据库中执行指定的操作。\n  **服务器登陆账号**分为为Windows验证及SQL Server验证两种。\n\n*   Windows身份验证模式：把Windows的操作系统用户添加为SQL Server服务器登陆账号，SQL Server并不参与验证。SQL Server完全相信Windows的验证结果，所以用此方式登录SQL Server时并不需要提供密码。\n*   SQL Server和Windows身份验证模式：这种模式即允许由Windows来验证主体身份，又允许SQL Server来验证主体身份，当由SQL Server验证主体身份时，需要用户名和密码来确认主体身份，和使用什么Windows账户半毛钱关系都没有，是在服务器上创建的另外一种独立账号。\n\n**登录名**\n  登录名是**服务器级别的主体**，但无论是上述哪个层级的主体，因为需要登录到SQL Server实例，所以每一个层级的主体都需要一个与之对应的登录名。对于**Windows级别的主体**来说，Windows用户会映射到登录名。对于**数据库级别的主体**来说，其用户必须映射到登录名中。而登录名可以不映射到数据库用户，如图所示登录名的映射关系：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-94f1908021861d4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n  在图中实例层级的登录名中，我们看到除了自定义添加的用户之外，还有一些由系统添加的登录名。\n\n*   以”##”开头和结尾的用户是SQL Server内部使用的账户，由证书创建，仅供内部系统使用，不应该被删除。\n*   sa 登录名是服务器级的主体。 默认情况下，该登录名是在安装实例时创建的。从 SQL Server 2005 开始，sa 的默认数据库为“master”。 sa账户可以认为是超级管理员用户，拥有一切特权，可以在SQL Server中为所欲为，并且不能够被删除。因此sa作为**分配权限的起点**（也就是SA账户在最开始时给予了其他主体对于安全对象的权限）。因此对于Sa的密码要设置的尽可能复杂，否则Sa登录名被盗取后果不堪设想。\n*   NT AUTHORITYNETWORK SERVICE和NT AUTHORITYSYSTEM账户是和启动SQL Server这个Windows服务的账户有关，如果使用本地登录账户或是网络账户启动SQL Server服务，请不要删除这两个账户。\n*   BUILDINAdministrator账户是与本地管理员组关联的登录名，默认属于sysadmin角色。这个账户使得任何属于本地管理员的账户都可以获得对SQL Server的完全控制权。\n\n**数据库用户**\n  数据库用户是数据库级别的主体,被用于访问数据库层面的对象。每一个数据库用户都必须要一个与之对用的登录名。数据库用户的信息存在数据库中，而登录名存在实例级别的Master数据库中(但SQL SERVER2012的Contained Database允许将登录名也存在数据库级别)。通常来说，数据库层级的用户可以和映射的登录名不一致，但由于这种做法会引起混淆，因此并不推荐，如下图所示。\n\n![](https://upload-images.jianshu.io/upload_images/9031347-83bd1b1a4c56e397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n  默认情况下，每个数据库都带有4个内置用户，如下图所示：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-5d985552aa97a03c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n*   dbo用户：dbo用户是Database Owner的简称，如果说SA是实例级别的老大，那DBO就是数据库级别的老大，是数据库的拥有者。这个用户也同样不能被删除，登录名sa自动映射为数据库用户dbo。每一个表创建时如果没有指定Schema，则默认在dbo这个schema下。\n*   guest 用户：guest用户是一个来宾账户，这个账户允许登录名没有映射到数据库用户的情况下访问数据库。默认情况下guest用户是不启用的，但不能删除。可通过撤消该用户的 CONNECT 权限将其禁用。\n\n```\n--允许guest用户连接权限\nGRANT CONNECT TO guest\n--收回guest的连接权限\nREVOKE CONNECT TO guest\n\n```\n\n*   INFORMATION_SCHEMA 和 sys：它们都作为用户出现在目录视图中。 这两个实体是 SQL Server 所必需的。 它们不是主体，不能修改或删除它们。\n\n![](https://upload-images.jianshu.io/upload_images/9031347-fa4d054886780974.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 安全对象\n\n安全对象是SQL Server数据库引擎授权系统控制对其访问的资源。安全对象分别属于3个层次：服务器、数据库、架构。\n  不同的范围包含不同的安全对象，详见下图。\n\n![](https://upload-images.jianshu.io/upload_images/9031347-9ab97deb6a303273.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 架构(schema)及其管理\n\n在SQL Server 2000中的构架是和用户绑定的，比如我新建用户Jack，SQL Server自动分配一个叫Jack构架，用户Jack并不能改变这个选项，而由Jack所建的任何对象都在Jack之下。比如新建一个表，则为Jack.Table1。当Jack如果离职时，这对管理来说简直是一场噩梦。\n  从SQL Server2005开始，数据库用户不再等同于架构，允许用户和构架分离。而在Oracle中，用户与模式还是等同的(在Oracle中，schema一般翻译为模式)。所以以往 SQL Server 内的对象命名是“服务器.数据库.用户名.对象”，但如今的对象命名改为“服务器.数据库.Schema.对象”\n  架构是与创建它的数据库用户无关的命名空间，也可以说，架构是数据库对象的容器，独立于创建它们的数据库用户而存在。架构有一下特点：\n\n*   多个数据库用户可以共享一个默认的架构；\n*   单个架构可以包含多个数据库用户拥有的对象；\n*   架构的所有权和架构内的安全对象可以转移；\n*   对象可以在不同的架构之间移动；\n*   可以删除数据库用户，而不删除相应架构中的对象。\n\n**架构所有者和权限**\n  通过用户架构分离，可实现管理数据库对象权限的更大灵活性。，因为对象不再绑定到用户账号上，所以你根本不用担心当一个账号被删除时需要变换对象的拥有者。\n  默认情况下，当开发人员创建了一个对象时，该对象并不属于开发人员而属于一个数据库架构。\n  任何数据库主体都可以拥有架构，并且一个主体可拥有多个架构。每个架构都有其所有者，但是所有者和架构名是不绑定的。所以当一个用户拥有一个架构，并且这个用户必须从数据库中删除时，可以不用破坏任何代码而仅仅是将架构的所有者变一下。\n  可以对架构应用安全规则，安全规则将由架构中的所有对象继承。 如果设置了对架构的访问权限，则当新对象添加到架构时，新对象会自动应用这些权限。注意：**用户不从架构继承权限，架构权限由架构中包含的数据库对象继承。**\n\n**内置架构**\n  SQL Server创建了十个预定义的架构，它们与内置数据库用户和角色具有相同的名称。这些架构主要用于向后兼容性。如果您不需要与固定数据库角色具有相同名称的架构，则可以删除它们。您不能删除下列架构：\n\n*   **dbo**：dbo 是新创建的数据库的默认架构。 dbo 架构由 dbo 用户帐户拥有。 默认情况下，使用 CREATE USER命令创建的用户的默认架构为 dbo，但是分配了 dbo 架构的用户不继承 dbo 用户帐户的权限。\n*   **guest**\n*   **sys**：为系统对象而保留的。\n*   **INFORMATION_SCHEMA**：为系统对象而保留的。\n    如果从模型数据库中删除这些架构，它们将不会显示在新数据库中。\n\n作者：水桶的魔法\n链接：https://www.jianshu.com/p/1a5a9b7e64c1\n來源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。\n');
INSERT INTO `blog_content` VALUES (79, '> 题目的详细描述：给出原乱序数组和去除\n');
INSERT INTO `blog_content` VALUES (80, '> 很是激动，离开ACM一年后还能找回当时ac时激动的感觉。虽然挺简单的一题，在苦思冥想之后想到左右子树分治采用递归解法。一次Compilation Error后就ac了。就算是重启刷题的开门红吧。\n\n### 这是原题：[ZOJ-1944](https://cn.vjudge.net/problem/29309/origin)\n\n答案：\n```c++\n//\n// Created by PC on 2019/2/28.\n// 通过前序遍历和中序遍历字母树获得的字符串获取后序遍历的字符串！\n// 深思熟虑后觉得应该用递归\n#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<stack>\nusing namespace std;\n// DBACEGF ABCDEFG\nstack<char> post;\n\n//先找出每个子树的根节点，然后获取其左子树和右子树\nvoid separateSubTree(char preOrder[], char inOrder[]) {\n\n    // 这是递归的判断\n    if(strlen(preOrder) == 0) {\n        return;\n    }\n    post.push(preOrder[0]);\n\n    // 根节点就是preOrder的第一个字母，根据根节点从inOrder中分成左右子树\n    // 这里的教训惨重啊，字符数组不赋初值，就会被自动赋一些乱七八糟的值，影响后面的结果！\n    char inLeft[20] = \"\", inRight[20] = \"\";\n    char preLeft[20] = \"\", preRight[20] = \"\";\n    char* middle = strchr(inOrder, preOrder[0]);\n\n    // 左子树\n    memcpy(inLeft, inOrder, middle - inOrder);\n\n    // 右子树\n    memcpy(inRight, middle + 1, strlen(inOrder) - 1 - (middle - inOrder));\n\n    //前面都是中序遍历的左右子树！下面获取前序遍历的左右子树，获取后直接再调用本方法获取就行了\n    // 左子树\n    memcpy(preLeft, preOrder + 1, strlen(inLeft));\n\n    // 右子树\n    memcpy(preRight, preOrder + strlen(inLeft) + 1, strlen(inRight));\n\n    separateSubTree(preRight, inRight);\n    separateSubTree(preLeft, inLeft);\n}\n\nint main() {\n    char preOrder[27], inOrder[27];\n    while (scanf(\"%s %s\", preOrder, inOrder) != EOF) {\n        // int postOrder[27];\n        separateSubTree(preOrder, inOrder);\n        //cout << post.size() << endl;\n        while (!post.empty()) {\n            cout << post.top();\n            post.pop();\n        }\n        cout << endl;\n    }\n    return 0;\n}\n```\n');
INSERT INTO `blog_content` VALUES (81, '> 重刷HDU，看到以前一个关于余数的题目，觉得相关余数的一些性质定理是时候总结下了！\n\n# 1. 概念：同余\n> 若a , b除以c的余数相等，则a与b相对于除数c是同余的，即a≡ b(mod c)！\n\n# 2.  同余的两个数的差能整除除数！\n > 如 10 % 3 = 1， 7 % 3 = 1，10≡ 7 (mod 3)则（10 - 7 ）% 3 = 0.\n\n# 3. 余数可加性（可减性同）\n两个数对于某个除数的余数和**对此除数的余数**等于两个数的和对此除数的余数！\n> 如 （11 % 3  + 8 % 3 ）% 3= （11 + 8） % 3\n题目：[hdu1021](http://acm.hdu.edu.cn/showproblem.php?pid=1021)\n\n# 4. 余数可乘性\n两个数对某个除数的余的乘积**对此除数的余数**等于两个数的乘积对此除数的乘积对此！\n> 如 [ （11%3 ）* （8%3 ） ]  % 3 = （11 * 8）%3\n题目： [hdu1005](http://acm.hdu.edu.cn/showproblem.php?pid=1005)\n\n# 5. 余数乘方性\n> 如果a与b除以m的余数相同，那么a^n与b^n除以m的余数也相同，但不一定等于原余数．\n例如：3，7除以4的余数都是3，可以算得3^2和7^2除以4的余数都等于1，它们的余数相等但不一定等于3.\n');
INSERT INTO `blog_content` VALUES (83, '```工具intellij，墙裂推荐。作为一个jetbrains的铁忠粉，能用上的我几乎都下载了，而且学生认证很简单，次日就可用认证完成。```\n\n###创建web项目\n1. 首先用intellij先新建一个project:\n\n![](https://upload-images.jianshu.io/upload_images/9031347-4795817501705735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 再src中新建一个servlet，代码：\n\n```java\npackage util;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n@WebServlet(name = \"MySer\")\npublic class MySer extends HttpServlet {\n    protected void doPost(HttpServletRequest request,\n                          HttpServletResponse response)\n            throws ServletException, IOException {\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\");\n        out.println(\"<HTML>\");out.println(\"  <HEAD><TITLE>A Servlet</TITLE></HEAD>\");\n        out.println(\"  <BODY>\");out.print(\"    This is \");\n        out.print(this.getClass());out.println(\", using the GET method\");\n        out.println(\"  </BODY>\");out.println(\"</HTML>\");out.flush();out.close();\n    }\n\n    protected void doGet(HttpServletRequest request,\n                         HttpServletResponse response)\n            throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n\n```\n\n3. 在../web/WEB-INFO/web.xml中对Servlet进行注册：\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <servlet>\n        <servlet-name>MySer</servlet-name>\n        <servlet-class>util.MySer</servlet-class>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>MySer</servlet-name>\n        <url-pattern>/hello</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\n>servlet-name即Servlet的名字，servlet-class可以写 包名.类名格式，没有包就可以不写，url-pattern在浏览器中访问时作为访问Servlet的地址后缀，可写多个。\n\n>比如这里的是/hello，那么访问时就是http://localhost:8080/项目名/hello，即可访问到Servlet。\n\n4. index.jsp文件中对servlet提交请求即可，代码：\n\n```html\n<body>\n    <form action=\"/hello\" method=\"post\">\n       <input type=\"submit\" value=\"提交\">\n    </form>\n  </body>\n```\n\n![登录](https://upload-images.jianshu.io/upload_images/9031347-8f300b7393a5ec7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###通过ServletConfig获取Servlet的初始化参数\n\n如果给Servlet配置了初始化函数的话，tomcat会在创建一个Servlet对象时将初始化参数封装进一个ServletConfig里并通过Servlet中的init（）方法传进去\n#####实例\n1. 在web.xml中Servlet中加上\n\n```\n<servlet>\n        <servlet-name>MySer</servlet-name>\n        <servlet-class>util.MySer</servlet-class>\n        <init-param>\n            <param-name>name</param-name>\n            <param-value>hsw</param-value>\n        </init-param>\n        <init-param>\n            <param-name>id</param-name>\n            <param-value>987654321</param-value>\n        </init-param>\n        <init-param>\n            <param-name>password</param-name>\n            <param-value>123456789</param-value>\n        </init-param>\n    </servlet>\n\n```\n\n2. 就可以在Servlet获取即可：\n\n```\npublic void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        response.setContentType(\"UTF-8\");\n        PrintWriter out = response.getWriter();\n\n        Enumeration<String> names = config.getInitParameterNames();\n\n        while (names.hasMoreElements()) {\n            String name = names.nextElement();\n            out.println(name + \": \" + config.getInitParameter(name));\n        }\n\n    }\n```\n![](https://upload-images.jianshu.io/upload_images/9031347-76d3ebcb3ea4732e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### ServletContext对象\n\nweb容器启动时会给每个web程序创建一个ServletContext对象，其代表的即是当前的web应用。\n\nweb在ServletConfig中维护了ServletContext对象，可以通过ServletConfig.getServletContext()获取该对象，也能用this.getServletContext()。\n\n因为一个web应用中所有Servlet共享一个ServletContext，所以ServletCopntext可以通过ServletContext实现通信。\n\n创建一个新的Servlet MySer2，doPost代码携程这个样子\n\n```\npublic class MySer2 extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        ServletContext context = this.getServletContext();\n        String name = (String) context.getAttribute(\"name\");\n        PrintWriter printWriter = response.getWriter();\n        printWriter.println(\"this is Servlet2\");\n        printWriter.println(\"name\" + \" :\" + name  + \"from MySer2\");\n    }\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {}\n}\n\n```\n\n把MySer里未用到的doGet函数作为设定一个属性的方法！\n\n```\npublic void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n\n        ServletContext context = config.getServletContext();\n        context.setAttribute(\"name\", \"何少文\");\n\n        response.setContentType(\"UTF-8\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\");\n        out.println(\"<HTML>\");\n        out.println(\"  <HEAD><TITLE>A Servlet</TITLE></HEAD>\");\n        out.println(\"  <BODY>\");\n        out.println(\"this is Servlet1\");\n        out.println(\"   <form action=\"/hello2\" method=\"post\">\");\n        out.println(\"   <input type=\"submit\" value=\"提交\">\");\n        out.println(\"   </form>\");\n        out.println(\"  </BODY>\");\n        out.println(\"</HTML>\");\n        out.flush();\n        out.close();\n    }\n```\n\nweb代码添加\n\n```\n<servlet>\n        <servlet-name>MySer2</servlet-name>\n        <servlet-class>util.MySer2</servlet-class>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>MySer2</servlet-name>\n        <url-pattern>/hello2</url-pattern>\n    </servlet-mapping>\n```\n\n运行下程序：\n\n![image.png](https://upload-images.jianshu.io/upload_images/9031347-4576ee85e6394e21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n显示index.jap的内容！\n\n点提交，将注册表接入MyServlet，然后就有了MySer中输出的xml代码。\n\n![](https://upload-images.jianshu.io/upload_images/9031347-8a0a31e895c1cb35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击此处的submit\n\n![image.png](https://upload-images.jianshu.io/upload_images/9031347-001081d83528c29c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n就显示了MySer2的内容，这里从ServletConfig获取到了MySer中添加的name属性。\n\n### 获取WEB应用的初始化参数：\n\n在web.xml中web-app中添加\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app version=\"3.0\" >\n    <context-param>\n        <param-name>url</param-name>\n        <param-value>jdbc:mysql://localhost:3306/test</param-value>\n    </context-param>\n</web-app>\n```\n\n然后再Servlet中直接ServletContext.getInitParameter(String name)即可！类似于ServletConfig.getInitParameter(String name);不多赘述。\n\n### 用ServletContext进行请求转发\n\n上课时老师曾拿请假作为例子，拿假条去财务部没用，然后财务部直接吧假条转到学工处理。\n\n这里即某个Servlet处理不了的问题，运用ServletContext请求转发将其转到其他的Servlet处理。看代码。\n\n新建两个类，MySer3，MySer4：\n\n```\npublic class MySer4 extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        PrintWriter out = response.getWriter();\n        out.println(\"这是MySer4！\");\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n    }\n}\n```\n\n```\npublic class MySer3 extends HttpServlet {\n\n    ServletConfig config = null;\n\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        ServletContext context = config.getServletContext();\n        RequestDispatcher dispatcher = context.getRequestDispatcher(\"/hello4\");//这里还是和表单form中action填的是一样的！并不是类名\n        dispatcher.forward(request, response);\n\n    }\n\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        this.config = config;\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n    }\n}\n```\n\n![](https://upload-images.jianshu.io/upload_images/9031347-dd68752c09449a01.gif?imageMogr2/auto-orient/strip) \n运行：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-1e2afc906de2a85e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击提交：\n![](https://upload-images.jianshu.io/upload_images/9031347-c96e4c6349284825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 利用ServletContext获取读取资源文件\n\n**根据资源文件的位置的不同，读取的方式也有不同。可以大致的分为两类：**\n\n1. 在Servlet的context域中读取。2.在非Servlet中读取文件，需要使用类加载器加载！\n\n![](https://upload-images.jianshu.io/upload_images/9031347-dad4ad93f546363f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n可以看到下面的java项目的目录结构可以看出，class有两个输出位置，根据以往java的项目文件格式，可以知道production文件夹下是java的class输出位置  。而针对web程序，工程目录下的src目录被发布到服务器时会映射到/WEB-INF/classes，所以这里可以忽视peoduction的存在，只用WEB-INFO的目录就行（production没试过）\n\n创建几个properties文件\n\n.properties的格式差不多这样\n![](https://upload-images.jianshu.io/upload_images/9031347-c84923d5f0df567a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n新建MySer5：\n\n```\npublic class MySer5 extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        getPro(response);\n        response.getWriter().println(\"<hr/>\");\n        getPro2(response);\n        response.getWriter().println(\"<hr/>\");\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n\n    private void getPro(HttpServletResponse response) throws IOException {\n        //InputStream input = new FileInputStream(new File(\"/WEB-INF/classes/util/pro.properties\"));//这样没用，一定要用下面的语句！\n        InputStream input = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/util/pro.properties\");\n        Properties pro = new Properties();\n        pro.load(input);\n        String name = pro.getProperty(\"name\");\n        String admin = pro.getProperty(\"admin\");\n        String password = pro.getProperty(\"password\");\n        PrintWriter out = response.getWriter();\n        out.println(\"information come from pro1: \");\n        out.println(\"name : \" + name + \", admin :\" + admin + \", password :\" + password);\n    }\n\n    private void getPro2(HttpServletResponse response) throws IOException {\n//这样根本没用：InputStream input = new FileInputStream(new File(\"/out/artifacts/firstServlet_war_exploded/pro2.properties\"));\n        InputStream input = this.getServletContext().getResourceAsStream(\"/pro2.properties\");\n        Properties pro = new Properties();\n        pro.load(input);\n        String name = pro.getProperty(\"name\");\n        String admin = pro.getProperty(\"admin\");\n        String password = pro.getProperty(\"password\");\n        PrintWriter out = response.getWriter();\n        out.println(\"information come from pro2\n\");\n        out.println(\"name : \" + name + \", admin :\" + admin + \", password :\" + password);\n    }\n}\n```\n\n![image.gif](https://upload-images.jianshu.io/upload_images/9031347-7f484aa4bff7f0f5.gif?imageMogr2/auto-orient/strip) \n\n在web中写下Servlet信息。修改表单中的url为/hello5：\n\n运行结果：\n![](https://upload-images.jianshu.io/upload_images/9031347-4a25894b64aaf7c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n目录结构中可以看出web目录下和映射文件夹里面的内容大致相似。\n\n所以根据以上代码即可推导出所有在ServletContext域中的所有配置文件的路径。\n\n然后就是非Servlet域外的文件！这需要类装载器来读取。\n\n不多说，自己看[点击打开链接](https://www.cnblogs.com/tech-bird/p/3843832.html)\n\n作为一个初学者，带着做笔记的想法写完了这篇博客，所以一定会漏洞百出，欢迎大家纠错！\n![美丽的十元](https://upload-images.jianshu.io/upload_images/9031347-649eaae70c5d14da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n');
INSERT INTO `blog_content` VALUES (84, '以下内容为网页摘抄\n\n###URL和URI：\n\n**作者：daixinye**\n**链接：https://www.zhihu.com/question/21950864/answer/154309494**\n**来源：知乎**\n**著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。**\n\n统一资源标志符URI就是在某一规则下能把一个资源独一无二地标识出来。\n拿人做例子，假设这个世界上所有人的名字都不能重复，那么名字就是URI的一个实例，通过名字这个字符串就可以标识出唯一的一个人。\n现实当中名字当然是会重复的，所以身份证号才是URI，通过身份证号能让我们能且仅能确定一个人。\n那统一资源定位符URL是什么呢。也拿人做例子然后跟HTTP的URL做类比，就可以有：\n\n动物住址协议://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人\n\n可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。URL是以描述人的位置来唯一确定一个人的。\n在上文我们用身份证号也可以唯一确定一个人。对于这个在杭州的张三，我们也可以用：\n\n身份证号：[123456789](tel:123456789)\n\n来标识他。\n所以不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是URl的一种实现，而URL就是用定位的方式实现的URI。\n\n回到Web上，假设所有的Html文档都有唯一的编号，记作html:xxxxx，xxxxx是一串数字，即Html文档的身份证号码，这个能唯一标识一个Html文档，那么这个号码就是一个URI。\n而URL则通过描述是哪个主机上哪个路径上的文件来唯一确定一个资源，也就是定位的方式来实现的URI。\n对于现在网址我更倾向于叫它URL，毕竟它提供了资源的位置信息，如果有一天网址通过号码来标识变成了[http://741236985.html](https://link.zhihu.com/?target=http%3A//741236985.html)，那感觉叫成URI更为合适，不过这样子的话还得想办法找到这个资源咯…\n\n## response.sendRedirect() 和 dispatcher.forward(request,response)\n\nJava Web开发中，采用MVC模式的时候，在控制器完成模型的调用之后会选择界面对用户响应，用常有两种方式：\n\n1. 通过response对象的sendRedirect方法。\n\n2. 通过RequestDispatcher对象的forward方法。\n\n例如要跳转登录界面login.jsp，可以使用下面的两种方式：\n\n1. 使用response\n\nresponse.sendRedirect(request.getContextPath()+\"/main.jsp\");     // 使用request.getContextPath()获取网站根目录\n\n2. 使用RequestDispatcher\n\nRequestDispatcher rd = request.getRequestDispatcher(\"login.jsp\");\n\nrd.forward(request,response);\n\n这两种方式有什么区别？什么情况下应该使用哪一种方式呢？\n\n首先介绍两者的区别。\n\n第一点区别，过程不同：第一种方式相当于浏览器接收到了响应之后又向服务器发送了一次请求，所以相当于两次请求。第二种方式相当于方法调用，在执行当前文件的过程中转向执行目标文件，两个文件（当前文件和目标文件）属于同一次请求，最本质的特点就是两次请求共享了reques对象和response对象。\n\n第二点区别，地址栏不同：第一种方式下用户在浏览器地址栏中看到的是目标文件的地址，第二种方式下用户在浏览器地址栏中看到的是当前文件的地址。这一点也非常重要，后面介绍。\n\n在使用的时候具体应如何选择呢？\n\n如果两个文件的关系非常密切，则应该使用RequestDispatcher，如果两个文件没有直接的关联关系，则应该使用response的sendRedirect方法。什么样的关系算是关系密切，什么样的关系算是没有直接的关联关系呢？例如查询的控制器和查询的结果界面之间就应该算是关系密切，因为查询控制器处理完之后肯定要转向查询结果界面。再例如添加信息的控制器和查询控制器之间的关系就是没有直接关系，通常在添加信息之后会跳转到列表界面的控制器然后再跳转到列表界面，修改信息或者删除信息之后也可能会跳转到列表界面的控制器然后再跳转到列表界面。\n\n下面是两个比较特殊的应用：\n\n1、如果希望通过request把当前在控制器中获取的信息传递给目标文件（通过request.setAttribute和request.getAttribute），这时候应该选择RequestDispatcher。因为需要当前文件和目标文件共享request对象。通常用于查询。\n\n2、对数据进行修改（包括删除和添加操作）的功能的控制器与之后的界面或者控制器应该采用response.sendRedirect方式。如果采用了RequestDiapatcher的forward方式，会产生严重错误。因为地址栏是修改信息的控制器，如果用户在刷新的时候，会重新发送一次对数据进行修改的请求，这不是用户想看到的结果。所以有同学在做添加功能的时候，每刷新一次就添加一条。\n\n如何采用第二种方式，如何传递数据呢？有两种方式：\n\n1、可以选择session，但是在第二个文件中一定要删除。\n\n2、可以在请求字符串中编写，例如login.jsp?info=\"用户不存在！\n\n为什么response.sendRedirect（）不跳转，在其后加上return;就能够跳转了呢\n\n```\nresponse.sendRedirect是通过浏览器来做转向的，所以只有在整个页面处理完成后，才会有实际的动作。\n```\n\n### Cookie和Session：\n\nSession是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；\n\nCookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式\n\n具体看一看这个博客：[点击打开链接](https://www.cnblogs.com/greatluoluo/p/5964888.html)\n');
INSERT INTO `blog_content` VALUES (85, '可以先看看别的[大佬写的](https://blog.csdn.net/dzy21/article/details/51867780)了解下cookie，具体我也不知道怎么讲。。\n\n然后自己写了个记住账号密码功能，附带查看cookie的值，删除cookie的功能！\n\n首先，在index.jsp中写好登录界面，并添加获取cookie中账号和密码信息并放进input中。以下是代码：\n\n```html\n<%--\n  Created by IntelliJ IDEA.\n  User: HSW\n  Date: 2018/4/20\n  Time: 11:09\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%\n    Cookie[] cookies = request.getCookies();\n    String admin = \"\";\n    String password = \"\";\n    if(cookies != null)\n        for(Cookie cookie : cookies){\n            if(cookie.getName().equals(\"admin\"))\n                 admin = cookie.getValue();\n            else if(cookie.getName().equals(\"pwd\"))\n                password = cookie.getValue();\n        }\n%>\n<html>\n  <head>\n    <title>Cookie Login</title>\n    <style>\n      div{\n        width: 800px;\n        height: 800px;\n        margin: 200px auto;\n      }\n      h1{\n          width: 400px;\n          height: auto;\n          margin: 0 auto;\n      }\n        table{\n            width: 400px;\n            height: auto;\n            margin: 0 auto;\n        }\n    </style>\n  </head>\n  <body>\n    <form action=\"${pageContext.request.contextPath}/setcookie\" method=\"post\">\n      <div>\n        <h1>登录</h1>\n        <table>\n          <tr><td><label for=\"admin\">用户名：</label></td>\n            <td><input type=\"text\" id=\"admin\" placeholder=\"请输入你的用户名\" name=\"admin\" value=\"<%=admin%>\"></td></tr>\n          <tr><td><label for=\"pwd\">密码：</label></td>\n            <td><input type=\"password\" id=\"pwd\" name=\"pwd\" value=\"<%=password %>\"></td></tr>\n          <tr><td><input type=\"submit\" value=\"登录\"></td><td><input type=\"reset\" value=\"重置\"></td></tr>\n        </table>\n      </div>\n    </form>\n  </body>\n</html>\n\n```\n\n将上面java代码字符串信息放进input框里面的方法就是像上面的这句一样：\n\n```html\nvalue=\"<%=password %>\">\n```\n\n每次访问这个页面时就先执行上面的java程序，第一次时没有账号信息，getCookies返回空，所以就不会自动填补input！\n\n![](https://upload-images.jianshu.io/upload_images/9031347-142331508c8ddc42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后新建一个Servlet相当于下面的A服务器，将登录信息放进Cookie！\n\n![](https://upload-images.jianshu.io/upload_images/9031347-05de6a3b406cbbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n代码如下：\n\n```java\npackage cn.jxufe;\n\nimport javax.servlet.http.Cookie;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.URLEncoder;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class CookieSer extends javax.servlet.http.HttpServlet {\n    protected void doPost(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {\n        response.setContentType(\"text/html; charset=utf-8\");\n        String admin = request.getParameter(\"admin\");\n        String password = request.getParameter(\"pwd\");\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd  hh:mm:ss\");\n        String datestr = format.format(new Date());\n        Cookie cookie = new Cookie(\"admin\", admin);\n        Cookie cookie2 = new Cookie(\"pwd\", password);\n        Cookie cookie3 = new Cookie(\"date\", URLEncoder.encode(datestr,\"utf-8\"));\n        response.addCookie(cookie);\n        response.addCookie(cookie2);\n        response.addCookie(cookie3);\n        PrintWriter out = response.getWriter();\n\n        out.write(\"<html>\");\n        out.write(\"<head>\");\n        out.write(\"<title>WebCookie</title>\");\n        out.write(\"</head>\");\n        out.write(\"<body>\");\n        out.write(\"账号密码已被添加进cookie\");\n        out.write(\"<a href=\"/look\">查看登录信息</a>\");\n        out.write(\"</body>\");\n        out.write(\"</html>\");\n    }\n\n    protected void doGet(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response) throws javax.servlet.ServletException, IOException {\n        doPost(request,response);\n    }\n}\n```\n效果：![](https://upload-images.jianshu.io/upload_images/9031347-a33d03ce874e1681.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到将账号、密码、最近一次登录时间都写进了cookie。\n\n这时返回登录界面刷新下看看：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-2d32cc7810d2acba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n账号密码都被保存！\n\n然后在上面的Servlet加了一个<a>跳转至另一个查看cookie信息的Servlet，名为LookCookieContent（url-pattern是/look）， 代码：\n\n```java\npackage cn.jxufe;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\n\npublic class LookCookieContent extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        Cookie[] cookies = request.getCookies();\n        String admin = \"暂无该项信息\";\n        String password = \"暂无该项信息\";\n        String date = \"暂无该项信息\";\n        if(cookies != null)\n            for(Cookie cookie : cookies){\n                if(cookie.getName().equals(\"admin\"))\n                    admin = cookie.getValue();\n                else if(cookie.getName().equals(\"pwd\"))\n                    password = cookie.getValue();\n                else if(cookie.getName().equals(\"date\"))\n                    date = URLDecoder.decode(cookie.getValue(), \"utf-8\");\n        }\n        PrintWriter out = response.getWriter();\n\n        out.write(\"<html>\n\" +\n                \"<head>\n\" +\n                \"    <title>Cookie Login</title>\n\" +\n                \"    <style>\n\" +\n                \"        div{\n\" +\n                \"            width: 800px;\n\" +\n                \"            height: 800px;\n\" +\n                \"            margin: 200px auto;\n\" +\n                \"        }\n\" +\n                \"        h1{\n\" +\n                \"            width: 400px;\n\" +\n                \"            height: auto;\n\" +\n                \"            margin: 0 auto;\n\" +\n                \"        }\n\" +\n                \"        table{\n\" +\n                \"            width: 400px;\n\" +\n                \"            height: auto;\n\" +\n                \"            margin: 0 auto;\n\" +\n                \"        }\n\" +\n                \"    </style>\n\" +\n                \"</head>\n\" +\n                \"<body>\n\" +\n                \"    <div>\n\" +\n                \"        <table> \n\" +\n                \"          <tr><td>账号：</td><td>\" + admin +\"</td></tr> \n\" +\n                \"          <tr><td>密码：</td><td>\" + password +\"</td></tr>\n\" +\n                \"          <tr><td>上次登陆时间：</td><td>\" + date + \"</td></tr>\n\" +\n                \"          <tr><td colspan=\"2\"><a href=\"\">删除cookie</a></td></tr>\n\" +\n                \"      </table>\n\" +\n                \"    </div>\n\" +\n                \"</body>\n\" +\n                \"</html>\");\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response);\n    }\n}\n\n```\n\n![](https://upload-images.jianshu.io/upload_images/9031347-4010e6088a24a08d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n单相思的情场失意，原本糟糕的心情随着一晚上的代码时光慢慢变好，现在依旧没有丝毫睡意，这难道就是学习使我快乐吗？\n\n![](https://upload-images.jianshu.io/upload_images/9031347-30558921b2bc0ba8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n新垣结衣晒出来一起养养眼![羡慕]\n![](https://upload-images.jianshu.io/upload_images/9031347-af74bbf88d501cee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\nemm~继续讲，接下来就是删除cookie了，很简单就是设置maxAge为0就行了！\n\n这个是自己写的无法正常删除cookie的代码（too young啊）：\n\n```java\npackage cn.jxufe;\n\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@WebServlet(name = \"DeleteCookieServlet\")\npublic class DeleteCookieServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Cookie[] cookies = request.getCookies();\n        if(cookies != null)\n            for(Cookie cookie : cookies)\n                cookie.setMaxAge(0);\n        RequestDispatcher dispatcher = request.getRequestDispatcher(\"index.jsp\");\n        dispatcher.forward(request, response);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request,response);\n    }\n}\n\n```\n\n![image.gif](https://upload-images.jianshu.io/upload_images/9031347-f26dc346225545b5.gif?imageMogr2/auto-orient/strip) \n\n关于cookie的寿命信息：\n\n在代码中，我们用Cookie.setMaxAge()设置Cookie的生命周期。在这个方法中如果没有参数的话，默认参数就是-1，表示是会话时期cookie，当结束会话或关闭浏览器就会删除。当设置了一个正值，即生命周期是这个正值的秒数，cookie将会保存至硬盘。而像上面那样直接设置为0，即直接删除该Cookie！\n\n运行代码发现无法正常删除，查找原因发现是因为没有执行response.addCookie()将原来的cookie覆盖！\n\n加上试试。\n\n点击删除cookie，返回登录界面时还是有的，因为网页有缓存，刷新下就没有了！\n![](https://upload-images.jianshu.io/upload_images/9031347-8746cee6a9e5060f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n**还有Cookie.setPath()和Cookie.setDomain()的作用。**\n\n**http://这里是domain/这里是path\n\n上面可以看到url中的domain部分和path部分**\n\n**cookie设定了domain和path之后，只允许同domain以及同path的页面访问。**\n\n可以看看这个博客：[点击打开链接](https://blog.csdn.net/mr_peach07/article/details/70442929)\n');
INSERT INTO `blog_content` VALUES (86, '<q>表示对别人的话的引用，差不多类似于在这句话两遍打上双引号，也便于设置样式。\n\n<blockquote>的作用也是引用别人的文本。但它是对**长文本**的引用\n\n<span> 没有什么实际意义，主要是将分割某段文字做特殊处理！\n\n<br>回车  &nbsp空格  <hr>网页横线\n\n<address>网页地址或联系方式之类的信息，与<em>的区别是虽然都是斜体但这个会另起一段    \n\n<pre>显示有具体格式的文字段落\n\n* * *\n\n**表格**\n\n    摘要 摘要的内容是不会在浏览器中显示出来的。它的作用是增加表格的可读性(语义化)，使搜索引擎更好的读懂表格内容，还可以使屏幕阅读器更好的帮助特殊用户读取表格内容。\n\n标题 用以描述表格内容，标题的显示位置：表格上方。\n\n<table summary=\"本表格记录2012年到2013年库存记录，记录包括U盘和耳机库存量\">\n\n  <caption>2012年到2013年库存记录</caption>\n\n  <tr>\n\n    <th>产品名称 </th>\n\n    <th>品牌 </th>\n\n    <th>库存量（个） </th>\n\n    <th>入库时间 </th>\n\n  </tr>\n\n  <tr>\n\n    <td>耳机 </td>\n\n    <td>联想 </td>\n\n    <td>500</td>\n\n    <td>2013-1-2</td>\n\n  </tr>\n\n  <tr>\n\n    <td>U盘 </td>\n\n    <td>金士顿 </td>\n\n    <td>120</td>\n\n    <td>2013-8-10</td>\n\n  </tr>\n\n  <tr>\n\n    <td>U盘 </td>\n\n    <td>爱国者 </td>\n\n    <td>133</td>\n\n    <td>2013-3-25</td>\n\n  </tr>\n\n如果想在新窗口中打开链接， 可以在<a>中设置 target=“_blank”\n\n* * *\n\nMailto 使用mailto能让访问者便捷向网站管理者发送电子邮件。\n\n后为收件人地址，cc后为抄送地址，bcc后为密件抄送地址，subject后为邮件的主题，body后为邮件的内容，如果Mailto后面同时有多个参数的话，第一个参数必须以“?”开头，后面的每一个都以“&”开头。下面是一个完整的实例:Mailto:[aaa@xxx.com](mailto:aaa@xxx.com)?cc=[bbb@yyy.com](mailto:bbb@yyy.com)&bcc=[ccc@zzz.com](mailto:ccc@zzz.com)&subject=主题&body=邮件内容\n\n***label****标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。*\n\n例子：\n\n<form>\n\n   <label for=\"male\">男</label>\n\n  <input type=\"radio\" name=\"gender\" id=\"male\" />\n\n  <br />\n\n  <label for=\"female\">女</label>\n\n  <input type=\"radio\" name=\"gender\" id=\"female\" />\n\n  <br />\n\n  <label for=\"email\">输入你的邮箱地址</label>\n\n  <input type=\"email\" id=\"email\" placeholder=\"Enter email\">\n\n</form>\n\n本来选择单选框要点击到框，而加了label，设置了for属性后，点击文字就可以勾选这个选项！\n\n**CSS**\n\nfont-size:默认是16px\n\nfont-weigth：默认是normal\n\n* * *\n\n***line-height:***\n\n在设置字体时如果设置font-size,font-weight, font-family,linr-height四个属性就显得有些麻烦，所以就可以使用font属性统一设置！\n\nfont：[font-style] [font-weight] font-size/font-height font-family;即可！\n![](https://upload-images.jianshu.io/upload_images/9031347-91c2fcea74c7cbdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![](https://upload-images.jianshu.io/upload_images/9031347-645cc11ce2a3282c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n* * *\n\n***background***\n\n当一个块级元素的背景图片比块级元素小时就会在页面中重复显示。\n\n可以用background-repeat：no-repeat；\n\nbackground-color  background-image  background-repeat background-position \n\nbackground-attachment 背景图片滚动属性：scroll | fixed | inherit；\n\nscroll会随着页面滚动，而fixed不会！\n\n* * *\n\n一个盒子的大小由content的宽高和padding还有border决定，设置一个元素的width和height实际上就是设置内容的宽高，一个盒子的面积即是\n\n(width+leftpadding+rightpadding+border)*(height+toppadding+bottompadding+border)\n\n* * *\n\n要想让网页能呈现想已被废除的<center>效果，可以在内容版块加个width和margin：0 auto即可\n\n想让div里面的内容超出了范围就自动换行可以设置white-space：normal，相关：\n\n### 相关属性介绍：\n\nwhite-space: normal|pre|nowrap|pre-wrap|pre-line|inherit;\n\nwhite-space 属性设置如何处理元素内的空白，其值：\n\n*   normal 默认。空白会被浏览器忽略。\n*   pre 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。\n*   nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。\n*   pre-wrap 保留空白符序列，但是正常地进行换行。\n*   pre-line 合并空白符序列，但是保留换行符。\n*   inherit 规定应该从父元素继承 white-space 属性的值。\n\nword-wrap: normal|break-word;\n\nword-wrap 属性用来标明是否允许浏览器在单词内进行断句，这是为了防止当一个字符串太长而找不到它的自然断句点时产生溢出现象。\n\n*   normal: 只在允许的断字点换行(浏览器保持默认处理)\n*   break-word:在长单词或URL地址内部进行换行\n*   word-break: normal|break-all|keep-all;\n\nword-break 属性用来标明怎么样进行单词内的断句。\n\n*   normal：使用浏览器默认的换行规则。\n*   break-all:允许再单词内换行\n*   keep-all:只能在半角空格或连字符处换行\n\n还有怎么使div内的元素水平排列和一些其他干货：[http://www.myexception.cn/HTML-CSS/2099946.html](http://www.myexception.cn/HTML-CSS/2099946.html)\n\n***元素类型：***\n\n一、block块级元素:\n\n    1、独占一行\n\n    2、不设置宽度样式时，宽度自动撑满父元素的宽度。\n\n    3、和相邻的元素依次垂直排列\n\n    4、可以设置高度和宽度和四个方向的内外边界值\n\n块级元素一般是其他元素的容器，如div，常见的块级元素有div，p，h1~h6，ul， ol，dr，dt，dd以及h5新增元素section、header、footer、nav等元素！\n\n二、inline行内元素:\n\n行内元素也称为内联元素或内嵌元素。行内元素具有以下特点：\n\n    1、行内元素不会独占一行，相邻得行内元素会从左往右一次排列在同一行里。知道一行排不下才会换行\n\n          注意：源代码中换行会被解析成空格。\n\n    2、不可以设置宽度width和高度height\n\n    3、可以设置四个方向的内边距的大小以及左右方向的外边距。但不可以设置上下方向的外边距。\n\n    4、行内元素的高度有元素高度觉得，宽度有内容的长度来控制，即宽高有内容来撑开！\n\n行内元素一般不能包含块级元素，常见的行内元素有span，a，em，strong，以及H5新增的mark，time元素。\n\n* * *\n\n三、inline-block行内块元素     \n\n行内块元素可以看成是行内元素和块级元素的结合体。它同时具有行内元素和块级元素的特点。\n\n    1、和相邻的行内元素以及行内块元素相邻会从左向右依次排列在一行。直到排不下就换行。换行同样被解析成空格！\n\n    2、可以设置宽高。\n\n    3、可以设置四个方向的内外边距。\n\n对于行内块元素来说两个左右响铃的行内块元素，间距等于左边右边距+右边左边距，上下相邻的上下边距等于上面下边距+下面上边距！\n');
INSERT INTO `blog_content` VALUES (87, '在许多登录界面，有着多次输入密码错误就会产生验证码防止有企图的人强力破解密码！\n\n### 实现生成验证码的servlet\n在这里我要实现的验证码像这样\n![验证码](https://upload-images.jianshu.io/upload_images/9031347-3129145e836d3b19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n随机的颜色随机的字母，还有随机颜色随机位置的线来影响图片识别算法的准确性！\n\n```\npackage checkCode;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class checkCodeServlet extends HttpServlet {\n\n	public final static int W = 120; //图片宽\n	public final static int H = 50; //图片高\n	Random random = new Random();\n\n	public void doGet(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n\n		doPost(request, response);\n\n	}\n\n	public void doPost(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		BufferedImage img = new BufferedImage(W,H,BufferedImage.TYPE_INT_BGR); //画纸\n		Graphics g = img.getGraphics(); //画笔\n		g.setColor(Color.yellow); //颜色\n		g.fillRect(200,500,W,H,10,10); //填充颜色的矩形\n		drawLines(g); //划线函数\n		drawCharacter(g); //画字母函数\n		ImageIO.write(img, \"jpg\", response.getOutputStream());  //输出图像\n		g.dispose();//释放资源！\n	}\n\n	//在图片上写下随机数字！\n	public void drawCharacter(Graphics g){\n		String str = \"0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHKJLZXCVBNM\";\n		for(int i = 0; i<4; i++){\n			int index = random.nextInt(str.length());\n			setColor(g);\n			g.setFont(new Font(\"宋体\", Font.BOLD, 30));\n			g.drawString(\"\" + str.charAt(index), 20*i+20, 30);\n		}\n	}\n\n	//画随机线\n	public void drawLines(Graphics g){\n		int count = random.nextInt(20);\n\n		for(int i = 0; i<count; i++){\n			int x1 = random.nextInt(W);\n			int x2 = random.nextInt(W);\n			int y1 = random.nextInt(H);\n			int y2 = random.nextInt(H);\n			setColor(g);\n			g.drawLine(x1, y1, x2, y2);\n		}\n	}\n\n	//随机选择画笔颜色！\n	public void setColor(Graphics g){\n		int R = random.nextInt(256);\n		int B = random.nextInt(256);\n		int G = random.nextInt(256);\n		Color c = new Color(R, B, G);\n		g.setColor(c);\n	}\n\n}\n\n```\n>代码比较简单，不多赘述！\n\n\n### 在jsp页面显示验证码\n\n#####首先必须现在web中配置servlet\n```html\n    <servlet>\n        <servlet-name>check</servlet-name>\n        <servlet-class>checkCodeServlet</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>check</servlet-name>\n        <url-pattern>/checkCode</url-pattern>\n    </servlet-mapping>\n```\n然后像下面这样使用：\n```html\n<label for=\"inputCheckCode\">请输入验证码：</label>\n<input type=\"text\" id=\"inputCheckCode\">\n<img src=\"${pageContext.request.contextPath}/checkCode\" alt=\"\">\n```\n####效果\n![输入验证码](https://upload-images.jianshu.io/upload_images/9031347-81b61c160c7c3005.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 实现javascript代码刷新二维码\n\n修改jsp代码如下：\n```html\n  <body>\n    <label for=\"inputCheckCode\">请输入验证码：</label>\n    <input type=\"text\" id=\"inputCheckCode\">\n    <img src=\"${pageContext.request.contextPath}/checkCode\" alt=\"\" id=\"checkImg\">\n    <script>\n        var i = 1;\n        var image = document.getElementsByTagName(\"img\")[0];\n        image.onclick = function() {\n            this.src = \"${pageContext.request.contextPath}/checkCode?i=\" + i;\n            i++\n        };\n    </script>\n  </body>\n```\n让每次点击二维码图片，改变img的src使其不会从缓存中去取图片（这样每次都一样），改变src使每次点击都能访问到servlet刷新二维码！\n现在就能靠点击二维码刷新图片了！\n\n![孙艺珍](https://upload-images.jianshu.io/upload_images/9031347-e0ff5b19e86a2206.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n');
INSERT INTO `blog_content` VALUES (89, '**我们能运用PrintWriter实现在Sevlet上传html代码至浏览器，上传图片同理。**\n\n#### 代码：\n\n```java\npackage cn.jxufe.test;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class DownImage extends HttpServlet {\n	public void doGet(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n		doPost(request, response);\n	}\n\n	public void doPost(HttpServletRequest request, HttpServletResponse response)\n			throws ServletException, IOException {\n\n		String path = this.getServletContext().getRealPath(\"/WEB-INF/classes/7.jpg\");\n		InputStream input = new FileInputStream(path);\n		OutputStream output = response.getOutputStream();\n		byte[] b = new byte[64];\n		int count = -1;\n		while((count = input.read(b))!=-1){\n			output.write(b, 0, count);\n		}\n\n		input.close();\n		output.close();\n	}\n\n}\n\n```\n\n在这里我们可以运用字节流将图片上传！\n![image.png](https://upload-images.jianshu.io/upload_images/9031347-fea11f2ee89a3ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这里的路径是类似于：tomcat安装目录/webapps/项目名/WEB-INF/classes/文件名\n\n当然这里的图片是放在src目录下的\n\n![](https://upload-images.jianshu.io/upload_images/9031347-a1cdf2614b12285b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n相对于tomcat服务器中webapps文件夹下的/classes文件夹下！\n\n这里看看文件夹结构和webapps的文件结构的对比：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-8f1fe44c7e9339c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](https://upload-images.jianshu.io/upload_images/9031347-3f9f04278e2328a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](https://upload-images.jianshu.io/upload_images/9031347-94751bd6f3794627.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](https://upload-images.jianshu.io/upload_images/9031347-8ee83639b21a46c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看出图片上面两个是包名，包里面是java文件对应的class文件！\n\n当给web项目配置了服务器，就会自动将web项目的文件夹下的WebRoot文件夹复制到tomcat安装目录下的webapps文件夹下，然后在复制文件夹的WEB-INF  文件夹下新建一个classes文件夹作为servlet.java字节码文件的目地文件夹，而ServletContext就类似于一整个项目的上下文，即整个WebRoot文件夹。\n\n如果想用户直接在这个网页下载文件：可以加上\n\n```java\nresponse.setHeader(\"content-disposition\", \"attachment;filename=\"+path);\n```\n\n![image.gif](https://upload-images.jianshu.io/upload_images/9031347-7379e8c4820137f8.gif?imageMogr2/auto-orient/strip) \n\n```java\nresponse.setHeader(\"content-type\", \"image/jpeg\");\n```\n\n![image.gif](https://upload-images.jianshu.io/upload_images/9031347-e9992d4f449999b8.gif?imageMogr2/auto-orient/strip) \n\n两行代码！当访问时就会直接出现下载选项！\n\n![image.png](https://upload-images.jianshu.io/upload_images/9031347-2162a3d5c10a98b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n');
INSERT INTO `blog_content` VALUES (90, '```泛型是一个很令人费解的概念，但却是理解类型系统的重要基石！```\n***\n\n&ensp;&ensp;大部分内容摘自《kotlin极简教程》，加上了自己的一些理解，写的不好，请多指教！\n\n### 型变有三种基本的形态：协变（covariant）， 逆变(cotravariant)，不变(invariant)\n\n&ensp;&ensp;我们先从java了解的类型通配符介绍这三个概念：java中通配符有一下两种形式：\n\n>？ extends T：子类型上界限定符，指定类型的上界（只能是T类型或者T的子类）\n>？ super T ：父类的下界限定符，指定类型的下界（只能是T类型或者是T类型的父类）\n\n```java\ninterface Animals{\n    void eat();\n    void run();\n}\nclass Cat implements Animals{\n    @Override\n    public void eat() {}\n    @Override\n    public void run() { }\n}\nclass Dog implements Animals{\n    @Override\n    public void eat() {}\n    @Override\n    public void run() {}\n}\n```\n\n&ensp;&ensp;在这里我先用java写几个类，在java中我们知道：Animal是Cat和Dog的父类，可以直接使用Cat的子类和Dog的子类给Animals的一个对象赋值，那么ArrayList<Animals> animals = new ArrayList<Cat>()或者ArrayList<Animals> animals = new ArrayList<Dog>()还可以吗？或者说ArrayList<Animals>还是ArrayList<Cat>()或者ArrayList<Dog>的父类吗？\n\n**我们试试看：**\n\n![](https://upload-images.jianshu.io/upload_images/9031347-3d508141856911f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n&ensp;&ensp;可以看到编译报错，所以是不可能这样赋值的！\n\n&ensp;&ensp;那么泛型通配符就派上用处了。将ArrayList<Animal> animals改成 ArrayList<? extends Animal> ：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-d4ed41152c9093a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n&ensp;&ensp;也就是说ArrayList<Animals>并不是ArrayList<Cat>()和ArrayList<Dog>的父类，而ArrayList<？ extends Animals>才是！\n\n> &ensp;&ensp;这里的ArrayList<？ extends Animals>并不能添加Animal及其子类对象的！因为如果能的话就既能添加Cat对象又能添加Dog对象，java是不允许的！但是能add（null）\n\n&ensp;&ensp;上述这种情况就叫做**协变（即F是C的父类，f(F)是f(C)的父类）**所以<? extends T>实现了泛型的协变！(f(F)类似于List<F>的形式)\n\n## <? super T>实现了泛型的逆变！\n\n&ensp;&ensp;逆变即**（即F是C的父类，f(C)是f(F)的父类）**\n\n**如果既不是逆变又不是协变，就是不变。**\n\n&ensp;&ensp;List<? super Number>，这里限制了List的内容只能是Number和Number父类。例如List<Object> 就是他的子类，而Object是所有类的父类，这就是逆变！看代码：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-f8eade4f523a9e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\nArrayList<Number> numbers = new ArrayList<Object>（）报错！\n![](https://upload-images.jianshu.io/upload_images/9031347-2bb756f0ff8c89fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n&ensp;&ensp;ArrayList<? super Number> numbers = new ArrayList<Object>()编译通过！\n\n&ensp;&ensp;在这个list中我们不能添加Number的任一父类对象，但能添加Number和其所有子类的对象！\n\n## PECS（Producer-Extends， Consumer-Super）\n\n&ensp;&ensp;那么我们什么时候使用extends，什么时候使用super呢！\n\n&ensp;&ensp;《kotlin极简教程》书上用了一个stack API来举例说明：\n\n```\npublic class Stack<E>{\n    public Stack(){}\n    public void push(E v){}\n    public E pop(){}\n    public boolean isEmpty(){}\n}\n```\n&ensp;&ensp;实现pushAll方法\n\n```\n    public void pushAll(Iterable<E> src){\n        for(E e : src)\n            push(e)\n    }\n```\n\n&ensp;&ensp;假设有一个实例化的stack<Number>，要将stack<Integer>和stack<Float>里的所有值添加进去，调用上面的方法会出现type mismatch错误应该写成下面这种形式。\n\n```\n    public void pushAll(Iterable<？extends E> src){\n        for(E e : src)\n            push(e)\n    }\n\n```\n\n&ensp;&ensp;而要实现popAll方法，将一个stack中的元素依次取出add至dst中，不用通配符时：\n\n```\n    public void popAll(Stack<E> dst) {\n        while(!isEmpty())\n            dst.push(pop())\n    }\n```\n\n&ensp;&ensp;如果要将一个stack<Number>栈全部输出至一个stack<Object>中， 即dst是stack<Object>类，则一样会出现type mismatch错误，应将方法改成：\n\n```\n    public void popAll(Stack<？ super E> dst) {\n        while(!isEmpty())\n            dst.push(pop())\n    }\n```\n&ensp;&ensp;将其PECS称为Get and Put principle\n\n&ensp;&ensp;在java.util.Collection的copy方法中完美地诠释了PECS：\n\n```\n    public static <E> void copy(List<? super E> dest, List<? extends E> src) {\n        int srcSize = src.size();\n        if(srcSize > dest.size())\n            throw new IndexOutOfBoundsException(\"Source does not fit in dest\");\n        ...略\n    }\n```\n\n&ensp;&ensp;大致可以这么解释，在这个方法中，我们从src中取数据，即src是producer，然后将数据添加至dest，所以dest是consumer所以，PECS，前者就是super，后者就是extends。\n\n## kotlin：\n\n&ensp;java中有通配符，kotlin中则抛弃了这些，引用了生产者消费者概念，从上面的copy方法中也可以看出端倪。\n\n&ensp;&ensp;kotlin把只负责安全读取数据的对象称为生产者，只负责安全写入数据的对象为消费者。kotlin中，生产者用\n\n<out T>（等价于<? extends T>），消费者用<in T>（等价于<> super T>）。\n');
INSERT INTO `blog_content` VALUES (91, '&ensp;&ensp;在平时的编程中，总是能在一些编译器自动生成的代码或者大佬的程序中看到//TODO ...的注释，一直很疑惑到底是什么意思，以为是个注释规范，其实是项目管理者要求代码编写人员在式样无法确定，或者其他原因不能完成编程的时候，用// TODO进行注释，那么管理者就可以随时的通过任务列表查看工作状况和问题点来进行控制。\n\n&ensp;&ensp;在intellij中可以设置自己专属的TODO，设置自己专属的TODO表示用来在一个多人合作的项目中与别人的TODO分别开来（默认是深蓝色）：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-242fd4e20f8ed9e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![](https://upload-images.jianshu.io/upload_images/9031347-cd1e801de1ee9247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n');
INSERT INTO `blog_content` VALUES (92, '&ensp;&ensp;最近买了个域名，租了台服务器，这个学期学习前端，然后又闲着没事干就想搭建一个个网站，所以就准备用Putty软件连接我的云服务器（系统是ubuntu server 16.04.1 LTS 64位的）然后再配置jdk和tomcat环境。我的操作都是在root的情况下进行的！\n***\n\n## 一、安装并配置jdk\n\n&ensp;&ensp;在网上看到有很多教程是直接在windows上下载然后用类似于WinScp软件移到云服务器上的，这样感觉很麻烦而且速度非常慢，下载慢，移到云服务器慢！所以我就用了wget这个命令。\n\n```cd home/ubuntu/pan```\n\n进入这个目录，我们在这个目录下下载文件，然后再在此解压什么的，没有这个目录的话，就```mkdir```创建这个目录！  \n\n### 1.1下载jdk\n\n![](https://upload-images.jianshu.io/upload_images/9031347-854f44f092cadcbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n&ensp;&ensp;在windows下找到jdk的下载的连接（不用下载，单纯的复制下载链接地址-确保正确-就行了！别忘了），然后在putty上输入：\n\n```wget  http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz```\n\n即可开始下载！如果显示没有wget，只需要apt install wget即可（需要root）。\n\n下载完成\n\n![](https://upload-images.jianshu.io/upload_images/9031347-301213a3532dde2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n查看目录文件，就可以看到这个压缩包了！\n\n![](https://upload-images.jianshu.io/upload_images/9031347-545aec61eae6f7ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n如果出现这样的错误：\n![](https://upload-images.jianshu.io/upload_images/9031347-f64d6d373e2bd919.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> 我当时的做法是看文件大小！如何很小的话，就说明下错了！找过另一个网址行了！\n\n很明显上面那个网址下下来是没有用的！/手动滑稽\n\n![](https://upload-images.jianshu.io/upload_images/9031347-48c8620d2a491594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个页面的就能下载成功！\n\n```wget http://download.oracle.com/otn-pub/java/jdk/10.0.1+10/fb4372174a714e6b8c52526dc134031e/jdk-10.0.1_linux-x64_bin.tar.gz?AuthParam=1527316636_a2f5739964d25aef810bcee5ba23f89d```\n\n这个下载就要久点，但也比windows（主要是学校的渣渣网速、、）下载快！\n![](https://upload-images.jianshu.io/upload_images/9031347-a0105624f9704da7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n下载完成后显示：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-55a91f74a2408878.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n首先先改名啊，这么长。。。 \n\n```mv jdk-10.0.1_linux-x64_bin.tar.gz?AuthParam=1527316636_a2f5739964d25aef810bcee5ba23f89d jdk-10.0.1.tar.gz```\n\n### 1.2 解压缩并移到目标文件夹！\n\n然后解压：**tar -zxvf  jdk-10.0.1.tar.gz**\n\n成功后：\n\n![](https://upload-images.jianshu.io/upload_images/9031347-22ed2e870443962a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n删除压缩包：**rm jdk-10.0.1.tar.gz**\n\n然后移到**/usr/java**(usr下没有java就自己创建，下tomcat同！)\n\n### 1.3 配置环境变量\n\n然后找到进入**/etc**目录，修改这个目录下的profile\n\n**vi profile**\n\n后面加上：\n```export JAVA_HOME=/usr/java/jdk-10.0.1```\n```xport PATH=$JAVA_HOME/bin:$PATH```\n\n```export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar```\n\n第一行的  JAVA_HOME是jdk目录的位置！后面一样就行了！\n\n```：wq    ```保存并退出！\n\n### 1.4 重启\n\n&ensp;&ensp;通常情况下、etc/profile 文件实在开机情况下加载的！我们可以用source来让其临时起作用！但为了让他长期起作用我们就需要重启服务器了！\n\n重启后**java -version**\n\n![](https://upload-images.jianshu.io/upload_images/9031347-585f672c8b31348f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n安装配置jdk成功！\n\n## 二、安装配置tomcat\n\n### 2.1 下载tomcat\n\n同上，找到tomcat的下载链接，复制粘贴\n\n```wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-9/v9.0.8/bin/apache-tomcat-9.0.8.tar.gz```\n\n![](https://upload-images.jianshu.io/upload_images/9031347-18b1aedfd56b079c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 2.2 解压缩并移动文件\n\n解压  ```tar -zxvf xxx```\n\n移动至```/usr/tomcat ```\n\n### 2.3 配置tomcat\n\n然后进入apache-tomcat-9.0.8，\n\n```cd conf```\n\n里面有一个server.xml文件，编辑文件\n\n```vi server.xml```\n\n找到这个connector\n\n![](https://upload-images.jianshu.io/upload_images/9031347-5779d82d6b8c5f80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后将其port改为80端口！\n\n```ESC```\n\n```：wq```\n\n### 2.4 启动tomcat\n\n然后再启动tomcat服务！\n\n![](https://upload-images.jianshu.io/upload_images/9031347-5b9d97f8a22905a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n进入tomcat下面的bin目录，ls可以看到有个startup.sh\n\n启动它，在linux中启动一个可执行文件，要在前面加上./代表当前目录。\n\n```./startup.sh```\n\n![](https://upload-images.jianshu.io/upload_images/9031347-80d4eb4b3fdc0bc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\ntomcat启动成功！\n\n### 2.5 访问tomcat\n\n通过域名访问就可以看到tomcat的默认显示内容！\n![image.png](https://upload-images.jianshu.io/upload_images/9031347-64833550f6ce4453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个是默认文件是/apach-tomcat/bin/ROOT/Index.jsp文件的内容\n![](https://upload-images.jianshu.io/upload_images/9031347-9e2e31bcf04a71d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n能访问就代表你的tomcat安装成功了！\n\n以上\n');
INSERT INTO `blog_content` VALUES (94, '###概念\n&ensp;软件测试中的决策表法 概念：该方法是分析和表达多逻辑条件下不同操作的执行情况！在一个程序中，许多项操作是在多个逻辑条件的组合下完成，此项方法中要做的就是针对每个条件的不同情况来分析每项操作的执行情况！\n###组成\n一个决策表是由“条件”和“活动”两部分组成 ，即列出所有可能条件情况的组合，为所有条件组合提供了所有可能会出现的执行情况的选择，针对选择做出分析！具体如图：\n![组成](https://upload-images.jianshu.io/upload_images/9031347-fa9e407531bf9ea8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![组成](https://upload-images.jianshu.io/upload_images/9031347-fcbd72ab6506053d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###例子\n\n&ensp;在这里我们测试了求1600年至2100年中任意一天的前一天的日期情况（好像就是等价类诶，其中下划线的是合法的）：\n\n>年份：① 1600<= y <=2100平年 ② 1600<= y <=2100闰年 ③ y < 1600 ④ y > 2100 \n\n>月份：⑤ m∈{5,7,10,12} ⑥ m∈{4,6,8,9,11} ⑦ m = 1 ⑧ m = 2 ⑨ m = 3 ⑩ m <1 ⑪ m >12 \n\n>日期：⑫ d = 1 ⑬ 2 <= d <= 28 ⑭ d = 29 ⑮ d = 30  ⑯ d = 31  ⑰ d > 31  ⑱ d < 1  |\n\n&ensp;列出了所有情况后，再制作决策表:\n\n| 条件 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |\n|:-------:|:-------:|:-------:|:------:|:-------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|\n| c1：年份 | ③④ | -- | -- | -- | -- | ① | ①② | -- | ①② | ①② | ①② | ①② | ①② | ①② | ② | ① | ② |\n| c2：月份 | -- | ⑨⑩ | -- | ⑧ | ⑥ | ⑧ | ⑧ | ⑥ | ⑤⑥⑦⑧⑨ | ⑤⑦⑨ | ⑤ | ⑥⑧ | ⑥ | ⑦ | ⑧ | ⑨ | ⑨ |\n| c3：日期 | -- | -- | ⑮⑯ | ⑮⑯ | ⑯ | ⑭ | ⑮⑯ | ⑯ | ⑬ | ⑭⑮⑯ | ⑫ | ⑫ | ⑭⑮ | ⑫ | ⑭ | ⑫ | ⑫ |\n| 行为 ||   |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n| a1：不可能 | X | X | X | X | X | X | X | X |  |  |  |  |  |  |  |  |  |\n| a2：日期减一 |  | |  |  |  |  |  |  | X | X |  |  | X |  | X |  |  |\n| a3：日期变为上个月28 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | X |  |\n| a4：日期变为上个月29 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | X |\n| a5：日期变为上个月30 |  |  |  |  |  |  |  |  |  |  | X |  |  |  |  |  |  |\n| a6：日期变为上个月31 |  |  |  |  |  |  |  |  |  |  |  | X |  | X |  |  |  |\n| a7：月份减一 |  |  |  |  |  |  |  |  |  |  | X | X |  |  |  | X | X |\n| a8：月份变为12月 |  |  |  |  |  |  |  |  |  |  |  |  |  | X |  |  |  |\n| a9：年份减一 |  |  |  |  |  |  |  |  |  |  |  |  |  | X |  |  |  |\n\n然后可以试着按照条件举出用例测试程序\n\n做出精简的表格列出所有用例和测试结果，这里懒得列了，溜~\n');
INSERT INTO `blog_content` VALUES (95, '###方法定义\n&ensp;将所有可能输入数据的数据域进行划分，分成若干子集，再从其中选出少数具有代表性的的是用例测试程序，该方法是一种常用的黑盒测试方法。**\n\n### 分类\n&ensp;**等价类划分可有两种不同的情况：有效等价类和无效等价类**\n\n1. 有效等价类\n是指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。\n2. 无效等价类\n与有效等价类的定义恰巧相反。无效等价类指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能有多个。\n\n###划分等价类的标准\n  - 完备测试、避免冗余;\n  - 划分等价类重要的是：集合的划分，划分为互不相交的一组子集，而子集的并是整个集合;\n  - 并是整个集合：完备性;\n  - 子集互不相交：保证一种形式的无冗余性;\n  - 同一类中标识（选择）一个测试用例，同一等价类中，往往处理相同，相同处理映射到\"相同的执行路径\"。\n\n###实例分析\n&ensp;首先是测试1600年至2100年的任意一天的下一天的日期情况，按照年、月、日的取值划分。\n**划分情况如下：**\n>①1600<= y <=2100平年 ②1600<= y <=2100闰年 ③y <1600 ④y >2100 ⑤m∈{1,3,5,7,8,10} ⑥m∈{4,6,9,11} ⑦m = 2 ⑧m = 12 ⑨ m <1 ⑩m >12 ⑪1<= d <=27 ⑫d = 28 ⑬d = 29  ⑭d = 30  ⑮d = 31 ⑯d > 31 ⑰d < 1 \n\n**按照等价类范围选出某些具有代表性的策划用例：**\n\n> ①2001.4.22  ②2000.2.29  ③1500.4.13  ④2101.5.10  ⑤2000.3.31 \n⑥2100.12.30  ⑦2000.0.30  ⑧2000.13.2  ⑨2001.2.28  ⑩2000.1.32\n⑪2000.1.0 \n\n**然后根据测试用例测试程序将情况按表列出：**\n\n| 测试实例|编号 | 年|月|日 | 预期结果 | 测试结果 | 备注 | 覆盖等价类 |\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n| ① | 2001 | 4 | 22 | 2001年4月23日 | 2001年4月23日 | pass |  |①⑥⑪ |\n| ② | 2000 | 2 | 29 | 2000年3月1日 | 2000年3月1日 | pass |  | ②⑦⑬ |\n| ③ | 1500 | 4 | 13 | 输入年份超出范围！ | 输入年份超出范围！ |pass| | ③ |\n| ④ | 2101 | 5 | 10 | 输入年份超出范围！ | 输入年份超出范围！ |pass|  | ④ |\n| ⑤ | 2000 | 3 | 31 | 2000年4月1日 | 2000年4月1日 | pass |  | ⑤⑮ |\n| ⑥ | 2100 | 12 | 30 | 2100年12月31日 | 2100年12月31日 | pass |  | ⑧⑭ |\n| ⑦ | 2000 | 0 | 30 | 不存在0月 | 2000年1月1日 | failed | 备注一 | ⑨ |\n| ⑧ | 2000 | 13 | 2 | 输入数据非法 | 输入数据非法 | pass |  | ⑩ |\n| ⑨ | 2001 | 2 | 28 | 2001年3月1日 | 2001年3月1日 | pass |  | ⑫ |\n| ⑩ | 2000 | 1 | 32 | 不存在1月32日 | 2000年2月1日 | failed | 备注二 |⑯ |\n| ⑪ | 2000 | 1 | 0 | 输入数据非法 | 2000年1月1日 | failed | 备注三 | ⑰|\n\n\n\n![备注一](https://upload-images.jianshu.io/upload_images/9031347-367e313af8c1c80d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![备注二](https://upload-images.jianshu.io/upload_images/9031347-d371b56f840b9497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![备注三](https://upload-images.jianshu.io/upload_images/9031347-7495d7f401b56a1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n**然后是测试三角形种类程序（感觉这个有错误）：**\n\n**等价类划分： **\n>①a<=0 ②a>200 ③b<=0 ④b>200 ⑤c<=0 ⑥c>200 ⑦0<a、b、c<200 ⑧(a+b)>c||(a+c)>b||(b+c)>a ⑨ (a+b)<c&&(a+c)<b&&(b+c)<a ⑩a=b||b=c||a=c ⑪a!=b&&a!=c&&b!=c ⑫a=b&&a=c&&b=c ⑬a!=b||a!=c||b!=c  ⑭a*a+b*b=c*c||a*a+c*c=b*b||b*b+c*c=a*a ⑮a*a+b*b!=c*c&&a*a+c*c!=b*b&&b*b+c*c!=a*a ⑯a*a+b*b=c*c&&(a=b||b=c||a=c)... ⑰a*a+b*b!=c*c||(a!=b&&b!=c&&a!=c)... \n\n\n>测试实例： ①4,5,6  ②1,1,2  ③2,2,3  ④2,2,2  ⑤3,4,5 \n⑥1,1,1.414214(√2)  ⑦0,2,1  ⑧  ⑨201,100,150  ⑩20,201,190\n⑪1,2,0  ⑫190,20,201 \n\n| 测试实例  | 编号 |  a | b | c  | 预期结果 | 测试结果 | 备注 | 覆盖等价类 | \n |:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n| ① | 4 | 5 | 6 | 一般三角形 | 一般三角形 | pass |  | ⑦⑧⑪⑬⑮⑰ |\n| ② | 1 | 1 | 2 | 非三角形 | 等腰三角形 | failed | 备注一 | ⑨ |  |\n| ③ | 2 | 2 | 3 | 等腰三角形 | 等腰三角形 | pass |  | ⑩ |  |\n| ④ | 2 | 2 | 2 | 等边三角形 | 等边三角形 | pass |  | ⑫ |  |\n| ⑤ | 3 | 4 | 5 | 直角三角形 | 直角三角形 | pass |  | ⑭ |  |\n| ⑥ | 1 | 1 | 1.414214 | 等腰直角三角形 | 等腰三角形 | failed | 备注二|⑯ |  |\n| ⑦ | 0 | 2 | 1 | 输入数据非法 | 输入数据非法 | pass |  | ① |  |\n| ⑧ | 201 | 100 | 150 | 输入数据非法 | 输入数据非法 | pass |  | ② |  |\n| ⑨ | 2 | 0 | 1 | 输入数据非法 | 输入数据非法 | pass |  | ③ |  |\n| ⑩ | 20 | 201 | 190 | 输入数据非法 | 输入数据非法 | pass |  | ④ |  |\n| ⑪ | 1 | 2 | 0 | 输入数据非法 | 输入数据非法 | pass |  | ⑤ |  |\n| ⑫ | 190 | 20 | 201 | 输入数据非法 | 输入数据非法 | pass |  | ⑥ |  |\n\n![备注一](https://upload-images.jianshu.io/upload_images/9031347-daaed518ea0cf7d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![备注二](https://upload-images.jianshu.io/upload_images/9031347-78e4ebe9b5a43f67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###总结\n&ensp;划分等价类的方法用自己所理解的一句话来总结：即是每个等价类里面的所有情况只能通过一个方法或者说是算法来得到结果。\n\n&ensp;这个条件所遇到的类似if else switch得到的结果都是一样。结果也就是属于一个类别！\n\n以上。\n');
INSERT INTO `blog_content` VALUES (97, '> 之所以为缓存新建一个文集，是因为这个知识点实在是太重要了，在项目中用redis + springCache做缓存的代码差不多写完了，这里稍微做下笔记，全为脑中零散记忆，属个人理解，有错望纠！\n\n参考[文章](https://segmentfault.com/a/1190000015804406\n)和[这篇](https://blog.csdn.net/qq_28740207/article/details/80877079)\n# 缓存击穿\n当某个缓存key过期后，突然在缓存更新的间隔内超高并发的对这缓存key的请求压力全部落在数据库上，这就是缓存击穿！\n\n> 黑客可以利用这点，对一些不存在的数据发出大量请求，这些没有被缓存的数据没有存在于缓存中，造成数据库压力过大直至崩溃。\n\n[缓存击穿的解决方案](https://blog.csdn.net/zeb_perfect/article/details/54135506)\n# 缓存雪崩\n如果缓存垮掉，如果之前没有做好容量预估，所有请求都压在DB上，致使数据库也跨掉造成整体服务不可用。\n解决方案：\n- 自动故障转移\n  redis就有哨兵模式，当主从服务器的主服务器崩溃不可写时，哨兵检测到，采用某些策略从从服务器中投票选出某一个来当主服务器，其他从服务器称为其从服务器。\n- 水平切分\n使用多台服务器分担请求压力，当一台服务器崩掉，还有其他服务器工作，但这种方式会造成数据不一致等问题，预防会使逻辑复杂！\n# 数据库读写缓存一致性问题\n此缓存一致性问题是指数据请求时造成的缓存和数据库数据不一致的问题！\n## cache更新？淘汰？\n在修改数据时，对于缓存中的数据进行删除还是更新，由具体业务情况而定。\n- 淘汰数据的话，会增加后面请求一次cache miss的情况。\n- 更新数据的话，逻辑相对较复杂。\n> 业务举例\n在某网上商城买件衣服，缓存中已有用户信息：\n1.首先从数据库查询该衣服价格70\n2.从数据库中获取折扣信息，获取优惠券信息。\n3.从cache中获取用户余额100\n4.100-70=30计算后写入缓存\n5.然后获取cache中用户拥有该道具件数\n6.件数加一写回缓存\n为了避免一次cache miss，要读写数据库缓存多次（或更复杂的情况），逻辑还复杂了，不值当！\n而如果直接是将余额改为200，仅仅一个简单的set（balance， 200）就可以直接更新缓存了！\n##先操作DB，还是先操作cache\n操作数据时，到底是先操作缓存还是先操作数据库？\n#### 先cache再DB\n先缓存在数据库会造成并发读写时的缓存一致性问题。\n如：\n1. A要更新某数据key，先淘汰cache中的key\n2. 淘汰key后，B需要读key，cache miss\n3. 因为写比较慢，或者A在主DB中写完成，为完成主从数据同步，B从从数据库读取到已经原来的数据。\n4. A更新数据库\n5. B将脏数据写入缓存\n此时缓存和数据库数据不一致。在一个过期时间内，其他的读请求读取的全是脏数据！\n#### 先DB再cache\n此种情况一般不会发生缓存一致性问题。\n比如：A读，B写\n- A在B的前面：\n   - cache miss \n1.A读取DB原数据\n2.B更新数据\n3.B删除缓存（即使没有缓存）\n4.A写缓存（脏数据）\n此时数据库和缓存数据一致，但这种情况很少发生，因为写操作一般都比读操作慢，不可能B更新数据再删除缓存之后A才读完数据。所以要不3、4颠倒，缓存数据被删除，数据也不会不一致！\n  - cache hit\n这种情况最多导致B**写完**到删除缓存这段时间内读取的数据不一致，即删除缓存的时间，最终数据还是一致的！\n- B在A的前面同理，\n  - cache miss\n因为写比较慢即使A读取到脏数据，写入了缓存，也会被慢一步的B删除，最终数据还是一致的！\n  - cache hit，这种更不用说，写完DB到删除cache之间的读不一致，可以忽略。\n> 所以先DB在cache的策略还是可以在很大程度上避免并发读写导致的缓存一致性问题的！\n\n> 但是，如果出现原子性问题（先cache再DB没有），B的写操作成功，删除缓存操作失败，也会造成缓存一致性问题。解决方案：将删除失败的key加入到消息队列中，尝试多次删除直到正确删除为止！\n\n# cache-aside pattern\n国外有人提出《cache-aside patter》套路，即旁路缓存方案的经验实践，这个实践又分读实践，写实践。\n读先cache后DB，cache hit返回数据，cache miss访问DB，然后将数据写入到缓存！\n写先DB在cache，先更新数据库，再**淘汰**cache！\n> 注意，其建议删除缓存，因为并发写缓存可能会发生错误造成数据不一致！\n');
INSERT INTO `blog_content` VALUES (98, '# 一、原码\n### 无符号数：\n> 无符号数在计算机中的表示非常简单，其在计算机中的所有字节都标识了其真值。我们在C语言中的unsigned表示的就是无符号数的变量。其所占二进制位数就能表示其取值范围。比如，一个占八位字节的无符号变量取值范围为0 ~ 2 ^ 8 = 256\n### 有符号数\n> 有符号数的表示包含了符号位和数值位，我们把每个部分都存储起来，把最高的一位作为符号位，即0代表正数，1代表负数。真值与机器数的转换示例如下：\n![](https://upload-images.jianshu.io/upload_images/9031347-761770d1814dfd06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#####那么如何确定小数点的位置呢？\n注意小数点的位置是按约定给出的，像这种小数点位置确定的数，我们称之为定点数。而定点数又可以分为**小数定点集**和**整数定点集**两种，分别如图上两个和下两个表示的那样，位置在最高位后面的为小数定点集，在最后的为整数定点集。（注意小数点不占二进制位！）\n\n整数源码公式：\n![](https://upload-images.jianshu.io/upload_images/9031347-168b988aaf83de4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 二、补码\n\n# 三、反码\n');
INSERT INTO `blog_content` VALUES (99, '```今天看到《看透SpringMVC源代码分析与实践》的相关协议与标准中看到计算机网络相关知识，现在整理下自己的理解；```\n参考博客(有更详细内容)：https://www.jianshu.com/p/9968b16b607e\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;https://github.com/jawil/blog/issues/14\n#DNS协议\nDNS属于应用层协议，他提供将易于理解的主机名或域名转换成计算机网络能识别的数字地址的机制，使我们不用记住复杂的数字地址访问网址！\n在windows中我们可以通过```nslookup```命令查看DNS的解析信息：\n![](https://upload-images.jianshu.io/upload_images/9031347-a15b23d7cf577663.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 这里显示的是我们使用nslookup命令查看解析百度网址的信息，由图可知，DNS服务器的名称是UnKnow（未知）IP地址是192.168.1.1，而www.baidu.com的ip地址是119.75.216.20、119.75.213.61，它是使用CNAME方式解析的，原始设置的域名为：www.a.shifen.com。\n\n#TCP/IP协议与socket\nTCP（Transmission Control Protocol）是运行在运输层上的协议，负责具体的传输工作；而IP协议运行在网络层，主要进行IP(Internet Protocol)地址的查找工作。书上运用快递的例子描写两者的功能：\n> 识别包裹上填写的地址并根据内容找到客户，属于IP协议的工作，发货运输到客户手里是TCP协议的工作！\n\n### 三次握手 四次挥手\n TCP传输协议是有连接的传输协议，必须经过三次握手使客户端和服务器端成功连接才会传输数据，最后断开时经过四次挥手断开连接！在这个过程中的相关概念及其含义如下表所示：\n|协议名|含义|\n|:--:|:--:|\n|seq|sequence number 的缩写，表示的是传输数据的序号，TCP传输的每个字节都有相应的序号，接受端会根据序号判断是否有数据丢失，如果有则请求重发，这样就保证了数据的完整性|\n|ack|acknowlegment number的缩写，表示的是接受数据后反馈的成功信息，它的值是当前接受数据的序号+1，表示的是下一个想要接受数据的信号|\n|ACK|当ACK的值为1的时候ack才能起作用，第一次发送请求的时候ACK的值为0，因为第一次没有数据的接受，ack没有值，所以ACK被设置成0|\n|SYN|表示同步位，连接的一开始是没有数据传输的，所以ack是没有值的，我们传输这样一个位的目的就是当其值为1时，直接设置ack的值为seq+1。需要注意的是，SYN会在前两次的值为1，因为两边的ack的值都需要初始化！|\n|FIN|终止位，请求端发送这个请求希望断开连接|\n![连接与数据传输](https://upload-images.jianshu.io/upload_images/9031347-c08c4a151055cc54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![断开](https://upload-images.jianshu.io/upload_images/9031347-f8a95d5c08f495c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 流程解析\n1. 客户发送连接请求，SYN=1、seq=x，ACK=0（因为之前没有数据传输，ack也就没有值）\n2. 接受到序号为x的数据，服务器返回序号为seq=y的数据，此时因为SYN=1，所以ack就是就直接等于接受到数据序号seq+1 即x + 1，ACK=1使ack起作用！\n3. 第三次握手与第二次同理！\n4. 然后就是数据传输了\n5. 客户发送请求FIN=1断开连接，发送数据序号为seq=u\n6. 服务器接收后返回ACK=1，所以ack=u+1，因为ack在连接时已经初始化完成，所以这里也就没有SYN信息。\n7. 后面两步是服务器发送断开请求，和前两步同理！\n> TIME-WAIT的作用：\n在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。\n\n###关于socket\nTCP/IP只不过是协议而不是可以实现功能的工具，而Socket是TCP/IP协议的一个具体的实现。Socket在后面博客中再详细讲！\n\n\n就先写到这吧，后面再补充！\n\n\n');
INSERT INTO `blog_content` VALUES (100, '> http缓存机制在使用nginx设定静态资源是否被缓存时就会被用到，当初做项目时就遇到这个触及我知识盲区的问题。所以现在整理下。\n像nginx、cdn等服务器端缓存具体用到时具体分析。这里主要了解浏览器端缓存！\n整理自 [孙世吉的http缓存控制小结]([https://imweb.io/topic/5795dcb6fb312541492eda8c]\n)\n[浏览器HTTP缓存详解]([https://my.oschina.net/leejun2005/blog/369148])\n# HTTP首部缓存控制字段\n## HTTP 1.0\n- expires：Mon, 22 Jul 2002 11:12:01 GMT ，固定GMT（格林尼治时间），但局限于每个地方的时区不同，所以在http1.1中一般不用。\n- pragma：no-cache 在http1.0中表示不缓存，每次请求都访问服务器。\n\n## HTTP 1.1：\n- 针对上述expires无法统一客户端时间问题，http1.1推出了cache-control，其设置的是相对时间，精确到秒，过了这段时间即表示资源过期。但为了向下兼容，还是保留expires。优先级为 pragam>cache-control>expires。\ncache-control存在以下值：\n请求报文中：\n\n|字段|含义|\n|:--|:--|\n|no-cache|告知（代理）服务器不使用缓存，直接向原服务器请求|\n|no-store|所有内容都不会被保存到浏览器缓存或internet临时文件中！|\n|max-age=delta-seconds|告知服务器，客户端希望接收一个存在时间不超过delta-seconds的资源|\n|max-stale[=delta-sonds]|指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。|\n|no-transform|告诉代理服务器客户端希望获取没有被转换（比如压缩）的数据|\n|only-if-cached|告知（代理）服务器客户端希望获取缓存，而不用想原服务器获取（若代理服务器有）|\n|cache-extension|自定义扩展值，服务器无法识别则忽略！|\n\n响应报文中：\n\n|字段|含义|\n|:--|:--|\n|public|则即使它有关联的 HTTP 身份验证，甚至响应状态代码通常无法缓存，也可以缓存响应。 大多数情况下，“public”不是必需的，因为明确的缓存信息（例如“max-age”）已表示响应是可以缓存的。|\n|private[=“field-name”]|这些响应通常只为单个用户缓存，因此不允许任何中间缓存对其进行缓存。 例如，用户的浏览器可以缓存包含用户私人信息的 HTML 网页，但 CDN 却不能缓存。|\n|no-cache|必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。 因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则可避免下载。|\n|no-store| 它直接禁止浏览器以及所有中间缓存存储任何版本的返回响应，例如，包含个人隐私数据或银行业务数据的响应。 每次用户请求该资产时，都会向服务器发送请求，并下载完整的响应。|\n|no-transform|客户端缓存时不得转换数据|\n|max-age=delta-seconds|指令指定从请求的时间开始，允许提取的响应被重用的最长时间（单位：秒）。 例如，“max-age=60”表示可在接下来的 60 秒缓存和重用响应。|\n|must-revalidate|略|\n|proxy-revalidate|略|\n|s-max-age=delta-seconds|略|\n```\nCache-Control 允许自由组合可选值，例如：\nCache-Control: max-age=3600, must-revalidate\n```\n![这张图简单明了](https://upload-images.jianshu.io/upload_images/9031347-d3853d7af14c11fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 数据校验字段\n缓存在客户端的数据有了控制过期的时间，当过期了或者是有相关设置每次一定要访问服务器检验有效期，都会连接服务器访问服务器，检验是否真的需要更新本地缓存，觉得返回200还是304。原文一个形象的例子：\n```\nC：小服，你几岁了？\nS：小客，我18岁了。(200)\n=================================\nC：小服 ，你几岁了？我猜你18岁了。\nS：靠，你知道还问我？（服务器检验，未过期，返回304）\n=================================\nC：小服 ，你几岁了？我猜你18岁了。\nS：小客 ，我19岁了。（服务器检验已过期，返回数据与状态码200）\n```\n\n## 1. Last-Modified\n服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。\n```Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT```\n客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码，内容为空，这样就节省了传输数据量 。如果两个时间不一致，则服务器会发回该资源并返回200状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个304响应比一个静态资源通常小得多，这样就节省了网络带宽。\n## If-Modified-Since\n和Last-Modified对应，服务器返回的资源最后修改时间在请求检验时会被放在这个字段值中，用来和服务器资源最后修改时间对比！\n![前两个字段的使用](https://upload-images.jianshu.io/upload_images/9031347-f74113bfae6b6f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##  If-Unmodified-Since\n该值告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回412(Precondition Failed) 状态码给客户端。 Last-Modified 存在一定问题，如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。\n\n## 2. ETag\n前面的cache-control时间能精确到秒，但是如果资源的改动在秒以内，检验就存在不确定性了。为了解决上述Last-Modified可能存在的不准确的问题，Http1.1还推出了 ETag 实体首部字段。\n其本质是资源子服务器中各种信息通过某一种算法生成的一种唯一标识。如Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。\n```Etag: \"5d8c72a5edda8d6a:3239\"```\n同理还有两个检验信息\n\n## If-None-Match\n示例为 If-None-Match: \"5d8c72a5edda8d6a:3239\" 告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送304 和响应报头即可。 当前各浏览器均是使用的该请求首部来向服务器传递保存的 ETag 值。\n## If-Match\n告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段。\n需要注意的是，如果资源是走分布式服务器（比如CDN）存储的情况，需要这些服务器上计算ETag唯一值的算法保持一致，才不会导致明明同一个文件，在服务器A和服务器B上生成的ETag却不一样。\n');
INSERT INTO `blog_content` VALUES (101, '> 本来这部分内容是用笔记在goodnotes上的，但感觉书写体验并不是那么好，又觉得整个过程又可以比较详细具体地复习linux和计算机网络课上的部分知识，所以还是认真写篇博客记录下吧！\n\n可以分如下步骤具体阐述：\n- [浏览器缓存解析](https://www.jianshu.com/p/6125caaaf2f5)\n- DNS解析\n- TCP连接\n- SSL/TLS协议保证安全\n- http协议\n- 浏览器渲染页面\n');
INSERT INTO `blog_content` VALUES (102, '> 转自 http://f543711700.iteye.com/blog/978044\n\nQQ是一个基于TCP/UDP协议的通讯软件 \n\n发送消息的时候是UDP打洞,登陆的时候使用HTTP~因为登陆服务器其实就是一个HTTP服务器,只不过不是常用的那些,那个服务器是腾讯自行开发的！！！ \n\n# 登录 \n\nQQ客户端在局域网内，当你打开QQ登录到QQ服务器时，通过外网，你的客户端与QQ服务器建立了一个长连接。你可以用netstat -bn  看到此连接的状态是 establish \n\n\n此时，在QQ服务器那面看到的连接的IP是你们局域网对外的IP。举个例子：       \nQQ服务器      IP：124.115.11.81     服务端口：80       \n你的机器在局域网中内部IP：   10.19.9.89       \n你局域网出口InternetIP：  61.183.172.149       \n你的客户端的请求将通过外网出去，如果防火墙没有禁止访问Internet上80端口服务，那么你的QQ客户端可以正常登录。你看到的连接是 （netstat  -bn）       \n10.19.9.89:55579           124.115.11.81：80    establish       \n      \n这是一个假象。通过QQ服务器看到的连接是：       \n124.115.11.81：80      61.183.172.149：31234    establish       \n      \n这样，防火墙上的31234口对应的就是你机器的55579口。（由于你是发起方，这个数是变化的。动态的）       \n当有信息给你时，QQ服务器只需要发给防火墙的55579口即可。（这里防火墙作了地址翻译）       \n      \n不管UDP还是TCP，最终登陆成功之后，QQ都会有一个TCP连接来保持在线状态。这个TCP连接的远程端口一般是80，采用UDP方式登陆的时候，端口是8000。因此，假如你所在的网络开放了80端口（80端口是最常用端口。。就是通常访问Web的端口，禁掉它的话，你的网络对你来说价值已经不大了），但没有屏蔽腾讯的服务器IP，恭喜你，你是可以登陆成功QQ的。 \n\n# 聊天消息通信 \n采用UDP协议，通过服务器中转方式。大家都知道，UDP 协议是不可靠协议，它只管发送，不管对方是否收到的，但它的传输很高效。但是，作为聊天软件，怎么可以采用这样的不可靠方式来传输消息呢？于是，腾讯采用了上层协议来保证可靠传输：如果客户端使用UDP协议发出消息后，服务器收到该包，需要使用UDP协议发回一个应答包。如此来保证消息可以无遗漏传输。之所以会发生在客户端明明看到“消息发送失败”但对方又收到了这个消息的情况，就是因为客户端发出的消息服务器已经收到并转发成功，但客户端由于网络原因没有收到服务器的应答包引起的。 \n\n因为用户一般都是在局域网内,地址都为私有IP,腾讯服务器是如何将信息转发到用户的? \n\n#先介绍一些基本概念： \nNAT(Network AddressTranslators)，网络地址转换：网络地址转换是在IP地址日益缺乏的情况下产生的，它的主要目的就是为了能够地址重用。NAT分为两大类，基本的NAT和NAPT(Network Address/Port Translator)。 \n最开始NAT是运行在路由器上的一个功能模块。 \n   \n最先提出的是基本的NAT，它的产生基于如下事实：一个私有网（域）中的节点中只有很少的节点需要与外网连接（呵呵，这是在上世纪90年代中期提出的）。那么这个子网中其实只有少数的节点需要全球唯一的IP地址，其他的节点的IP地址应该是可以重用的。 \n   因此，基本的NAT实现的功能很简单，在子网内使用一个保留的IP子网段，这些IP对外是不可见的。子网内只有少数一些IP地址可以对应到真正全球唯一的IP地址。如果这些节点需要访问外部网络，那么基本NAT就负责将这个节点的子网内IP转化为一个全球唯一的IP然后发送出去。(基本的NAT会改变IP包中的原IP地址，但是不会改变IP包中的端口) \n    关于基本的NAT可以参看RFC 1631 \n   \n   另外一种NAT叫做NAPT，从名称上我们也可以看得出，NAPT不但会改变经过这个NAT设备的IP数据报的IP地址，还会改变IP数据报的TCP/UDP端口。基本NAT的设备可能我们见的不多（呵呵，我没有见到过），NAPT才是我们真正讨论的主角。看下图： \n```\n                                Server S1                        \n                         18.181.0.31:1235                         \n                                      | \n          ^  Session 1 (A-S1)  ^      | \n          |  18.181.0.31:1235  |      |  \n          v 155.99.25.11:62000 v      |   \n                                      | \n                                     NAT \n                                 155.99.25.11 \n                                      | \n          ^  Session 1 (A-S1)  ^      | \n          |  18.181.0.31:1235  |      | \n          v   10.0.0.1:1234    v      | \n                                      | \n                                   Client A \n                                10.0.0.1:1234 \n```\n   有一个私有网络10.*.*.*，ClientA是其中的一台计算机，这个网络的网关（一个NAT设备）的外网IP是155.99.25.11(应该还有一个内网的IP地址，比如10.0.0.10)。如果Client A中的某个进程（这个进程创建了一个UDPSocket,这个Socket绑定1234端口）想访问外网主机18.181.0.31的1235端口，那么当数据包通过NAT时会发生什么事情呢？ \n   首先NAT会改变这个数据包的原IP地址，改为155.99.25.11。接着NAT会为这个传输创建一个Session（Session是一个抽象的概念，如果是TCP，也许Session是由一个SYN包开始，以一个FIN包结束。而UDP呢，以这个IP的这个端口的第一个UDP开始，结束呢，呵呵，也许是几分钟，也许是几小时，这要看具体的实现了）并且给这个Session分配一个端口，比如62000，然后改变这个数据包的源端口为62000。所以本来是（10.0.0.1:1234->18.181.0.31:1235）的数据包到了互联网上变为了（155.99.25.11:62000->18.181.0.31:1235）。 \n一旦NAT创建了一个Session后，NAT会记住62000端口对应的是10.0.0.1的1234端口，以后从18.181.0.31发送到62000端口的数据会被NAT自动的转发到10.0.0.1上。（注意：这里是说18.181.0.31发送到62000端口的数据会被转发，其他的IP发送到这个端口的数据将被NAT抛弃）这样Client A就与Server S1建立以了一个连接。 \n\n上面的基础知识可能很多人都知道了，那么下面是关键的部分了。 \n    看看下面的情况： \n```\n    Server S1                                     Server S2 \n18.181.0.31:1235                              138.76.29.7:1235 \n        |                                             | \n        |                                             | \n        +----------------------+----------------------+ \n                               | \n   ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^ \n   |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  | \n   v 155.99.25.11:62000 v      |      v 155.99.25.11:62000 v \n                               | \n                            Cone NAT \n                          155.99.25.11 \n                               | \n   ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^ \n   |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  | \n   v   10.0.0.1:1234    v      |      v   10.0.0.1:1234    v \n                               | \n                            Client A \n                         10.0.0.1:1234 \n```\n接上面的例子，如果Client A的原来那个Socket(绑定了1234端口的那个UDP Socket)又接着向另外一个Server S2发送了一个UDP包，那么这个UDP包在通过NAT时会怎么样呢？ \n这时可能会有两种情况发生，一种是NAT再次创建一个Session，并且再次为这个Session分配一个端口号（比如：62001）。另外一种是NAT再次创建一个Session，但是不会新分配一个端口号，而是用原来分配的端口号62000。前一种NAT叫做SymmetricNAT，后一种叫做ConeNAT。我们期望我们的NAT是第二种，呵呵，如果你的NAT刚好是第一种，那么很可能会有很多P2P软件失灵。（可以庆幸的是，现在绝大多数的NAT属于后者，即Cone NAT） \n  \n我们看到，通过NAT,子网内的计算机向外连结是很容易的（NAT相当于透明的，子网内的和外网的计算机不用知道NAT的情况）。 \n但是如果外部的计算机想访问子网内的计算机就比较困难了（而这正是P2P所需要的）。 \n那么我们如果想从外部发送一个数据报给内网的计算机有什么办法呢？首先，我们必须在内网的NAT上打上一个“洞”（也就是前面我们说的在NAT上建立一个Session），这个洞不能由外部来打，只能由内网内的主机来打。而且这个洞是有方向的，比如从内部某台主机（比如：192.168.0.10）向外部的某个IP(比如：219.237.60.1)发送一个UDP包，那么就在这个内网的NAT设备上打了一个方向为219.237.60.1的“洞”，（这就是称为UDP HolePunching的技术）以后219.237.60.1就可以通过这个洞与内网的192.168.0.10联系了。（但是其他的IP不能利用这个洞）。 \n\n# 说回正题\n现在该轮到我们的正题P2P了。有了上面的理论，实现两个内网的主机通讯就差最后一步了：两边都无法主动发出连接请求，谁也不知道谁的公网地址，那我们如何来打这个洞呢？我们需要一个中间人来联系这两个内网主机。  \n    现在我们来看看一个P2P软件的流程，以下图为例： \n```\n                       Server S （219.237.60.1）\n                                  | \n                                  | \n   +-----------------------+----------------------+ \n   |                                             | \nNAT A (外网IP:202.187.45.3)                 NAT B (外网IP:187.34.1.56) \n   |   (内网IP:192.168.0.1)                      | (内网IP:192.168.0.1) \n   |                                             | \nClient A  (192.168.0.20:60000)             Client B (192.168.0.10:40000) \n```\n首先，Client A登录服务器，NAT A为这次的Session分配了一个端口60000，那么ServerS收到的Client A的地址是202.187.45.3:60000，这就是Client A的外网地址了。同样，ClientB登录Server S，NAT B给此次Session分配的端口是40000，那么ServerS收到的B的地址是187.34.1.56:40000。 \n此时，Client A与Client B都可以与ServerS通信了。如果Client A此时想直接发送信息给Client B，那么他可以从ServerS那儿获得B的公网地址187.34.1.56:40000，是不是Client A向这个地址发送信息ClientB就能收到了呢？答案是不行，因为如果这样发送信息，NATB会将这个信息丢弃（因为这样的信息是不请自来的，为了安全，大多数NAT都会执行丢弃动作）。那该怎么办呢？   首先我们假设Server S是219.237.60.1：7000，当Clinet A（202.187.45.3：60000）向Server S（219.237.60.1：7000）发送数据包，Server S是可以正常接收到数据，因为它是属于外型开放的服务器端口。当Server S收到数据包后可以获知Clinet A（202.187.45.3：60000）对外通信的临时session信息（这个叫临时的端口，假设是60000会过期，具体时间不同，一般是每30S发送一个keep住连接以保证端口维持通信连接不断）Server S此时应将次信息保存起来。而同时，Client B (192.168.0.10:40000)也在时刻向 \nServer S发送心跳包，Server S就向Client B (192.168.0.10:40000)发送一个通知，让Client B  (192.168.0.10:4000) 发送探测包（这个数据包最好发几个），Client B  (192.168.0.10:4000)在收到通知后在向Server S发送反馈包，说明以向自己以向Client A  (192.168.0.20:60000)发送了探测包，Server S在收到反馈之后再向Client A  (192.168.0.20:60000)转发反馈包，Client A  (192.168.0.20:60000)在收到数据包之后在向原本要求请求的Client B  (192.168.0.10:4000)发送数据包，此时连接已经打通，实现穿透。Client B  (192.168.0.10:4000)会将数据包转发给 \nClient A  (192.168.0.20:60000)从而在转发给内网内网IP:192.168.0.1。 \n\n对于Symmetric NAPT的情况，网上有人说可以通过探测端口的方式，不过成功率并不高，我建议可用服务器进行中转。另外，最好在数据包发送前先检测是否进行的是同个NAT的情况，也就是内网发内网，如果是，直接发送即可，而无需通过外网再绕回来。\n');
INSERT INTO `blog_content` VALUES (103, '大三，对于当初还在为学生会焦头烂额的大一的我来说，大三是多么遥远的事。可就在一节节课下了又上，一个个期待的周末来了又走的平淡日子里，即使是时间飞逝也不能察觉一分，就像歌里唱的那样“毕业总遥遥无期”，此刻虽没有各奔东西，但也能看见不久的将来，走出校门的我眼中的茫然。我不是害怕分别，也不是为这舒适的大学生活而惋惜，只是觉得自己的能力还无法经受住社会的考验，从踏入大三的那一刻起，那看不见的危机感便悄然而至，如影随形。\n虽然想在大学的后半段悬崖勒马，好好珍惜每天的学习时光，可是这永远上不去的学习效率，让所有学习的时间，都显得事倍功半。\n');
INSERT INTO `blog_content` VALUES (104, '--------------------\n2019-03-05\n1.  当mybatis有多个参数是就不需要parameterType了，可以封装成map（这个要），可以使用参数序号  #{1}，可以在方法参数上注解@Param(\"passwordEmail\") String passwordEmail等\n2. mybaits的xml中判断一个字符串是否为空字符串的方式：可以直接调用java的方法：\n    “!@org.springframework.util.StringUtils@isEmpty(passwordEmail)”（但必须是静态方法！）\n    判断passwordEmail是否为空！\n3. 纠结了好久POJO类中使用基本类型还是包装类，包装类在堆中创建，速率相对基本类型较慢，而且会造成内存泄漏但基本类型接受null会报错。然后突然看到阿里规范手册上说POJO统一使用包装类，看到这个就放心了，阿里都发话了！\n4. postman如何传递@requestBody获取的参数：\n![](https://upload-images.jianshu.io/upload_images/9031347-a999a8f393b06504.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n5. 会话设置setMaxInactiveInterval参数单位是**秒**！\n6. String的getByte默认字符编码即是ISO-8859-1\n7. getSession（）参数设置为true肯定新建一个，这也是为什么今晚出现找不到session的bug的原因！\n8. 注意mapper方法返回值一定要为包装类，不然没有值返回null就会报错！\n9. 使用触发器或存储过程还是使用代码实现业务逻辑，这是个问题，查阅各大论坛博客，决定还是使用代码去实现。很多人说存储过程和触发器虽然运行快，节约流量，但是维护难，使存储结构复杂，最先崩的就是这层。但是如果其所涉及数据少，关系简单，还是可以使用下的。我权衡了下，还是代码+事务操作吧！\n\n\n-----------------------------------\n2019-9-29\n1. mvn打包时可以使用```mvn package -Dmaven.test.skip=true```跳过测试！\n\n2. 看来在程序中使用相对路径也不行了！因为还有运行jar包的时候，此时就找不到相关目录了！（多种方法，去查！）\n\n3. DTO :data transport object\nDO: data object，通常对应于一张数据库表\n VO：view object，一个页面显示数据的封装！\n> 这些object类型都是可以用在项目中的！\n\n\n4. SpringBoot 热部署工具\n```xml\n<dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-devtools</artifactId>\n      <optional>true</optional>\n</dependency>\n```\n5. guava和apache common！！！ swagger实现前后端分离（第一步搞清楚是不是后端必会的？）Joda-time处理时间！！commons-lang3字符串处理工具！\n6. spring webflux记住喽学下！\n-----\n2019-9-30\n1. 记住喽：zookeeper之dubbo的关系就相当于Euraka对于spring boot的关系！\n2. dependencyManagement的作用是：\n> 来管理jar包的版本，让子项目中引用一个依赖而不用显示的列出版本号。Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement元素中指定的版本号。\n**好处**：统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，才能保证测试的和发布的是相同的成果，因此，在顶层pom中定义共同的依赖关系。同时可以避免在每个使用的子项目中都声明一个版本号，这样想升级或者切换到另一个版本时，只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个版本号时，只需要在dependencies中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。\n\n> 之前脑海中一直有个疑问：子模块能继承父模块的properties属性，为什么不直接在父模块中定义properties进行版本管理呢？\n答： 我觉得，dependencyManagement的作用是专门干这个的，其次management可以定义继承的scope，解决不能多继承和父模块dependencyManagement内容过多的问题。（还是没什么说服力啊！）\n\n> plugins和pluginManagement同理！\n');
INSERT INTO `blog_content` VALUES (105, '> 今日结合以往经历发现国外的许多技术文写的是真的好，内容详实，水准较高，即使是有些许语言障碍，都能让我如沐春风，了解到许多直接看中文无法或者很难了解的东西。也难怪，许多人都重点提及英语和英语原著的重要性！\n\n> 关于top的命令（真的很详细，有时间（没事干的时候）给翻译下来）：https://www.booleanworld.com/guide-linux-top-command/\n');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `content` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `blog_id` int(10) UNSIGNED NOT NULL COMMENT '评论所属文章',
  `user_id` int(10) UNSIGNED NOT NULL COMMENT '评论用户id',
  `reply_id` int(10) UNSIGNED NOT NULL COMMENT '回复的评论id，默认0，如果是直接评论父级的评论，则于parent_id相同',
  `parent_id` int(10) UNSIGNED NOT NULL COMMENT '所属父级评论，，默认0时属于的父级评论表示本身为父级评论',
  `create_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '评论时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for corpus
-- ----------------------------
DROP TABLE IF EXISTS `corpus`;
CREATE TABLE `corpus`  (
  `id` int(10) UNSIGNED NOT NULL DEFAULT 0,
  `name` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '',
  `user_id` int(10) UNSIGNED NOT NULL,
  `blog_num` int(10) UNSIGNED NOT NULL,
  `create_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '文集创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 29 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of corpus
-- ----------------------------
INSERT INTO `corpus` VALUES (1, 'Java', 1, 0, '2020-01-12 14:14:31');
INSERT INTO `corpus` VALUES (2, 'python', 1, 0, '2020-01-12 14:14:31');
INSERT INTO `corpus` VALUES (3, 'Go', 1, 0, '2020-01-12 14:14:31');
INSERT INTO `corpus` VALUES (4, 'Linux', 1, 0, '2020-01-12 14:14:31');
INSERT INTO `corpus` VALUES (5, 'docker', 1, 0, '2020-01-12 14:14:31');
INSERT INTO `corpus` VALUES (6, 'Spring', 1, 0, '2020-01-12 14:14:31');
INSERT INTO `corpus` VALUES (7, 'spring-boot', 1, 0, '2020-01-12 14:14:31');
INSERT INTO `corpus` VALUES (8, 'mybatis', 1, 0, '2020-01-12 14:14:31');
INSERT INTO `corpus` VALUES (9, 'Spring cloud', 1, 0, '2020-01-12 14:14:32');
INSERT INTO `corpus` VALUES (10, '心得', 1, 0, '2020-01-12 14:14:32');
INSERT INTO `corpus` VALUES (11, 'SpringMVC', 1, 0, '2020-01-12 14:14:32');
INSERT INTO `corpus` VALUES (12, 'ElasticSearch', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (13, 'J2ee', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (14, 'shiro', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (15, 'spring-cloud', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (16, '一些错误', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (17, '听课简记', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (18, '工具', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (19, '想', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (20, '操作系统', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (21, '数据库', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (22, '数据结构与算法', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (23, '来自CSDN的文章', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (24, '消息队列', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (25, '缓存', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (26, '计算机组成原理', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (27, '计算机网络', 1, 0, '2020-01-14 13:06:23');
INSERT INTO `corpus` VALUES (28, '随笔', 1, 0, '2020-01-14 13:06:23');

-- ----------------------------
-- Table structure for love
-- ----------------------------
DROP TABLE IF EXISTS `love`;
CREATE TABLE `love`  (
  `user_id` int(10) UNSIGNED NOT NULL,
  `blog_id` int(10) UNSIGNED NOT NULL,
  `author_id` int(10) UNSIGNED NOT NULL COMMENT '文章作者id',
  `create_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '记住每篇文章记录赞的人要有上限，即只保存最新的几个用户点赞记录！',
  PRIMARY KEY (`user_id`, `blog_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for subscription
-- ----------------------------
DROP TABLE IF EXISTS `subscription`;
CREATE TABLE `subscription`  (
  `sub_id` int(10) UNSIGNED NOT NULL COMMENT '被关注的用户',
  `fan_id` int(11) UNSIGNED NOT NULL COMMENT '粉丝id',
  `sub_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '关注时间',
  `receive_msg` tinyint(1) UNSIGNED NOT NULL DEFAULT 0 COMMENT '是否接收动态消息提醒，默认不接收',
  PRIMARY KEY (`sub_id`, `fan_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for token
-- ----------------------------
DROP TABLE IF EXISTS `token`;
CREATE TABLE `token`  (
  `user_id` int(10) UNSIGNED NOT NULL,
  `login_token` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `latest_login_at` timestamp(0) NULL DEFAULT CURRENT_TIMESTAMP(0) ON UPDATE CURRENT_TIMESTAMP(0),
  UNIQUE INDEX `user_id_unique_index`(`user_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of token
-- ----------------------------
INSERT INTO `token` VALUES (1, '2bc2eeaec17e87e48c97c17fc899a76f', '2020-03-23 14:15:35');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `email` varchar(64) CHARACTER SET armscii8 COLLATE armscii8_general_ci NOT NULL DEFAULT '',
  `username` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '',
  `password` char(32) CHARACTER SET armscii8 COLLATE armscii8_general_ci NOT NULL DEFAULT '',
  `salt` char(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '',
  `avatar` varchar(512) CHARACTER SET armscii8 COLLATE armscii8_general_ci NOT NULL DEFAULT '' COMMENT '头像图片链接',
  `gender` bit(1) NOT NULL DEFAULT b'0' COMMENT '0男，1女，默认0',
  `blog_num` int(11) UNSIGNED NOT NULL DEFAULT 0,
  `corpus_num` int(11) UNSIGNED NOT NULL DEFAULT 0,
  `word_num` bigint(20) UNSIGNED NOT NULL DEFAULT 0 COMMENT '文章总字数',
  `sub_num` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '关注（订阅）其他用户数量',
  `fan_num` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '粉丝数量',
  `person_msg` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT '' COMMENT '个性签名',
  `register_at` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '用户注册时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'heshaowen@qq.com', 'nobug_1', 'b71a8a73f90c15745ea03b655c5e5727', '6256875882473110', 'https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcQbQcMdgigNh2jDn3MSidF8qy8MZP0JOLGshm0V8qL63RV6BIg8', b'0', 96, 28, 47396, 0, 0, '', '2020-03-23 13:43:36');

SET FOREIGN_KEY_CHECKS = 1;
